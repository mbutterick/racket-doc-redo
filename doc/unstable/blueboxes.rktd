12402
((3) 0 () 35 ((q lib "unstable/list.rkt") (q lib "unstable/temp-c/monitor.rkt") (q lib "unstable/automata/machine.rkt") (q 20743 . 18) (q lib "unstable/options.rkt") (q lib "unstable/automata/re.rkt") (q 20265 . 16) (q lib "unstable/class-iop.rkt") (q lib "unstable/debug.rkt") (q lib "unstable/automata/re-ext.rkt") (q lib "unstable/logging.rkt") (q 0 . 3) (q lib "unstable/contract.rkt") (q lib "unstable/define.rkt") (q lib "unstable/markparam.rkt") (q lib "unstable/syntax.rkt") (q 70 . 3) (q lib "unstable/sequence.rkt") (q 20115 . 6) (q lib "unstable/function.rkt") (q lib "unstable/temp-c/dsl.rkt") (q lib "unstable/match.rkt") (q 20035 . 4) (q lib "unstable/custom-write.rkt") (q lib "unstable/error.rkt") (q lib "unstable/macro-testing.rkt") (q lib "unstable/socket.rkt") (q lib "unstable/future.rkt") (q lib "unstable/pretty.rkt") (q 13678 . 2) (q lib "unstable/hash.rkt") (q lib "unstable/parameter-group.rkt") (q lib "unstable/bytes.rkt") (q lib "unstable/automata/nfa-ep.rkt") (q lib "unstable/struct.rkt")) () (h ! (equal) ((c def c (c (? . 0) q drop-common-prefix)) q (10540 . 5)) ((c form c (c (? . 13) q in-phase1)) q (5943 . 2)) ((c def c (c (? . 0) q take-common-prefix)) q (10423 . 5)) ((c def c (c (? . 1) q monitor:return-proj-label)) c (? . 3)) ((c def c (c (? . 2) q machine-intersect)) q (678 . 4)) ((c form c (c (? . 5) q epsilon)) q (2327 . 2)) ((c def c (c (? . 1) q monitor:call-kw-args)) c (? . 6)) ((c def c (c (? . 12) q if/c)) q (2890 . 5)) ((c def c (c (? . 2) q struct:machine-accepting)) c (? . 16)) ((c def c (c (? . 0) q list-set)) q (12116 . 5)) ((c def c (c (? . 4) q has-option?)) q (15584 . 3)) ((c def c (c (? . 1) q monitor:return-app-label)) c (? . 3)) ((c form c (c (? . 25) q phase1-eval)) q (13411 . 8)) ((c def c (c (? . 19) q disjoin)) q (8436 . 4)) ((c form c (c (? . 8) q parameterize/debug)) q (5848 . 2)) ((c def c (c (? . 4) q exercise-option)) q (15385 . 3)) ((c form c (c (? . 7) q send/apply/i)) q (9825 . 2)) ((c form c (c (? . 5) q dseq)) q (2357 . 2)) ((c def c (c (? . 17) q in-pairs)) q (17647 . 3)) ((q form ((lib "unstable/2d/match.rkt") 2dmatch)) q (22923 . 22)) ((c def c (c (? . 1) q monitor:call-proj-label)) c (? . 6)) ((c def c (c (? . 23) q make-constructor-style-printer)) q (18433 . 6)) ((c def c (c (? . 0) q split-common-prefix)) q (10663 . 5)) ((c def c (c (? . 1) q monitor:proj-label)) c (? . 18)) ((c def c (c (? . 15) q make-variable-like-transformer)) q (18958 . 6)) ((c def c (c (? . 2) q machine-next)) c (? . 11)) ((c form c (c (? . 7) q init/i)) q (9956 . 2)) ((c def c (c (? . 0) q extend)) q (10887 . 5)) ((c form c (c (? . 8) q let*-values/debug)) q (5565 . 2)) ((c form c (c (? . 31) q parameterize*/group)) q (16584 . 5)) ((c def c (c (? . 1) q monitor:call-label)) c (? . 6)) ((c def c (c (? . 1) q monitor:return-args)) c (? . 3)) ((c form c (c (? . 9) q intersection)) q (2530 . 2)) ((c def c (c (? . 2) q machine-sigma*)) q (428 . 2)) ((q form ((lib "unstable/automata/nfa.rkt") nfa)) q (1193 . 11)) ((c def c (c (? . 10) q start-recording)) q (12981 . 3)) ((c def c (c (? . 1) q monitor:return?)) c (? . 3)) ((c form c (c (? . 8) q letrec/debug)) q (5432 . 2)) ((c form c (c (? . 9) q plus)) q (2442 . 2)) ((c def c (c (? . 10) q with-intercepted-logging)) q (12456 . 12)) ((c form c (c (? . 8) q let-values/debug)) q (5493 . 2)) ((c form c (c (? . 20) q ret)) q (21474 . 2)) ((c def c (c (? . 2) q struct:machine)) c (? . 11)) ((c form c (c (? . 5) q complement)) q (2273 . 2)) ((c def c (c (? . 14) q mark-parameter-first)) q (13712 . 5)) ((c def c (c (? . 4) q waive-option)) q (15474 . 3)) ((c def c (c (? . 12) q maybe/c)) q (3206 . 3)) ((c form c (c (? . 13) q in-phase1/pass2)) q (5965 . 2)) ((c form c (c (? . 8) q let*/debug)) q (5373 . 2)) ((c def c (c (? . 2) q machine-accepts?/prefix-closed)) q (253 . 4)) ((c form c (c (? . 13) q at-end)) q (5921 . 2)) ((c def c (c (? . 24) q raise-syntax-error*)) q (6586 . 15)) ((c form c (c (? . 5) q seq)) q (2291 . 2)) ((c def c (c (? . 14) q mark-parameters-all)) q (14036 . 6)) ((c def c (c (? . 2) q machine-epsilon)) q (393 . 2)) ((c def c (c (? . 15) q syntax-source-directory)) q (19867 . 3)) ((c def c (c (? . 12) q failure-result/c)) q (3064 . 2)) ((c form c (c (? . 7) q define/i)) q (9913 . 2)) ((c form c (c (? . 8) q with-syntax*/debug)) q (5780 . 2)) ((c def c (c (? . 8) q dprintf)) q (4588 . 4)) ((c def c (c (? . 2) q machine-accepting-next)) c (? . 16)) ((c def c (c (? . 0) q remf)) q (11613 . 4)) ((c form c (c (? . 27) q for/async)) q (8238 . 2)) ((q form ((lib "unstable/open-place.rkt") open-place)) q (14683 . 2)) ((c def c (c (? . 28) q break-lines)) q (17275 . 4)) ((c def c (c (? . 1) q struct:monitor:call)) c (? . 6)) ((c def c (c (? . 4) q invariant/c)) q (15712 . 11)) ((c def c (c (? . 26) q unix-socket-available?)) q (21577 . 2)) ((c def c (c (? . 2) q machine?)) c (? . 11)) ((c def c (c (? . 0) q group-by)) q (11694 . 5)) ((c form c (c (? . 9) q difference)) q (2490 . 2)) ((c form c (c (? . 8) q debugf)) q (4672 . 5)) ((c def c (c (? . 14) q mark-parameter?)) c (? . 29)) ((c def c (c (? . 1) q struct:monitor)) c (? . 22)) ((c def c (c (? . 17) q in-sequence-forever)) q (17710 . 4)) ((c form c (c (? . 8) q begin/debug)) q (4794 . 2)) ((q form ((lib "unstable/2d/tabular.rkt") 2dmatch)) q (23757 . 26)) ((c form c (c (? . 8) q debug)) q (4485 . 5)) ((c def c (c (? . 0) q map/values)) q (11313 . 5)) ((c def c (c (? . 15) q syntax-length)) q (19784 . 3)) ((c def c (c (? . 2) q machine-complement)) q (462 . 3)) ((c def c (c (? . 2) q machine)) c (? . 11)) ((c form c (c (? . 7) q send/i)) q (9684 . 2)) ((c def c (c (? . 1) q monitor:call)) c (? . 6)) ((c def c (c (? . 1) q struct:monitor:proj)) c (? . 18)) ((c form c (c (? . 5) q union)) q (2302 . 2)) ((c def c (c (? . 19) q conjoin)) q (8339 . 4)) ((c form c (c (? . 8) q define/override/debug)) q (5075 . 3)) ((c form c (c (? . 7) q init-private/i)) q (10086 . 5)) ((c form c (c (? . 8) q with-syntax/debug)) q (5713 . 2)) ((c form c (c (? . 21) q as)) q (14355 . 2)) ((c def c (c (? . 1) q monitor:call-f)) c (? . 6)) ((c form c (c (? . 33) q nfa/ep)) q (1479 . 14)) ((c def c (c (? . 15) q format-unique-id)) q (19169 . 13)) ((c form c (c (? . 20) q with-monitor)) q (21498 . 2)) ((c def c (c (? . 1) q monitor:proj?)) c (? . 18)) ((c def c (c (? . 14) q mark-parameter-all)) q (13875 . 5)) ((c form c (c (? . 15) q phase-of-enclosing-module)) q (18923 . 2)) ((c form c (c (? . 7) q send*/i)) q (9750 . 2)) ((c form c (c (? . 21) q match?)) q (14319 . 2)) ((c def c (c (? . 1) q monitor?)) c (? . 22)) ((c def c (c (? . 23) q prop:auto-custom-write)) q (18713 . 2)) ((c def c (c (? . 17) q in-slice)) q (17899 . 4)) ((q form ((lib "unstable/automata/dfa.rkt") dfa)) q (959 . 11)) ((c def c (c (? . 1) q monitor:call-kws)) c (? . 6)) ((c def c (c (? . 24) q compose-error-message)) q (7371 . 13)) ((c def c (c (? . 0) q filter-multiple)) q (10795 . 4)) ((c def c (c (? . 1) q struct:monitor:return)) c (? . 3)) ((c def c (c (? . 32) q write/bytes)) q (2664 . 3)) ((c form c (c (? . 25) q convert-syntax-error)) q (13642 . 2)) ((c def c (c (? . 26) q unix-socket-path?)) q (21733 . 3)) ((c form c (c (? . 20) q label)) q (21543 . 2)) ((c def c (c (? . 12) q sequence/c)) q (3311 . 5)) ((c def c (c (? . 1) q monitor:call-args)) c (? . 6)) ((c def c (c (? . 12) q treeof)) q (3511 . 3)) ((c def c (c (? . 4) q transfer/c)) q (15443 . 2)) ((c def c (c (? . 24) q compose-error-detail)) q (8070 . 5)) ((c form c (c (? . 5) q re)) q (1926 . 15)) ((c form c (c (? . 27) q for*/async)) q (8288 . 2)) ((c form c (c (? . 8) q define/debug)) q (4826 . 3)) ((c def c (c (? . 2) q machine-union)) q (590 . 4)) ((q def ((lib "unstable/wrapc.rkt") wrap-expr/c)) q (3592 . 19)) ((c form c (c (? . 7) q init-field/i)) q (10018 . 2)) ((c def c (c (? . 4) q has-option-with-contract?)) q (15641 . 3)) ((c form c (c (? . 7) q define-interface-expander)) q (10222 . 2)) ((c form c (c (? . 7) q define-interface)) q (9539 . 2)) ((c form c (c (? . 7) q define-interface/dynamic)) q (9613 . 2)) ((c def c (c (? . 1) q monitor:return-kws)) c (? . 3)) ((c def c (c (? . 28) q pretty-format/write)) q (16745 . 5)) ((c def c (c (? . 10) q with-logging-to-port)) q (12260 . 5)) ((c def c (c (? . 2) q machine-null)) q (361 . 2)) ((q def ((lib "unstable/string.rkt") regexp-filter)) q (18009 . 5)) ((c def c (c (? . 2) q machine-star)) q (529 . 3)) ((c form c (c (? . 25) q convert-compile-time-error)) q (13600 . 2)) ((c form c (c (? . 9) q rep)) q (2464 . 2)) ((c def c (c (? . 2) q machine-seq)) q (770 . 4)) ((c form c (c (? . 9) q opt)) q (2421 . 2)) ((c def c (c (? . 30) q hash-union!)) q (9048 . 11)) ((c def c (c (? . 12) q tcp-listen-port?)) q (2821 . 2)) ((c def c (c (? . 14) q mark-parameter)) c (? . 29)) ((c form c (c (? . 8) q let/debug)) q (5255 . 3)) ((c def c (c (? . 0) q list-prefix?)) q (10346 . 4)) ((c def c (c (? . 1) q monitor:call-app-label)) c (? . 6)) ((c def c (c (? . 0) q map2)) q (11490 . 4)) ((c def c (c (? . 1) q monitor:return-kw-args)) c (? . 3)) ((q form ((lib "unstable/lazy-require.rkt") begin-on-demand)) q (10279 . 3)) ((c form c (c (? . 21) q match*?)) q (14404 . 2)) ((c form c (c (? . 9) q seq/close)) q (2572 . 2)) ((c form c (c (? . 8) q define/public/debug)) q (4988 . 3)) ((c def c (c (? . 1) q monitor)) c (? . 22)) ((c def c (c (? . 30) q hash-union)) q (8533 . 12)) ((c form c (c (? . 14) q mark-parameterize)) q (14257 . 2)) ((c def c (c (? . 0) q list-update)) q (11952 . 5)) ((c form c (c (? . 5) q nullset)) q (2342 . 2)) ((c def c (c (? . 12) q path-piece?)) q (2858 . 2)) ((c form c (c (? . 8) q define/augment/debug)) q (5166 . 3)) ((c def c (c (? . 10) q stop-recording)) q (13117 . 7)) ((c def c (c (? . 15) q explode-module-path-index)) q (18785 . 4)) ((c form c (c (? . 8) q letrec-values/debug)) q (5638 . 2)) ((c def c (c (? . 15) q syntax-within?)) q (19701 . 4)) ((c def c (c (? . 1) q monitor/c)) q (21294 . 5)) ((c def c (c (? . 1) q monitor:return-rets)) c (? . 3)) ((c def c (c (? . 1) q monitor:proj)) c (? . 18)) ((c form c (c (? . 20) q call)) q (21449 . 2)) ((c def c (c (? . 4) q option/c)) q (14719 . 15)) ((c def c (c (? . 1) q monitor:proj-v)) c (? . 18)) ((c def c (c (? . 2) q machine-accepting?)) c (? . 16)) ((c def c (c (? . 12) q non-empty-string?)) q (2725 . 3)) ((c def c (c (? . 1) q monitor:return-label)) c (? . 3)) ((c form c (c (? . 5) q define-re-transformer)) q (2380 . 2)) ((c def c (c (? . 26) q unix-socket-connect)) q (21619 . 3)) ((q def ((lib "unstable/sandbox.rkt") make-log-based-eval)) q (17447 . 4)) ((c def c (c (? . 1) q monitor:return)) c (? . 3)) ((c def c (c (? . 0) q cartesian-product)) q (11861 . 3)) ((c def c (c (? . 24) q error*)) q (5993 . 13)) ((c def c (c (? . 1) q monitor:return-f)) c (? . 3)) ((c form c (c (? . 5) q star)) q (2315 . 2)) ((q form ((lib "unstable/recontract.rkt") recontract-out)) q (17414 . 2)) ((c form c (c (? . 31) q parameterize/group)) q (16424 . 5)) ((c def c (c (? . 31) q parameter-group?)) q (16168 . 3)) ((c def c (c (? . 1) q monitor:proj-proj-label)) c (? . 18)) ((c def c (c (? . 32) q read/bytes)) q (2604 . 3)) ((c form c (c (? . 33) q epsilon)) q (1464 . 2)) ((c def c (c (? . 12) q port-number?)) q (2788 . 2)) ((c def c (c (? . 28) q pretty-format/print)) q (17099 . 5)) ((c form c (c (? . 31) q define-parameter-group)) q (16230 . 7)) ((c def c (c (? . 4) q tweak-option)) q (15529 . 3)) ((c def c (c (? . 1) q monitor-label)) c (? . 22)) ((c def c (c (? . 2) q machine-accepts?)) q (159 . 4)) ((c def c (c (? . 14) q struct:mark-parameter)) c (? . 29)) ((c def c (c (? . 17) q sequence-lift)) q (17807 . 4)) ((c form c (c (? . 8) q define/private/debug)) q (4899 . 3)) ((c def c (c (? . 15) q syntax-source-file-name)) q (19951 . 3)) ((c form c (c (? . 34) q make)) q (18238 . 2)) ((c def c (c (? . 2) q machine-seq*)) q (856 . 4)) ((c def c (c (? . 34) q struct->list)) q (18274 . 4)) ((c def c (c (? . 1) q monitor:call?)) c (? . 6)) ((c def c (c (? . 0) q check-duplicate)) q (10978 . 8)) ((c def c (c (? . 28) q pretty-format/display)) q (16921 . 5)) ((c def c (c (? . 12) q truth/c)) q (3278 . 2)) ((c def c (c (? . 2) q machine-accepting)) c (? . 16)) ((c form c (c (? . 21) q object)) q (14455 . 10)) ((c def c (c (? . 17) q in-syntax)) q (17585 . 3)) ((c def c (c (? . 12) q rename-contract)) q (3101 . 4)) ((q form ((lib "unstable/2d/cond.rkt") 2dcond)) q (21796 . 33)) ((c form c (c (? . 5) q rec)) q (2369 . 2))))
struct
(struct machine (next))
  next : (any/c . -> . machine?)
struct
(struct machine-accepting machine (next))
  next : (any/c . -> . machine?)
procedure
(machine-accepts? m i) -> boolean?
  m : machine?
  i : (listof any/c)
procedure
(machine-accepts?/prefix-closed m i) -> boolean?
  m : machine?
  i : (listof any/c)
value
machine-null : machine?
value
machine-epsilon : machine?
value
machine-sigma* : machine?
procedure
(machine-complement m) -> machine?
  m : machine?
procedure
(machine-star m) -> machine?
  m : machine?
procedure
(machine-union m0 m1) -> machine?
  m0 : machine?
  m1 : machine?
procedure
(machine-intersect m0 m1) -> machine?
  m0 : machine?
  m1 : machine?
procedure
(machine-seq m0 m1) -> machine?
  m0 : machine?
  m1 : machine?
procedure
(machine-seq* m0 make-m1) -> machine?
  m0 : machine?
  make-m1 : (-> machine?)
syntax
(dfa start
     (end ...)
     [state ([evt next-state]
             ...)]
     ...)
 
  start : identifier?
  end : identifier?
  state : identifier?
  next-state : identifier?
syntax
(nfa (start:id ...)
     (end:id ...)
     [state:id ([evt:expr (next-state:id ...)]
                ...)]
     ...)
 
  start : identifier?
  end : identifier?
  state : identifier?
  next-state : identifier?
syntax
epsilon
syntax
(nfa/ep (start:id ...)
        (end:id ...)
        [state:id ([epsilon (epsilon-state:id ...)]
                   ...
                   [evt:expr (next-state:id ...)]
                   ...)]
        ...)
 
  start : identifier?
  end : identifier?
  state : identifier?
  epsilon-state : identifier?
  next-state : identifier?
syntax
(re re-pat)
 
re-pat = (rec id re-pat)
       | ,expr
       | (complement re-pat)
       | (seq re-pat ...)
       | (union re-pat ...)
       | (star re-pat)
       | epsilon
       | nullset
       | re-transformer
       | (re-transformer . datum)
       | (dseq pat re-pat)
       | pat
syntax
complement
syntax
seq
syntax
union
syntax
star
syntax
epsilon
syntax
nullset
syntax
dseq
syntax
rec
syntax
(define-re-transformer id expr)
syntax
(opt re-pat)
syntax
(plus re-pat)
syntax
(rep re-pat num)
syntax
(difference re-pat_0 re-pat_1)
syntax
(intersection re-pat_0 re-pat_1)
syntax
(seq/close re-pat ...)
procedure
(read/bytes b) -> printable/c
  b : bytes?
procedure
(write/bytes v) -> bytes?
  v : printable/c
procedure
(non-empty-string? x) -> boolean?
  x : any/c
value
port-number? : contract?
value
tcp-listen-port? : contract?
value
path-piece? : contract?
procedure
(if/c predicate then-contract else-contract) -> contract?
  predicate : (-> any/c any/c)
  then-contract : contract?
  else-contract : contract?
value
failure-result/c : contract?
procedure
(rename-contract contract name) -> contract?
  contract : contract?
  name : any/c
procedure
(maybe/c contract) -> contract?
  contract : contract?
value
truth/c : flat-contract?
procedure
(sequence/c [#:min-count min-count]     
             elem/c ...)            -> contract?
  min-count : (or/c #f exact-nonnegative-integer?) = #f
  elem/c : contract?
procedure
(treeof elem-contract) -> contract?
  elem-contract : contract?
procedure
(wrap-expr/c  contract-expr            
              expr                     
             [#:positive pos-blame     
              #:negative neg-blame     
              #:name expr-name         
              #:macro macro-name       
              #:context context])  -> syntax?
  contract-expr : syntax?
  expr : syntax?
  pos-blame : (or/c syntax? string? module-path-index?
                    'from-macro 'use-site 'unknown)
            = 'use-site
  neg-blame : (or/c syntax? string? module-path-index?
                    'from-macro 'use-site 'unknown)
            = 'from-macro
  expr-name : (or/c identifier? symbol? string? #f) = #f
  macro-name : (or/c identifier? symbol? string? #f) = #f
  context : (or/c syntax? #f) = (current-syntax-context)
syntax
(debug options ... expr)
 
options = #:name name-expr
        | #:source srcloc-expr
procedure
(dprintf fmt arg ...) -> void?
  fmt : string?
  arg : any/c
syntax
(debugf function-expr argument ...)
 
argument = argument-expr
         | argument-keyword argument-expr
syntax
(begin/debug expr ...)
syntax
(define/debug id expr)
(define/debug (head args) body ...+)
syntax
(define/private/debug id expr)
(define/private/debug (head args) body ...+)
syntax
(define/public/debug id expr)
(define/public/debug (head args) body ...+)
syntax
(define/override/debug id expr)
(define/override/debug (head args) body ...+)
syntax
(define/augment/debug id expr)
(define/augment/debug (head args) body ...+)
syntax
(let/debug ([lhs-id rhs-expr] ...) body ...+)
(let/debug loop-id ([lhs-id rhs-expr] ...) body ...+)
syntax
(let*/debug ([lhs-id rhs-expr] ...) body ...+)
syntax
(letrec/debug ([lhs-id rhs-expr] ...) body ...+)
syntax
(let-values/debug ([(lhs-id ...) rhs-expr] ...) body ...+)
syntax
(let*-values/debug ([(lhs-id ...) rhs-expr] ...) body ...+)
syntax
(letrec-values/debug ([(lhs-id ...) rhs-expr] ...) body ...+)
syntax
(with-syntax/debug ([pattern stx-expr] ...) body ...+)
syntax
(with-syntax*/debug ([pattern stx-expr] ...) body ...+)
syntax
(parameterize/debug ([param-expr value-expr] ...) body ...+)
syntax
(at-end expr)
syntax
(in-phase1 e)
syntax
(in-phase1/pass2 e)
procedure
(error*  name                                
         message                             
         field                               
         value ...                           
         ...                                 
        [#:continued continued-message]) -> any
  name : symbol?
  message : string?
  field : (let ([option/c (or/c 'value 'multi 'maybe)])
            (or/c string? (cons/c string? (listof option/c))))
  value : any/c
  continued-message : (or/c string? (listof string?)) = null
procedure
(raise-syntax-error*  message                             
                      expr                                
                      sub-expr                            
                      field                               
                      value ...                           
                      ...                                 
                     [#:continued continued-message]) -> any
  message : string?
  expr : (or/c syntax? #f)
  sub-expr : (or/c syntax? #f)
  field : (let ([option/c (or/c 'value 'multi 'maybe)])
            (or/c string? (cons/c string? (listof option/c))))
  value : any/c
  continued-message : (or/c string? (listof string?)) = null
procedure
(compose-error-message  name                                
                        message                             
                        field                               
                        value ...                           
                        ...                                 
                       [#:continued continued-message]) -> string?
  name : (or/c symbol? #f)
  message : string?
  field : (let ([option/c (or/c 'value 'multi 'maybe)])
            (or/c string? (cons/c string? (listof option/c))))
  value : any/c
  continued-message : (or/c string? (listof string?)) = null
procedure
(compose-error-detail field options value) -> string?
  field : string?
  options : (listof (or/c 'value 'multi 'maybe))
  value : any/c
syntax
(for/async (for-clause ...) body ...+)
syntax
(for*/async (for-clause ...) body ...+)
procedure
((conjoin f ...) x ...) -> boolean?
  f : (-> A ... boolean?)
  x : A
procedure
((disjoin f ...) x ...) -> boolean?
  f : (-> A ... boolean?)
  x : A
procedure
(hash-union  h0                          
             h ...                       
            [#:combine combine           
             #:combine/key combine/key]) 
 -> (and/c hash? hash-can-functional-set?)
  h0 : (and/c hash? hash-can-functional-set?)
  h : hash?
  combine : (-> any/c any/c any/c)
          = (lambda _ (error 'hash-union ....))
  combine/key : (-> any/c any/c any/c any/c)
              = (lambda (k a b) (combine a b))
procedure
(hash-union!  h0                              
              h ...                           
             [#:combine combine               
              #:combine/key combine/key]) -> void?
  h0 : (and/c hash? hash-mutable?)
  h : hash?
  combine : (-> any/c any/c any/c)
          = (lambda _ (error 'hash-union ....))
  combine/key : (-> any/c any/c any/c any/c)
              = (lambda (k a b) (combine a b))
syntax
(define-interface name-id (super-ifc-id ...) (method-id ...))
syntax
(define-interface/dynamic name-id ifc-expr (method-id ...))
syntax
(send/i obj-exp static-ifc-id method-id arg-expr ...)
syntax
(send*/i obj-expr static-ifc-id (method-id arg-expr ...) ...)
syntax
(send/apply/i obj-expr static-ifc-id method-id arg-expr ... list-arg-expr)
syntax
(define/i id static-ifc-id expr)
syntax
(init/i (id static-ifc-id maybe-default-expr) ...)
syntax
(init-field/i (id static-ifc-id maybe-default-expr) ...)
syntax
(init-private/i (id static-ifc-id maybe-default-expr) ...)
 
maybe-default-expr = ()
                   | default-expr
syntax
(define-interface-expander id transformer-expr)
syntax
(begin-on-demand #:export (fun-id ...)
   body ...+)
procedure
(list-prefix? l r) -> boolean?
  l : list?
  r : list?
procedure
(take-common-prefix l r #:same? same?) -> list?
  l : list?
  r : list?
  same? : equal?
procedure
(drop-common-prefix l r #:same same?) -> list? list?
  l : list?
  r : list?
  same? : equal?
procedure
(split-common-prefix l r #:same? same?) -> list? list? list?
  l : list?
  r : list?
  same? : equal?
procedure
(filter-multiple l f ...) -> list? ...
  l : list?
  f : procedure?
procedure
(extend l1 l2 v) -> list?
  l1 : list?
  l2 : list?
  v : any/c
procedure
(check-duplicate  lst                   
                 [#:key extract-key     
                  #:same? same?])   -> (or/c any/c #f)
  lst : list?
  extract-key : (-> any/c any/c) = (lambda (x) x)
  same? : (or/c (any/c any/c . -> . any/c) = equal?
                dict?)
procedure
(map/values n f lst ...) -> (listof B_1) ... (listof B_n)
  n : natural-number/c
  f : (-> A ... (values B_1 ... B_n))
  lst : (listof A)
procedure
(map2 f lst ...) -> (listof B) (listof C)
  f : (-> A ... (values B C))
  lst : (listof A)
procedure
(remf pred lst) -> list?
  pred : procedure?
  lst : list?
procedure
(group-by extract-key lst [=?]) -> (listof (listof A))
  extract-key : (-> A B)
  lst : (listof A)
  =? : (-> B B any/c) = equal?
procedure
(cartesian-product lst ...) -> (listof (listof A))
  lst : (listof A)
procedure
(list-update lst index updater) -> list?
  lst : list?
  index : (and/c (>=/c 0) (</c (length lst)))
  updater : (-> any/c any/c)
procedure
(list-set lst index value) -> list?
  lst : list?
  index : (and/c (>=/c 0) (</c (length lst)))
  value : any/c
procedure
(with-logging-to-port port proc log-spec ...) -> any
  port : output-port?
  proc : (-> any)
  log-spec : (or/c 'fatal 'error 'warning 'info 'debug symbol? #f)
procedure
(with-intercepted-logging interceptor       
                          proc              
                          log-spec ...) -> any
  interceptor : (-> (vector/c
                      (or/c 'fatal 'error 'warning 'info 'debug)
                      string?
                      any/c
                      (or/c symbol? #f))
                     any)
  proc : (-> any)
  log-spec : (or/c 'fatal 'error 'warning 'info 'debug symbol? #f)
procedure
(start-recording log-spec ...) -> listener?
  log-spec : (or/c 'fatal 'error 'warning 'info 'debug symbol? #f)
procedure
(stop-recording listener)
 -> (listof (vector/c (or/c 'fatal 'error 'warning 'info 'debug)
                      string?
                      any/c
                      (or/c symbol? #f)))
  listener : listener?
syntax
(phase1-eval ct-expr maybe-quote maybe-catch?)
 
maybe-quote  = 
             | #:quote quote-id
                
maybe-catch? = 
             | #:catch? catch?
syntax
(convert-compile-time-error expr)
syntax
(convert-syntax-error expr)
struct
(struct mark-parameter ())
procedure
(mark-parameter-first mp [tag]) -> any/c
  mp : mark-parameter?
  tag : continuation-prompt-tag?
      = default-continuation-prompt-tag
procedure
(mark-parameter-all mp [tag]) -> list?
  mp : mark-parameter?
  tag : continuation-prompt-tag?
      = default-continuation-prompt-tag
procedure
(mark-parameters-all mps none-v [tag]) -> (listof vector?)
  mps : (listof mark-parameter?)
  none-v : [any/c #f]
  tag : continuation-prompt-tag?
      = default-continuation-prompt-tag
syntax
(mark-parameterize ([mp expr] ...) body-expr ...)
syntax
(match? val-expr pat ...)
syntax
(as ([lhs-id rhs-expr] ...) pat ...)
syntax
(match*? (val-expr ...) (pat ...) ...)
syntax
(object maybe-class field-clause ...)
 
maybe-class  = 
             | class-expr
                
field-clause = (field field-id maybe-pat)
                
maybe-pat    = 
             | pat
syntax
(open-place id body ...+)
procedure
(option/c  c                         
          [#:with-contract with      
           #:tester tester           
           #:invariant invariant     
           #:immutable immutable     
           #:flat? flat?             
           #:struct struct-id])  -> contract?
  c : contract?
  with : boolean? = #f
  tester : (or/c (-> any boolean?) 'dont-care) = 'dont-care
  invariant : (or/c (-> any boolean?) 'dont-care) = 'dont-care
  immutable : (or/c #t #f 'dont-care) = 'dont-care
  flat? : boolean? = #f
  struct-id : (or/c identifier? 'none) = 'none
procedure
(exercise-option x) -> any/c
  x : any/c
value
transfer/c : contract?
procedure
(waive-option x) -> any/c
  x : any/c
procedure
(tweak-option x) -> any/c
  x : any/c
procedure
(has-option? v) -> boolean?
  v : any/c
procedure
(has-option-with-contract? v) -> boolean?
  v : any/c
procedure
(invariant/c  c                         
              invariant                 
             [#:immutable immutable     
              #:flat? flat?             
              #:struct struct-id])  -> contract?
  c : contract?
  invariant : (-> any boolean?)
  immutable : (or/c #t #f 'dont-care) = 'dont-care
  flat? : boolean? = #f
  struct-id : (or/c identifier? 'none) = 'none
procedure
(parameter-group? v) -> boolean?
  v : any/c
syntax
(define-parameter-group name (param-or-group-expr ...) options)
 
options = 
        | #:struct struct-name
 
  param-or-group-expr : (or/c parameter? parameter-group?)
syntax
(parameterize/group ([param-or-group-expr  value-expr] ...)
  body-expr ...+)
 
  param-or-group-expr : (or/c parameter? parameter-group?)
syntax
(parameterize*/group ([param-or-group-expr  value-expr] ...)
  body-expr ...+)
 
  param-or-group-expr : (or/c parameter? parameter-group?)
procedure
(pretty-format/write x [columns]) -> string?
  x : any/c
  columns : (or/c exact-nonnegative-integer? 'infinity)
          = (pretty-print-columns)
procedure
(pretty-format/display x [columns]) -> string?
  x : any/c
  columns : (or/c exact-nonnegative-integer? 'infinity)
          = (pretty-print-columns)
procedure
(pretty-format/print x [columns]) -> string?
  x : any/c
  columns : (or/c exact-nonnegative-integer? 'infinity)
          = (pretty-print-columns)
procedure
(break-lines s [columns]) -> string?
  s : string?
  columns : exact-nonnegative-integer? = (pretty-print-columns)
syntax
(recontract-out id ...)
procedure
(make-log-based-eval log-file mode) -> (-> any/c any)
  log-file : path-string?
  mode : (or/c 'record 'replay)
procedure
(in-syntax stx) -> sequence?
  stx : syntax?
procedure
(in-pairs seq) -> sequence?
  seq : sequence?
procedure
(in-sequence-forever seq val) -> sequence?
  seq : sequence?
  val : any/c
procedure
(sequence-lift f seq) -> sequence?
  f : procedure?
  seq : sequence?
procedure
(in-slice length seq) -> sequence?
  length : exact-positive-integer?
  seq : sequence?
procedure
(regexp-filter pattern lst)
 -> (listof (or/c string? bytes? path? input-port?))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  lst : (listof (or/c string? bytes? path? input-port?))
syntax
(make struct-id expr ...)
procedure
(struct->list v [#:on-opaque on-opaque]) -> (or/c list? #f)
  v : any/c
  on-opaque : (or/c 'error 'return-false 'skip) = 'error
procedure
(make-constructor-style-printer get-constructor 
                                get-contents)   
 -> (-> any/c output-port? (or/c #t #f 0 1) void?)
  get-constructor : (-> any/c (or/c symbol? string?))
  get-contents : (-> any/c sequence?)
value
prop:auto-custom-write : (struct-type-property/c 'constructor)
procedure
(explode-module-path-index mpi)
 -> (listof (or/c module-path? resolved-module-path? #f))
  mpi : module-path-index?
syntax
(phase-of-enclosing-module)
procedure
(make-variable-like-transformer  reference-stx 
                                [setter-stx])  
 -> set!-transformer?
  reference-stx : syntax?
  setter-stx : (or/c syntax? #f) = #f
procedure
(format-unique-id  lctx              
                   fmt               
                   v ...             
                  [#:source src      
                   #:props props     
                   #:cert cert]) -> identifier?
  lctx : (or/c syntax? #f)
  fmt : string?
  v : (or/c string? symbol? identifier? keyword? char? number?)
  src : (or/c syntax? #f) = #f
  props : (or/c syntax? #f) = #f
  cert : (or/c syntax? #f) = #f
procedure
(syntax-within? a b) -> boolean?
  a : syntax?
  b : syntax?
procedure
(syntax-length stx) -> exact-nonnegative-integer?
  stx : syntax?
procedure
(syntax-source-directory stx) -> (or/c path? #f)
  stx : syntax?
procedure
(syntax-source-file-name stx) -> (or/c path? #f)
  stx : syntax?
struct
(struct monitor (label)
        #:transparent)
  label : symbol?
struct
(struct monitor:proj monitor (label proj-label v)
        #:transparent)
  label : symbol?
  proj-label : symbol?
  v : any/c
struct
(struct monitor:call monitor (label
                             proj-label
                             f
                             app-label
                             kws
                             kw-args
                             args)
        #:transparent)
  label : symbol?
  proj-label : symbol?
  f : procedure?
  app-label : symbol?
  kws : (listof keyword?)
  kw-args : list?
  args : list?
struct
(struct monitor:return monitor (label
                               proj-label
                               f
                               app-label
                               kws
                               kw-args
                               args
                               rets)
        #:transparent)
  label : symbol?
  proj-label : symbol?
  f : procedure?
  app-label : symbol?
  kws : (listof keyword?)
  kw-args : list?
  args : list?
  rets : list?
procedure
(monitor/c monitor-allows? label c) -> contract?
  monitor-allows? : (-> monitor? boolean?)
  label : symbol?
  c : contract?
syntax
(call n a ...)
syntax
(ret n a ...)
syntax
(with-monitor contract-expr re-pat)
syntax
(label id contract-expr)
value
unix-socket-available? : boolean?
procedure
(unix-socket-connect socket-path) -> input-port? output-port?
  socket-path : unix-socket-path?
procedure
(unix-socket-path? v) -> boolean?
  v : any/c
syntax
(2dcond cond-content)
 
cond-content  = question-row
                body-row
                ⋮
              | question-row
                body-row
                ⋮
                else-row
                 
question-row  = empty-cell question-cell ⋯
              | empty-cell question-cell ⋯ else-cell
                 
body-row      = question-cell exprs-cell ⋯
                 
else-row      = question-cell exprs-cell ⋯ else-cell
                 
question-cell = ╔═════════════╗
                ║question-expr║
                ╚═════════════╝
                 
empty-cell    = ╔═══╗
                ║   ║
                ╚═══╝
                 
exprs-cell    = ╔═════════════╗
                ║expr expr ...║
                ╚═════════════╝
                 
else-cell     = ╔══════╗
                ║ else ║
                ╚══════╝
syntax
(2dmatch match-content)
 
match-content   = match-first-row
                  match-row
                  ⋮
                   
match-first-row = two-expr-cell match-pat-cell ⋯
                   
match-row       = match-pat-cell exprs-cell ⋯
                   
two-expr-cell   = ╔═════════════════╗
                  ║col-expr row-expr║
                  ╚═════════════════╝
                   
match-pat-cell  = ╔═════╗
                  ║ pat ║
                  ╚═════╝
                   
exprs-cell      = ╔═════════════╗
                  ║expr expr ...║
                  ╚═════════════╝
syntax
(2dmatch tabular-content)
 
tabular-content = tabular-row
                  ⋮
                | tabular-row
                  ⋮
                  style-cell
                   
tabular-row     = tabular-cell ⋯
                   
tabular-cell    = ╔════════════════╗
                  ║tabular-expr ...║
                  ╚════════════════╝
                   
style-cell      = ╔═════════════════╗
                  ║style-content ...║
                  ╚═════════════════╝
                   
style-content   = #:style style-expr
                | #:sep sep-expr
                | #:ignore-first-row
 
  style-expr : style?
  sep-expr : (or/c block? content? #f)
  tabular-expr : (or/c block? content?)
