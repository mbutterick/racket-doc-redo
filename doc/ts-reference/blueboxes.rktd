15118
((3) 0 () 7 ((q lib "typed-racket/base-env/base-types.rkt") (q lib "typed-racket/base-env/prims.rkt") (q lib "typed-racket/base-env/base-types-extra.rkt") (q lib "typed/scheme/base.rkt") (q lib "typed-racket/typed-racket.rkt") (q lib "typed-racket/base-env/extra-procs.rkt") (q lib "typed/racket/base.rkt")) () (h ! (equal) ((c form c (c (? . 0) q Subprocess)) q (2682 . 2)) ((c form c (c (? . 0) q Negative-Fixnum)) q (1696 . 2)) ((c form c (c (? . 0) q Inexact-Real)) q (118 . 2)) ((c form c (c (? . 1) q for/flvector:)) q (6101 . 2)) ((c form c (c (? . 2) q Parameter)) q (11542 . 2)) ((c form c (c (? . 0) q Custodian)) q (2503 . 2)) ((c form c (c (? . 0) q Negative-Real)) q (1492 . 2)) ((c form c (c (? . 0) q Resolved-Module-Path)) q (2202 . 2)) ((c form c (c (? . 1) q for*:)) q (7607 . 3)) ((c form c (c (? . 4) q #%module-begin)) q (10300 . 2)) ((c form c (c (? . 1) q declare-refinement)) q (12107 . 2)) ((c form c (c (? . 0) q UDP-Socket)) q (2559 . 2)) ((c form c (c (? . 1) q require/typed)) q (9553 . 15)) ((c form c (c (? . 2) q Struct)) q (4114 . 2)) ((c form c (c (? . 0) q Pairof)) q (2822 . 2)) ((c form c (c (? . 1) q ann)) q (9376 . 2)) ((c form c (c (? . 1) q define:)) q (8080 . 7)) ((c form c (c (? . 1) q for*/product:)) q (7338 . 2)) ((c form c (c (? . 0) q Float)) q (70 . 2)) ((c form c (c (? . 1) q make-predicate)) q (9235 . 2)) ((c form c (c (? . 0) q Security-Guard)) q (2537 . 2)) ((c form c (c (? . 0) q Struct-Type-Property)) q (2381 . 2)) ((c form c (c (? . 0) q Path-String)) q (2803 . 2)) ((c form c (c (? . 1) q :print-type)) q (10944 . 2)) ((c form c (c (? . 0) q Single-Flonum-Nan)) q (1053 . 2)) ((c form c (c (? . 0) q Inexact-Real-Positive-Zero)) q (1234 . 2)) ((c form c (c (? . 0) q MListof)) q (2956 . 2)) ((c form c (c (? . 0) q Byte-Regexp)) q (1970 . 2)) ((c form c (c (? . 1) q require-typed-struct/provide)) q (11440 . 2)) ((c form c (c (? . 1) q let*-values:)) q (4613 . 2)) ((c form c (c (? . 0) q Vectorof)) q (3047 . 2)) ((c form c (c (? . 0) q Regexp)) q (1941 . 2)) ((c form c (c (? . 0) q Prompt-Tagof)) q (3567 . 2)) ((c form c (c (? . 0) q Positive-Single-Flonum)) q (831 . 2)) ((c form c (c (? . 0) q Sexpof)) q (3523 . 2)) ((c form c (c (? . 0) q Internal-Definition-Context)) q (2291 . 2)) ((c form c (c (? . 0) q Struct-TypeTop)) q (4159 . 2)) ((c form c (c (? . 1) q letrec:)) q (4402 . 2)) ((c form c (c (? . 1) q Î»)) q (10184 . 2)) ((c form c (c (? . 1) q define-struct/exec:)) q (8948 . 5)) ((c form c (c (? . 0) q Boxof)) q (3015 . 2)) ((c form c (c (? . 0) q Promise)) q (3272 . 2)) ((c form c (c (? . 0) q Thread-Cellof)) q (3364 . 2)) ((c form c (c (? . 0) q PRegexp)) q (1955 . 2)) ((c form c (c (? . 0) q Flonum-Nan)) q (813 . 2)) ((c form c (c (? . 2) q All)) q (3980 . 3)) ((c form c (c (? . 2) q Opaque)) q (4237 . 2)) ((c form c (c (? . 0) q Namespace-Anchor)) q (2039 . 2)) ((c form c (c (? . 1) q with-handlers)) q (10149 . 2)) ((c form c (c (? . 1) q define)) q (10194 . 2)) ((c form c (c (? . 0) q Float-Zero)) q (759 . 2)) ((c form c (c (? . 1) q for*/flvector:)) q (6925 . 2)) ((c form c (c (? . 0) q Sexp)) q (3542 . 2)) ((c form c (c (? . 0) q Flonum-Negative-Zero)) q (676 . 2)) ((c form c (c (? . 0) q Positive-Float)) q (457 . 2)) ((c form c (c (? . 0) q BoxTop)) q (3033 . 2)) ((c form c (c (? . 0) q Zero)) q (445 . 2)) ((c form c (c (? . 0) q Nonpositive-Exact-Rational)) q (1413 . 2)) ((c form c (c (? . 0) q Input-Port)) q (1852 . 2)) ((c form c (c (? . 1) q let*:)) q (4448 . 2)) ((c form c (c (? . 1) q letrec-values:)) q (4551 . 2)) ((c form c (c (? . 0) q Negative-Exact-Rational)) q (1382 . 2)) ((c form c (c (? . 1) q typecheck-fail)) q (10695 . 8)) ((c form c (c (? . 2) q Tuple)) q (11529 . 2)) ((c form c (c (? . 2) q List*)) q (2926 . 2)) ((c form c (c (? . 0) q Namespace)) q (2022 . 2)) ((c form c (c (? . 1) q plet:)) q (4348 . 2)) ((c form c (c (? . 1) q for*/list:)) q (6578 . 2)) ((c form c (c (? . 0) q Parameterization)) q (2479 . 2)) ((c form c (c (? . 1) q for*/last:)) q (7203 . 2)) ((c form c (c (? . 2) q Struct-Type)) q (4134 . 2)) ((c form c (c (? . 1) q let/cc:)) q (4673 . 2)) ((c form c (c (? . 0) q Datum)) q (3554 . 2)) ((c form c (c (? . 0) q Custodian-Boxof)) q (3336 . 2)) ((c form c (c (? . 2) q case->)) q (3927 . 2)) ((c form c (c (? . 0) q Real-Zero)) q (1537 . 2)) ((c form c (c (? . 0) q Module-Path)) q (2158 . 2)) ((c form c (c (? . 0) q Flonum)) q (83 . 2)) ((c form c (c (? . 0) q Nonpositive-Fixnum)) q (1719 . 2)) ((c form c (c (? . 0) q True)) q (1760 . 2)) ((c form c (c (? . 1) q pdefine:)) q (11476 . 2)) ((c form c (c (? . 1) q lambda)) q (10170 . 2)) ((c form c (c (? . 0) q Ephemeronof)) q (3412 . 2)) ((c form c (c (? . 0) q Nonnegative-Fixnum)) q (1670 . 2)) ((c def c (c (? . 1) q index?)) q (10643 . 3)) ((c form c (c (? . 0) q Bytes)) q (2009 . 2)) ((c form c (c (? . 0) q Semaphore)) q (2734 . 2)) ((c form c (c (? . 1) q define-struct:)) q (8634 . 11)) ((c form c (c (? . 1) q require-typed-struct)) q (11412 . 2)) ((c form c (c (? . 1) q define-typed-struct)) q (11358 . 2)) ((c form c (c (? . 0) q False)) q (1772 . 2)) ((c form c (c (? . 1) q opt-lambda:)) q (5176 . 6)) ((c form c (c (? . 0) q Inexact-Complex)) q (242 . 2)) ((c form c (c (? . 3) q require/typed)) q (11585 . 12)) ((c form c (c (? . 1) q plambda:)) q (4930 . 3)) ((c form c (c (? . 1) q inst)) q (9434 . 3)) ((c form c (c (? . 1) q for/or:)) q (6238 . 2)) ((c form c (c (? . 0) q HashTableTop)) q (3150 . 2)) ((c form c (c (? . 1) q case-lambda:)) q (5021 . 2)) ((c form c (c (? . 1) q for*/fold:)) q (7766 . 4)) ((c form c (c (? . 0) q Pseudo-Random-Generator)) q (2772 . 2)) ((c form c (c (? . 0) q Read-Table)) q (2438 . 2)) ((c form c (c (? . 2) q U)) q (3908 . 2)) ((c form c (c (? . 1) q :type)) q (10860 . 5)) ((c form c (c (? . 1) q :query-type/args)) q (10968 . 2)) ((c def c (c (? . 5) q defined?)) q (10589 . 3)) ((c form c (c (? . 1) q for/lists:)) q (7409 . 4)) ((c form c (c (? . 0) q Nonnegative-Integer)) q (319 . 2)) ((c form c (c (? . 0) q Nonnegative-Inexact-Real)) q (1107 . 2)) ((c form c (c (? . 0) q Nonnegative-Float)) q (502 . 2)) ((c form c (c (? . 0) q Nonpositive-Float)) q (598 . 2)) ((c form c (c (? . 0) q Nonnegative-Exact-Rational)) q (1348 . 2)) ((c form c (c (? . 1) q for*/hasheqv:)) q (6784 . 2)) ((c form c (c (? . 0) q Syntaxof)) q (3454 . 2)) ((c form c (c (? . 0) q Single-Flonum-Zero)) q (1027 . 2)) ((c form c (c (? . 0) q Flonum-Positive-Zero)) q (731 . 2)) ((c form c (c (? . 0) q Thread)) q (2648 . 2)) ((c form c (c (? . 0) q Thread-Group)) q (2662 . 2)) ((c form c (c (? . 1) q lambda:)) q (4741 . 6)) ((c form c (c (? . 0) q EOF)) q (2101 . 2)) ((c form c (c (? . 3) q require-typed-struct)) q (12032 . 2)) ((c form c (c (? . 1) q for*/or:)) q (7064 . 2)) ((c form c (c (? . 1) q for/sum:)) q (6442 . 2)) ((c form c (c (? . 0) q Nonnegative-Flonum)) q (527 . 2)) ((c form c (c (? . 0) q Listof)) q (2844 . 2)) ((c form c (c (? . 0) q Positive-Real)) q (1447 . 2)) ((c form c (c (? . 0) q Float-Negative-Zero)) q (649 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Keyof)) q (3616 . 2)) ((c form c (c (? . 0) q Positive-Integer)) q (265 . 2)) ((c form c (c (? . 0) q Number)) q (26 . 2)) ((c form c (c (? . 1) q struct:)) q (8329 . 11)) ((c form c (c (? . 0) q Byte-PRegexp)) q (1989 . 2)) ((c form c (c (? . 0) q Positive-Index)) q (1611 . 2)) ((c form c (c (? . 1) q require/opaque-type)) q (11385 . 2)) ((c form c (c (? . 0) q Single-Flonum-Positive-Zero)) q (992 . 2)) ((c form c (c (? . 0) q Null)) q (2089 . 2)) ((c form c (c (? . 0) q Evtof)) q (3436 . 2)) ((c form c (c (? . 1) q for/vector:)) q (6032 . 2)) ((c form c (c (? . 1) q for/list:)) q (5759 . 2)) ((c form c (c (? . 1) q for*/first:)) q (7134 . 2)) ((c form c (c (? . 1) q :)) q (9297 . 3)) ((c form c (c (? . 0) q String)) q (1785 . 2)) ((c form c (c (? . 0) q TCP-Listener)) q (2577 . 2)) ((c form c (c (? . 0) q Continuation-Mark-KeyTop)) q (3652 . 2)) ((c form c (c (? . 0) q Bytes-Converter)) q (2456 . 2)) ((c form c (c (? . 0) q Void)) q (1840 . 2)) ((c form c (c (? . 2) q Parameterof)) q (3228 . 3)) ((c form c (c (? . 0) q Sequenceof)) q (3313 . 2)) ((c form c (c (? . 4) q with-type)) q (11039 . 10)) ((c form c (c (? . 0) q Nonnegative-Single-Flonum)) q (861 . 2)) ((c form c (c (? . 1) q popt-lambda:)) q (5414 . 3)) ((c form c (c (? . 0) q Log-Level)) q (2631 . 2)) ((c form c (c (? . 1) q provide:)) q (9327 . 2)) ((c form c (c (? . 0) q Float-Complex)) q (192 . 2)) ((c form c (c (? . 2) q mu)) q (11519 . 2)) ((c form c (c (? . 0) q Positive-Fixnum)) q (1647 . 2)) ((c form c (c (? . 0) q Integer)) q (55 . 2)) ((c form c (c (? . 1) q for/hash:)) q (5826 . 2)) ((c form c (c (? . 0) q Channelof)) q (3188 . 2)) ((c form c (c (? . 0) q Logger)) q (2597 . 2)) ((c form c (c (? . 0) q Nonpositive-Single-Flonum)) q (924 . 2)) ((c form c (c (? . 0) q Single-Flonum-Complex)) q (213 . 2)) ((c form c (c (? . 0) q Negative-Integer)) q (394 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Set)) q (2112 . 2)) ((c form c (c (? . 0) q Positive-Exact-Rational)) q (1317 . 2)) ((c form c (c (? . 0) q Pair)) q (11559 . 2)) ((c form c (c (? . 0) q Option)) q (4218 . 2)) ((c form c (c (? . 1) q for/fold:)) q (7502 . 4)) ((c form c (c (? . 1) q let:)) q (4256 . 3)) ((c form c (c (? . 6) q values)) q (11571 . 2)) ((c form c (c (? . 0) q Identifier)) q (3475 . 2)) ((c form c (c (? . 1) q for/hasheq:)) q (5893 . 2)) ((c form c (c (? . 1) q define-type-alias)) q (11333 . 2)) ((c form c (c (? . 2) q Refinement)) q (12139 . 2)) ((c form c (c (? . 0) q Log-Receiver)) q (2611 . 2)) ((c form c (c (? . 0) q Float-Nan)) q (796 . 2)) ((c form c (c (? . 0) q Variable-Reference)) q (2063 . 2)) ((c form c (c (? . 0) q Module-Path-Index)) q (2177 . 2)) ((c form c (c (? . 2) q Instance)) q (12086 . 2)) ((c form c (c (? . 2) q Class)) q (12060 . 2)) ((c form c (c (? . 0) q Any)) q (0 . 2)) ((c form c (c (? . 0) q VectorTop)) q (3108 . 2)) ((c form c (c (? . 0) q Setof)) q (3170 . 2)) ((c form c (c (? . 1) q for*/hash:)) q (6646 . 2)) ((c form c (c (? . 0) q Compiled-Module-Expression)) q (2230 . 2)) ((c form c (c (? . 0) q Negative-Inexact-Real)) q (1139 . 2)) ((c def c (c (? . 1) q default-continuation-prompt-tag)) q (10208 . 3)) ((c form c (c (? . 0) q Compiled-Expression)) q (2264 . 2)) ((c form c (c (? . 0) q Positive-Flonum)) q (479 . 2)) ((c form c (c (? . 1) q with-asserts)) q (10485 . 5)) ((c form c (c (? . 2) q Vector)) q (3068 . 2)) ((c form c (c (? . 2) q pred)) q (11492 . 2)) ((c form c (c (? . 1) q for*/sum:)) q (7271 . 2)) ((c form c (c (? . 0) q Inspector)) q (2520 . 2)) ((c form c (c (? . 0) q Pretty-Print-Style-Table)) q (2326 . 2)) ((c form c (c (? . 1) q for/last:)) q (6375 . 2)) ((c form c (c (? . 0) q Nonpositive-Integer)) q (418 . 2)) ((c form c (c (? . 0) q Impersonator-Property)) q (2409 . 2)) ((c form c (c (? . 0) q Nonpositive-Flonum)) q (623 . 2)) ((c form c (c (? . 0) q HashTable)) q (3125 . 2)) ((c form c (c (? . 0) q Char)) q (1828 . 2)) ((c form c (c (? . 1) q for/hasheqv:)) q (5962 . 2)) ((c form c (c (? . 0) q Futureof)) q (3292 . 2)) ((c def c (c (? . 5) q assert)) q (10370 . 6)) ((c form c (c (? . 0) q Exact-Rational)) q (138 . 2)) ((c form c (c (? . 0) q Inexact-Real-Zero)) q (1268 . 2)) ((c form c (c (? . 1) q do:)) q (7895 . 7)) ((c form c (c (? . 0) q Nonpositive-Real)) q (1513 . 2)) ((c form c (c (? . 1) q for*/vector:)) q (6855 . 2)) ((c form c (c (? . 0) q Undefined)) q (2141 . 2)) ((c form c (c (? . 1) q for/first:)) q (6307 . 2)) ((c form c (c (? . 0) q Fixnum)) q (1633 . 2)) ((c form c (c (? . 0) q Nothing)) q (11 . 2)) ((c form c (c (? . 0) q Syntax-E)) q (3507 . 2)) ((c form c (c (? . 0) q FlVector)) q (3092 . 2)) ((c form c (c (? . 1) q for/product:)) q (6508 . 2)) ((c form c (c (? . 0) q Byte)) q (1565 . 2)) ((c form c (c (? . 0) q Natural)) q (379 . 2)) ((c form c (c (? . 0) q Index)) q (1598 . 2)) ((c form c (c (? . 0) q Nonpositive-Inexact-Real)) q (1168 . 2)) ((c form c (c (? . 2) q List)) q (2863 . 2)) ((c form c (c (? . 0) q Will-Executor)) q (2751 . 2)) ((c form c (c (? . 1) q for:)) q (5513 . 10)) ((c form c (c (? . 0) q Special-Comment)) q (2358 . 2)) ((c form c (c (? . 1) q for*/and:)) q (6997 . 2)) ((c form c (c (? . 1) q for*/lists:)) q (7672 . 4)) ((c form c (c (? . 0) q Prompt-TagTop)) q (3595 . 2)) ((c form c (c (? . 0) q Path-For-Some-System)) q (1913 . 2)) ((c form c (c (? . 1) q for*)) q (7883 . 2)) ((c form c (c (? . 0) q Inexact-Real-Negative-Zero)) q (1200 . 2)) ((c form c (c (? . 0) q Exact-Number)) q (172 . 2)) ((c form c (c (? . 0) q MPairof)) q (2976 . 2)) ((c form c (c (? . 0) q One)) q (1554 . 2)) ((c form c (c (? . 2) q â)) q (4181 . 2)) ((c form c (c (? . 0) q Complex)) q (40 . 2)) ((c form c (c (? . 1) q let-values:)) q (4492 . 2)) ((c form c (c (? . 2) q â)) q (4207 . 2)) ((c form c (c (? . 2) q caseâ)) q (4192 . 2)) ((c form c (c (? . 1) q pcase-lambda:)) q (5065 . 3)) ((c form c (c (? . 0) q Inexact-Real-Nan)) q (1293 . 2)) ((c form c (c (? . 0) q ChannelTop)) q (3210 . 2)) ((c form c (c (? . 1) q let/ec:)) q (4707 . 2)) ((c form c (c (? . 2) q Rec)) q (4095 . 2)) ((c form c (c (? . 0) q Single-Flonum-Negative-Zero)) q (957 . 2)) ((c form c (c (? . 2) q Un)) q (11509 . 2)) ((c form c (c (? . 2) q Values)) q (4033 . 2)) ((c form c (c (? . 1) q cast)) q (9414 . 2)) ((c form c (c (? . 1) q Î»:)) q (4900 . 2)) ((c form c (c (? . 1) q for/and:)) q (6172 . 2)) ((c form c (c (? . 0) q Port)) q (1889 . 2)) ((c form c (c (? . 0) q Positive-Byte)) q (1577 . 2)) ((c form c (c (? . 4) q #%top-interaction)) q (10335 . 2)) ((c form c (c (? . 0) q Float-Positive-Zero)) q (704 . 2)) ((c form c (c (? . 0) q Thread-CellTop)) q (3390 . 2)) ((c form c (c (? . 1) q for*/hasheq:)) q (6714 . 2)) ((c form c (c (? . 0) q Negative-Float)) q (553 . 2)) ((c form c (c (? . 0) q Output-Port)) q (1870 . 2)) ((c form c (c (? . 0) q Single-Flonum)) q (97 . 2)) ((c form c (c (? . 0) q Procedure)) q (3891 . 2)) ((c form c (c (? . 0) q Negative-Single-Flonum)) q (894 . 2)) ((c form c (c (? . 0) q Exact-Nonnegative-Integer)) q (346 . 2)) ((c form c (c (? . 0) q Symbol)) q (1814 . 2)) ((c form c (c (? . 1) q define-typed-struct/exec)) q (12163 . 2)) ((c form c (c (? . 6) q define-type)) q (9074 . 6)) ((c form c (c (? . 1) q :query-type/result)) q (11005 . 2)) ((c form c (c (? . 0) q Negative-Flonum)) q (575 . 2)) ((c form c (c (? . 0) q Keyword)) q (1799 . 2)) ((c form c (c (? . 1) q for)) q (7872 . 2)) ((c form c (c (? . 0) q Path)) q (1901 . 2)) ((c form c (c (? . 0) q Flonum-Zero)) q (777 . 2)) ((c form c (c (? . 0) q Place-Channel)) q (2713 . 2)) ((c form c (c (? . 1) q require/typed/provide)) q (10099 . 2)) ((c form c (c (? . 0) q Real)) q (160 . 2)) ((c form c (c (? . 2) q ->)) q (3684 . 11)) ((c form c (c (? . 1) q define-predicate)) q (9262 . 2)) ((c form c (c (? . 0) q Boolean)) q (1745 . 2)) ((c form c (c (? . 0) q MPairTop)) q (2999 . 2)) ((c form c (c (? . 0) q Syntax)) q (3493 . 2)) ((c form c (c (? . 0) q Exact-Positive-Integer)) q (289 . 2)) ((c form c (c (? . 0) q Nonnegative-Real)) q (1468 . 2)) ((c form c (c (? . 0) q Positive-Inexact-Real)) q (1078 . 2)) ((c form c (c (? . 0) q Place)) q (2700 . 2))))
syntax
Any
syntax
Nothing
syntax
Number
syntax
Complex
syntax
Integer
syntax
Float
syntax
Flonum
syntax
Single-Flonum
syntax
Inexact-Real
syntax
Exact-Rational
syntax
Real
syntax
Exact-Number
syntax
Float-Complex
syntax
Single-Flonum-Complex
syntax
Inexact-Complex
syntax
Positive-Integer
syntax
Exact-Positive-Integer
syntax
Nonnegative-Integer
syntax
Exact-Nonnegative-Integer
syntax
Natural
syntax
Negative-Integer
syntax
Nonpositive-Integer
syntax
Zero
syntax
Positive-Float
syntax
Positive-Flonum
syntax
Nonnegative-Float
syntax
Nonnegative-Flonum
syntax
Negative-Float
syntax
Negative-Flonum
syntax
Nonpositive-Float
syntax
Nonpositive-Flonum
syntax
Float-Negative-Zero
syntax
Flonum-Negative-Zero
syntax
Float-Positive-Zero
syntax
Flonum-Positive-Zero
syntax
Float-Zero
syntax
Flonum-Zero
syntax
Float-Nan
syntax
Flonum-Nan
syntax
Positive-Single-Flonum
syntax
Nonnegative-Single-Flonum
syntax
Negative-Single-Flonum
syntax
Nonpositive-Single-Flonum
syntax
Single-Flonum-Negative-Zero
syntax
Single-Flonum-Positive-Zero
syntax
Single-Flonum-Zero
syntax
Single-Flonum-Nan
syntax
Positive-Inexact-Real
syntax
Nonnegative-Inexact-Real
syntax
Negative-Inexact-Real
syntax
Nonpositive-Inexact-Real
syntax
Inexact-Real-Negative-Zero
syntax
Inexact-Real-Positive-Zero
syntax
Inexact-Real-Zero
syntax
Inexact-Real-Nan
syntax
Positive-Exact-Rational
syntax
Nonnegative-Exact-Rational
syntax
Negative-Exact-Rational
syntax
Nonpositive-Exact-Rational
syntax
Positive-Real
syntax
Nonnegative-Real
syntax
Negative-Real
syntax
Nonpositive-Real
syntax
Real-Zero
syntax
One
syntax
Byte
syntax
Positive-Byte
syntax
Index
syntax
Positive-Index
syntax
Fixnum
syntax
Positive-Fixnum
syntax
Nonnegative-Fixnum
syntax
Negative-Fixnum
syntax
Nonpositive-Fixnum
syntax
Boolean
syntax
True
syntax
False
syntax
String
syntax
Keyword
syntax
Symbol
syntax
Char
syntax
Void
syntax
Input-Port
syntax
Output-Port
syntax
Port
syntax
Path
syntax
Path-For-Some-System
syntax
Regexp
syntax
PRegexp
syntax
Byte-Regexp
syntax
Byte-PRegexp
syntax
Bytes
syntax
Namespace
syntax
Namespace-Anchor
syntax
Variable-Reference
syntax
Null
syntax
EOF
syntax
Continuation-Mark-Set
syntax
Undefined
syntax
Module-Path
syntax
Module-Path-Index
syntax
Resolved-Module-Path
syntax
Compiled-Module-Expression
syntax
Compiled-Expression
syntax
Internal-Definition-Context
syntax
Pretty-Print-Style-Table
syntax
Special-Comment
syntax
Struct-Type-Property
syntax
Impersonator-Property
syntax
Read-Table
syntax
Bytes-Converter
syntax
Parameterization
syntax
Custodian
syntax
Inspector
syntax
Security-Guard
syntax
UDP-Socket
syntax
TCP-Listener
syntax
Logger
syntax
Log-Receiver
syntax
Log-Level
syntax
Thread
syntax
Thread-Group
syntax
Subprocess
syntax
Place
syntax
Place-Channel
syntax
Semaphore
syntax
Will-Executor
syntax
Pseudo-Random-Generator
syntax
Path-String
syntax
(PairofÂ sÂ t)
syntax
(ListofÂ t)
syntax
(ListÂ tÂ ...)
syntax
(ListÂ tÂ ...Â trestÂ ...Â bound)
syntax
(List*Â tÂ t1Â ...Â s)
syntax
(MListofÂ t)
syntax
(MPairofÂ tÂ u)
syntax
MPairTop
syntax
(BoxofÂ t)
syntax
BoxTop
syntax
(VectorofÂ t)
syntax
(VectorÂ tÂ ...)
syntax
FlVector
syntax
VectorTop
syntax
(HashTableÂ kÂ v)
syntax
HashTableTop
syntax
(SetofÂ t)
syntax
(ChannelofÂ t)
syntax
ChannelTop
syntax
(ParameterofÂ t)
(ParameterofÂ sÂ t)
syntax
(PromiseÂ t)
syntax
(FutureofÂ t)
syntax
(SequenceofÂ t)
syntax
(Custodian-BoxofÂ t)
syntax
(Thread-CellofÂ t)
syntax
Thread-CellTop
syntax
(EphemeronofÂ t)
syntax
(EvtofÂ t)
syntax
(SyntaxofÂ t)
syntax
Identifier
syntax
Syntax
syntax
Syntax-E
syntax
(SexpofÂ t)
syntax
Sexp
syntax
Datum
syntax
(Prompt-TagofÂ sÂ t)
syntax
Prompt-TagTop
syntax
(Continuation-Mark-KeyofÂ t)
syntax
Continuation-Mark-KeyTop
syntax
(domÂ ...Â ->Â rng)
(domÂ ...Â restÂ *Â ->Â rng)
(domÂ ...Â restÂ oooÂ boundÂ ->Â rng)
(domÂ ->Â rngÂ :Â pred)
Â 
oooÂ =Â ...
Â   Â Â Â Â 
domÂ =Â type
Â   Â |Â keywordÂ type
Â   Â |Â [keywordÂ type]
syntax
Procedure
syntax
(UÂ tÂ ...)
syntax
(case->Â fun-tyÂ ...)
syntax
(tÂ t1Â t2Â ...)
syntax
(AllÂ (aÂ ...)Â t)
(AllÂ (aÂ ...Â aÂ ooo)Â t)
syntax
(ValuesÂ tÂ ...)
syntax
v
syntax
(quoteÂ val)
syntax
i
syntax
(RecÂ nÂ t)
syntax
(StructÂ st)
syntax
(Struct-TypeÂ st)
syntax
Struct-TypeTop
syntax
â
syntax
caseâ
syntax
â
syntax
(OptionÂ t)
syntax
(OpaqueÂ t)
syntax
(let:Â ([vÂ :Â tÂ e]Â ...)Â . body)
(let:Â loopÂ :Â t0Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(plet:Â (aÂ ...)Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(letrec:Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(let*:Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(let-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(letrec-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(let*-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(let/cc:Â vÂ :Â tÂ . body)
syntax
(let/ec:Â vÂ :Â tÂ . body)
syntax
(lambda:Â formalsÂ . body)
Â 
formalsÂ =Â ([vÂ :Â t]Â ...)
Â       Â |Â ([vÂ :Â t]Â ...Â vÂ :Â tÂ *)
Â       Â |Â ([vÂ :Â t]Â ...Â vÂ :Â tÂ oooÂ bound)
syntax
(Î»:Â formalsÂ . body)
syntax
(plambda:Â (aÂ ...)Â formalsÂ . body)
(plambda:Â (aÂ ...Â bÂ ooo)Â formalsÂ . body)
syntax
(case-lambda:Â [formalsÂ body]Â ...)
syntax
(pcase-lambda:Â (aÂ ...)Â [formalsÂ body]Â ...)
(pcase-lambda:Â (aÂ ...Â bÂ ooo)Â [formalsÂ body]Â ...)
syntax
(opt-lambda:Â formalsÂ . body)
Â 
formalsÂ =Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...)
Â       Â |Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...Â vÂ :Â tÂ *)
Â       Â |Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...Â vÂ :Â tÂ oooÂ bound)
syntax
(popt-lambda:Â (aÂ ...)Â formalsÂ . body)
(popt-lambda:Â (aÂ ...Â aÂ ooo)Â formalsÂ . body)
syntax
(for:Â type-ann-maybeÂ (for:-clauseÂ ...)
Â Â exprÂ ...+)
Â 
type-ann-maybeÂ =Â 
Â              Â |Â :Â u
Â              Â Â Â Â 
for:-clause   Â =Â [idÂ :Â tÂ seq-expr]
Â              Â |Â [idÂ seq-expr]
Â              Â |Â #:whenÂ guard
syntax
(for/list:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hash:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hasheq:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hasheqv:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/vector:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/flvector:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/and:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/or:Â Â Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/first:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/last:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/sum:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/product:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/list:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hash:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hasheq:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hasheqv:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/vector:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/flvector:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/and:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/or:Â Â Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/first:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/last:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/sum:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/product:Â type-ann-maybeÂ (for:-clauseÂ ...)Â exprÂ ...+)
syntax
(for/lists:Â type-ann-maybeÂ ([idÂ :Â t]Â ...)
Â Â (for:-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for/fold:Â Â type-ann-maybeÂ ([idÂ :Â tÂ init-expr]Â ...)
Â Â (for:-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*:Â void-ann-maybeÂ (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*/lists:Â type-ann-maybeÂ ([idÂ :Â t]Â ...)
Â Â (for:-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*/fold:Â Â type-ann-maybeÂ ([idÂ :Â tÂ init-expr]Â ...)
Â Â (for:-clauseÂ ...)
Â Â exprÂ ...+)
syntax
for
syntax
for*
syntax
(do:Â :Â uÂ ([idÂ :Â tÂ init-exprÂ step-expr-maybe]Â ...)
Â Â Â Â Â Â Â Â Â (stop?-exprÂ finish-exprÂ ...)
Â Â exprÂ ...+)
Â 
step-expr-maybeÂ =Â 
Â               Â |Â step-expr
syntax
(define:Â vÂ :Â tÂ e)
(define:Â (aÂ ...)Â vÂ :Â tÂ e)
(define:Â (aÂ ...Â aÂ ooo)Â vÂ :Â tÂ e)
(define:Â (fÂ . formals)Â :Â tÂ . body)
(define:Â (aÂ ...)Â (fÂ . formals)Â :Â tÂ . body)
(define:Â (aÂ ...Â aÂ ooo)Â (fÂ . formals)Â :Â tÂ . body)
syntax
(struct:Â maybe-type-varsÂ name-specÂ ([fÂ :Â t]Â ...)Â optionsÂ ...)
Â 
maybe-type-varsÂ =Â 
Â               Â |Â (vÂ ...)
Â               Â Â Â Â 
name-spec      Â =Â name
Â               Â |Â nameÂ parent
Â               Â Â Â Â 
options        Â =Â #:transparent
Â               Â |Â #:mutable
syntax
(define-struct:Â maybe-type-varsÂ name-specÂ ([fÂ :Â t]Â ...)Â optionsÂ ...)
Â 
maybe-type-varsÂ =Â 
Â               Â |Â (vÂ ...)
Â               Â Â Â Â 
name-spec      Â =Â name
Â               Â |Â (nameÂ parent)
Â               Â Â Â Â 
options        Â =Â #:transparent
Â               Â |Â #:mutable
syntax
(define-struct/exec:Â name-specÂ ([fÂ :Â t]Â ...)Â [eÂ :Â proc-t])
Â 
name-specÂ =Â name
Â         Â |Â (nameÂ parent)
syntax
(define-typeÂ nameÂ tÂ maybe-omit-def)
(define-typeÂ (nameÂ vÂ ...)Â tÂ maybe-omit-def)
Â 
maybe-omit-defÂ =Â #:omit-define-syntaxes
Â              Â |Â 
syntax
(make-predicateÂ t)
syntax
(define-predicateÂ nameÂ t)
syntax
(:Â vÂ t)
(:Â vÂ :Â t)
syntax
(provide:Â [vÂ t]Â ...)
syntax
#{vÂ :Â t}
syntax
(annÂ eÂ t)
syntax
#{eÂ ::Â t}
syntax
(castÂ eÂ t)
syntax
(instÂ eÂ tÂ ...)
(instÂ eÂ tÂ ...Â tÂ oooÂ bound)
syntax
#{eÂ @Â tÂ ...}
syntax
#{eÂ @Â tÂ ...Â tÂ oooÂ bound}
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
rt-clause    Â =Â [maybe-renamedÂ t]
Â             Â |Â [#:structÂ nameÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
Â             Â |Â [#:structÂ (nameÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
Â             Â |Â [#:opaqueÂ tÂ pred]
Â             Â Â Â Â 
maybe-renamedÂ =Â id
Â             Â |Â (orig-idÂ new-id)
Â             Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
Â             Â |Â #:extra-constructor-nameÂ constructor-id
syntax
(require/typed/provideÂ mÂ rt-clauseÂ ...)
syntax
with-handlers
syntax
lambda
syntax
Î»
syntax
define
procedure
(default-continuation-prompt-tag)
Â ->Â (->Â (Prompt-TagofÂ AnyÂ (AnyÂ ->Â Any)))
syntax
(#%module-beginÂ formÂ ...)
syntax
(#%top-interactionÂ . form)
procedure
(assertÂ v)Â ->Â A
Â Â vÂ :Â (UÂ #fÂ A)
(assertÂ vÂ p?)Â ->Â B
Â Â vÂ :Â A
Â Â p?Â :Â (AÂ ->Â AnyÂ :Â B)
syntax
(with-assertsÂ ([idÂ maybe-pred]Â ...)Â bodyÂ ...+)
Â 
maybe-predÂ =Â 
Â          Â |Â predicate
procedure
(defined?Â v)Â ->Â boolean?
Â Â vÂ :Â any/c
procedure
(index?Â v)Â ->Â boolean?
Â Â vÂ :Â any/c
syntax
(typecheck-failÂ orig-stxÂ maybe-msgÂ maybe-id)
Â 
maybe-msgÂ =Â 
Â         Â |Â msg-string
Â         Â Â Â Â 
maybe-id Â =Â 
Â         Â |Â #:covered-idÂ id
syntax
(:typeÂ maybe-verboseÂ t)
Â 
maybe-verboseÂ =Â 
Â             Â |Â #:verbose
syntax
(:print-typeÂ e)
syntax
(:query-type/argsÂ fÂ tÂ ...)
syntax
(:query-type/resultÂ fÂ t)
syntax
(with-typeÂ result-specÂ fv-clauseÂ bodyÂ ...+)
(with-typeÂ export-specÂ fv-clauseÂ bodyÂ ...+)
Â 
fv-clause  Â =Â 
Â           Â |Â #:freevarsÂ ([idÂ fv-type]Â ...)
Â           Â Â Â Â 
result-specÂ =Â #:resultÂ type
Â           Â Â Â Â 
export-specÂ =Â ([export-idÂ export-type]Â ...)
syntax
define-type-alias
syntax
define-typed-struct
syntax
require/opaque-type
syntax
require-typed-struct
syntax
require-typed-struct/provide
syntax
pdefine:
syntax
(predÂ t)
syntax
Un
syntax
mu
syntax
Tuple
syntax
Parameter
syntax
Pair
syntax
values
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
rt-clause    Â =Â [rÂ t]
Â             Â |Â [structÂ nameÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
Â             Â |Â [structÂ (nameÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
Â             Â |Â [opaqueÂ tÂ pred]
Â             Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
Â             Â |Â #:extra-constructor-nameÂ constructor-id
syntax
require-typed-struct
syntax
(ClassÂ argsÂ ...)
syntax
(InstanceÂ c)
syntax
(declare-refinementÂ id)
syntax
(RefinementÂ id)
syntax
(define-typed-struct/execÂ formsÂ ...)
