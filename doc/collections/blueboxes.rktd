4126
((3) 0 () 1 ((q lib "data/collection.rkt")) () (h ! (equal) ((c def c (c (? . 0) q tenth)) q (6642 . 3)) ((c def c (c (? . 0) q repeat)) q (2319 . 3)) ((c def c (c (? . 0) q gen:collection)) q (0 . 2)) ((c def c (c (? . 0) q flatten)) q (5611 . 3)) ((c def c (c (? . 0) q index-where)) q (5031 . 4)) ((c def c (c (? . 0) q subsequence)) q (3302 . 5)) ((c def c (c (? . 0) q sequence->string)) q (7188 . 3)) ((c form c (c (? . 0) q sequence)) q (8019 . 7)) ((c def c (c (? . 0) q set-ref)) q (7894 . 5)) ((c def c (c (? . 0) q conj)) q (88 . 4)) ((c def c (c (? . 0) q reverse)) q (1485 . 3)) ((c def c (c (? . 0) q last)) q (1692 . 3)) ((c def c (c (? . 0) q sequence->bytes)) q (7287 . 3)) ((c def c (c (? . 0) q sequenceof)) q (8105 . 4)) ((c def c (c (? . 0) q remove-all)) q (5465 . 5)) ((c def c (c (? . 0) q countable?)) q (7487 . 3)) ((c def c (c (? . 0) q chunk)) q (5780 . 4)) ((c def c (c (? . 0) q seventh)) q (6471 . 3)) ((c def c (c (? . 0) q length)) q (7543 . 3)) ((c def c (c (? . 0) q sixth)) q (6415 . 3)) ((c form c (c (? . 0) q for*/sequence)) q (6820 . 2)) ((c def c (c (? . 0) q indexable?)) q (7744 . 3)) ((c def c (c (? . 0) q ninth)) q (6586 . 3)) ((c form c (c (? . 0) q for/sequence/derived)) q (6888 . 2)) ((c def c (c (? . 0) q naturals)) q (2462 . 3)) ((c def c (c (? . 0) q third)) q (6246 . 3)) ((c def c (c (? . 0) q sequence->list)) q (7057 . 3)) ((c def c (c (? . 0) q range)) q (2552 . 7)) ((c def c (c (? . 0) q take)) q (3104 . 4)) ((c def c (c (? . 0) q map)) q (3722 . 4)) ((c def c (c (? . 0) q gen:indexable)) q (7714 . 2)) ((c def c (c (? . 0) q sequence->collection)) q (1547 . 3)) ((c def c (c (? . 0) q update-nth)) q (1016 . 5)) ((c def c (c (? . 0) q chunk*)) q (5891 . 4)) ((c def c (c (? . 0) q drop)) q (3203 . 4)) ((c def c (c (? . 0) q in)) q (6698 . 3)) ((c def c (c (? . 0) q andmap)) q (4155 . 4)) ((c form c (c (? . 0) q for/sequence)) q (6753 . 2)) ((c def c (c (? . 0) q nth)) q (777 . 4)) ((c def c (c (? . 0) q filter)) q (3619 . 4)) ((c def c (c (? . 0) q random-access?)) q (1624 . 3)) ((c def c (c (? . 0) q remove-first)) q (5147 . 10)) ((c def c (c (? . 0) q fourth)) q (6302 . 3)) ((c def c (c (? . 0) q rest)) q (696 . 3)) ((c def c (c (? . 0) q empty?)) q (554 . 3)) ((c form c (c (? . 0) q for*/sequence/derived)) q (6972 . 2)) ((c def c (c (? . 0) q index-of)) q (4869 . 5)) ((c def c (c (? . 0) q eighth)) q (6529 . 3)) ((c def c (c (? . 0) q append-map)) q (6003 . 4)) ((c def c (c (? . 0) q cycle)) q (2376 . 3)) ((c def c (c (? . 0) q append*)) q (1969 . 4)) ((c def c (c (? . 0) q apply)) q (1747 . 6)) ((q form ((lib "data/collection/experimental/quasi.rkt") quasiquote)) q (8230 . 2)) ((c def c (c (? . 0) q append)) q (1903 . 3)) ((c def c (c (? . 0) q gen:sequence)) q (470 . 2)) ((c def c (c (? . 0) q find-best)) q (4340 . 5)) ((c def c (c (? . 0) q collection?)) q (31 . 3)) ((c def c (c (? . 0) q sequence->list*)) q (7122 . 3)) ((c def c (c (? . 0) q subsequence*)) q (3460 . 5)) ((c def c (c (? . 0) q update-nth*)) q (1319 . 5)) ((c def c (c (? . 0) q find-max)) q (4708 . 4)) ((c def c (c (? . 0) q set-nth*)) q (1171 . 5)) ((c def c (c (? . 0) q randoms)) q (2718 . 9)) ((c def c (c (? . 0) q sequence?)) q (499 . 3)) ((c def c (c (? . 0) q foldl)) q (3816 . 5)) ((c def c (c (? . 0) q cartesian-product)) q (6098 . 3)) ((c def c (c (? . 0) q ref)) q (7800 . 4)) ((c def c (c (? . 0) q set-nth)) q (879 . 5)) ((c def c (c (? . 0) q known-finite?)) q (7634 . 3)) ((c def c (c (? . 0) q generate-sequence)) q (7384 . 3)) ((c def c (c (? . 0) q conj*)) q (262 . 4)) ((c def c (c (? . 0) q ormap)) q (4248 . 4)) ((c def c (c (? . 0) q fifth)) q (6359 . 3)) ((c def c (c (? . 0) q gen:countable)) q (7457 . 2)) ((c def c (c (? . 0) q indexed)) q (5669 . 4)) ((c def c (c (? . 0) q first)) q (614 . 3)) ((c def c (c (? . 0) q extend)) q (178 . 4)) ((c def c (c (? . 0) q extend*)) q (358 . 4)) ((c def c (c (? . 0) q find-min)) q (4547 . 4)) ((c def c (c (? . 0) q for-each)) q (4060 . 4)) ((c def c (c (? . 0) q build-sequence)) q (2079 . 6)) ((c def c (c (? . 0) q foldl/steps)) q (3933 . 5)) ((c def c (c (? . 0) q second)) q (6189 . 3))))
value
gen:collection : any/c
procedure
(collection? v) -> boolean?
  v : any/c
procedure
(conj coll item) -> collection?
  coll : collection?
  item : any/c
procedure
(extend a b) -> collection?
  a : collection?
  b : sequence?
procedure
(conj* coll item ...) -> collection?
  coll : collection?
  item : any/c
procedure
(extend* base extension ...) -> collection?
  base : collection?
  extension : sequence?
value
gen:sequence : any/c
procedure
(sequence? v) -> boolean?
  v : any/c
procedure
(empty? seq) -> boolean?
  seq : sequence?
procedure
(first seq) -> any/c
  seq : (and/c sequence? (not/c empty?))
procedure
(rest seq) -> any/c
  seq : (and/c sequence? (not/c empty?))
procedure
(nth seq index) -> any/c
  seq : sequence?
  index : exact-nonnegative-integer?
procedure
(set-nth seq index value) -> sequence?
  seq : sequence?
  index : exact-nonnegative-integer?
  value : any/c
procedure
(update-nth seq index proc) -> sequence?
  seq : sequence?
  index : exact-nonnegative-integer?
  proc : (any/c . -> . any/c)
procedure
(set-nth* seq index value ... ...) -> sequence?
  seq : sequence?
  index : exact-nonnegative-integer?
  value : any/c
procedure
(update-nth* seq index proc ... ...) -> sequence?
  seq : sequence?
  index : exact-nonnegative-integer?
  proc : (any/c . -> . any/c)
procedure
(reverse seq) -> sequence?
  seq : sequence?
procedure
(sequence->collection seq) -> collection?
  seq : sequence?
procedure
(random-access? seq) -> boolean?
  seq : sequence?
procedure
(last seq) -> any/c
  seq : sequence?
procedure
(apply proc arg ... args #:<kw> kw-arg ...) -> any
  proc : procedure?
  arg : any/c
  args : sequence?
  kw-arg : any/c
procedure
(append seq ...) -> sequence?
  seq : sequence?
procedure
(append* seq ... seqs) -> sequence?
  seq : sequence?
  seqs : (sequenceof sequence?)
procedure
(build-sequence proc) -> sequence?
  proc : (exact-nonnegative-integer? . -> . any/c)
(build-sequence n proc) -> sequence?
  n : exact-nonnegative-integer?
  proc : (exact-nonnegative-integer? . -> . any/c)
procedure
(repeat val) -> sequence?
  val : any/c
procedure
(cycle seq) -> sequence?
  seq : (and/c sequence? (not/c empty?))
procedure
(naturals [start]) -> stream?
  start : exact-nonnegative-integer? = 0
procedure
(range end) -> stream?
  end : number?
(range start end [step]) -> stream?
  start : number?
  end : number?
  step : number? = 1
procedure
(randoms [rand-gen])
 -> (sequenceof (and/c real? inexact? (>/c 0) (</c 1)))
  rand-gen : pseudo-random-generator?
           = (make-pseudo-random-generator)
(randoms k [rand-gen]) -> (sequenceof exact-nonnegative-integer?)
  k : (integer-in 1 4294967087)
  rand-gen : pseudo-random-generator?
           = (make-pseudo-random-generator)
procedure
(take n seq) -> sequence?
  n : exact-nonnegative-integer?
  seq : sequence?
procedure
(drop n seq) -> sequence?
  n : exact-nonnegative-integer?
  seq : sequence?
procedure
(subsequence seq start end) -> sequence?
  seq : sequence?
  start : exact-nonnegative-integer?
  end : exact-nonnegative-integer?
procedure
(subsequence* seq start len) -> sequence?
  seq : sequence?
  start : exact-nonnegative-integer?
  len : exact-nonnegative-integer?
procedure
(filter pred seq) -> sequence?
  pred : (any/c . -> . any/c)
  seq : sequence?
procedure
(map proc seq ...+) -> sequence?
  proc : procedure?
  seq : sequence?
procedure
(foldl proc init seq ...+) -> any/c
  proc : procedure?
  init : any/c
  seq : sequence?
procedure
(foldl/steps proc init seq ...+) -> sequence?
  proc : procedure?
  init : any/c
  seq : sequence?
procedure
(for-each proc seq ...+) -> void?
  proc : procedure?
  seq : sequence?
procedure
(andmap proc seq ...+) -> any/c
  proc : procedure?
  seq : sequence?
procedure
(ormap proc seq ...+) -> any/c
  proc : procedure?
  seq : sequence?
procedure
(find-best seq >? [#:key extract-key]) -> any/c
  seq : (and/c sequence? (not/c empty?))
  >? : (any/c any/c . -> . any/c)
  extract-key : (any/c . -> . any/c) = values
procedure
(find-min seq [#:key extract-key]) -> any/c
  seq : (and/c sequence? (not/c empty?))
  extract-key : (any/c . -> . real?) = values
procedure
(find-max seq [#:key extract-key]) -> any/c
  seq : (and/c sequence? (not/c empty?))
  extract-key : (any/c . -> . real?) = values
procedure
(index-of seq v [is-equal?]) -> (or/c any/c #f)
  seq : sequence?
  v : any/c
  is-equal? : (any/c any/c . -> . any/c) = equal?
procedure
(index-where seq proc) -> (or/c any/c #f)
  seq : sequence?
  proc : (any/c . -> . any/c)
procedure
(remove-first seq val [=?]) -> sequence?
  seq : sequence?
  val : any/c
  =? : (any/c any/c . -> . any/c) = equal?
(remove-first seq val =? failure-thunk) -> any/c
  seq : sequence?
  val : any/c
  =? : (any/c any/c . -> . any/c)
  failure-thunk : (-> any/c)
procedure
(remove-all seq val [=?]) -> sequence?
  seq : sequence?
  val : any/c
  =? : (any/c any/c . -> . any/c) = equal?
procedure
(flatten s) -> sequence?
  s : sequence?
procedure
(indexed seq)
 -> (sequenceof (cons/c exact-nonnegative-integer? any/c))
  seq : sequence?
procedure
(chunk n seq) -> (sequenceof sequence?)
  n : exact-positive-integer?
  seq : sequence?
procedure
(chunk* n seq) -> (sequenceof sequence?)
  n : exact-positive-integer?
  seq : sequence?
procedure
(append-map f seq ...+) -> sequence?
  f : procedure?
  seq : sequence?
procedure
(cartesian-product seq ...) -> (sequenceof sequence?)
  seq : sequence?
procedure
(second seq) -> any/c
  seq : sequence?
procedure
(third seq) -> any/c
  seq : sequence?
procedure
(fourth seq) -> any/c
  seq : sequence?
procedure
(fifth seq) -> any/c
  seq : sequence?
procedure
(sixth seq) -> any/c
  seq : sequence?
procedure
(seventh seq) -> any/c
  seq : sequence?
procedure
(eighth seq) -> any/c
  seq : sequence?
procedure
(ninth seq) -> any/c
  seq : sequence?
procedure
(tenth seq) -> any/c
  seq : sequence?
procedure
(in seq) -> stream?
  seq : sequence?
syntax
(for/sequence (for-clause ...) body-or-break ... body)
syntax
(for*/sequence (for-clause ...) body-or-break ... body)
syntax
(for/sequence/derived name-id (for-clause ...) body-or-break ... body)
syntax
(for*/sequence/derived name-id (for-clause ...) body-or-break ... body)
procedure
(sequence->list seq) -> list?
  seq : sequence?
procedure
(sequence->list* seq) -> list?
  seq : sequence?
procedure
(sequence->string seq) -> (and/c string? sequence?)
  seq : (sequenceof char?)
procedure
(sequence->bytes seq) -> (and/c bytes? sequence?)
  seq : (sequenceof byte?)
procedure
(generate-sequence gen) -> sequence?
  gen : generator?
value
gen:countable : any/c
procedure
(countable? v) -> boolean?
  v : any/c
procedure
(length countable) -> exact-nonnegative-integer?
  countable : countable?
procedure
(known-finite? countable) -> boolean?
  countable : countable?
value
gen:indexable : any/c
procedure
(indexable? v) -> boolean?
  v : any/c
procedure
(ref collection index) -> any
  collection : indexable?
  index : any/c
procedure
(set-ref collection index value) -> any
  collection : indexable?
  index : any/c
  value : any/c
syntax
(sequence svp ...)
 
svp = pat
    | pat ooo
       
ooo = ...
procedure
(sequenceof ctc [#:chaperone? chaperone?]) -> contract?
  ctc : contract?
  chaperone? : any/c = #f
syntax
(quasiquote datum)
