9385
((3) 0 () 21 ((q lib "mzlib/contract.rkt") (q lib "mzlib/compat.rkt") (q lib "mzlib/pconvert-prop.rkt") (q lib "mzlib/etc.rkt") (q lib "mzlib/string.rkt") (q lib "mzlib/pconvert.rkt") (q lib "mzlib/file.rkt") (q lib "mzlib/list.rkt") (q lib "mzlib/match.rkt") (q lib "mzlib/struct.rkt") (q lib "mzlib/class100.rkt") (q lib "mzlib/awk.rkt") (q lib "mzlib/include.rkt") (q lib "mzlib/cml.rkt") (q submod (lib "racket/unit.rkt") compat) (q lib "mzlib/serialize.rkt") (q lib "mzlib/kw.rkt") (q lib "mzlib/pregexp.rkt") (q lib "mzlib/os.rkt") (q lib "mzlib/transcr.rkt") (q lib "mzlib/thread.rkt")) () (h ! (equal) ((c form c (c (? . 3) q rec)) q (9327 . 4)) ((c def c (c (? . 2) q print-converter-proc)) q (17468 . 4)) ((c form c (c (? . 9) q define-struct/properties)) q (24577 . 7)) ((c form c (c (? . 0) q case->)) q (8221 . 2)) ((c def c (c (? . 1) q getprop)) q (5535 . 5)) ((c form c (c (? . 0) q ->d)) q (6886 . 2)) ((c def c (c (? . 5) q whole/fractional-exact-numbers)) q (17230 . 4)) ((c def c (c (? . 1) q >?)) q (4837 . 3)) ((c def c (c (? . 7) q third)) q (12767 . 3)) ((c def c (c (? . 4) q glob->regexp)) q (23091 . 10)) ((c def c (c (? . 6) q build-absolute-path)) q (10571 . 8)) ((c def c (c (? . 11) q regexp-exec)) q (1630 . 4)) ((c def c (c (? . 2) q prop:print-convert-constructor-name)) q (17584 . 2)) ((c form c (c (? . 3) q this-expression-source-directory)) q (9429 . 3)) ((q def ((lib "mzlib/sendevent.rkt") send-event)) q (21684 . 14)) ((c def c (c (? . 4) q eval-string)) q (23684 . 6)) ((c def c (c (? . 2) q print-converter?)) q (17411 . 3)) ((c def c (c (? . 5) q quasi-read-style-printing)) q (17024 . 4)) ((c def c (c (? . 6) q call-with-output-file*)) q (9827 . 11)) ((c def c (c (? . 2) q print-convert-named-constructor?)) q (17640 . 3)) ((c form c (c (? . 0) q ->r)) q (7085 . 7)) ((c form c (c (? . 8) q match-letrec)) q (13974 . 2)) ((c form c (c (? . 15) q define-serializable-struct)) q (22394 . 2)) ((c form c (c (? . 12) q include-at/relative-to)) q (11172 . 2)) ((c def c (c (? . 6) q build-relative-path)) q (10275 . 7)) ((c form c (c (? . 3) q begin-with-definitions)) q (8384 . 2)) ((c def c (c (? . 17) q pregexp-match-positions)) q (18732 . 15)) ((c def c (c (? . 7) q second)) q (12703 . 3)) ((c form c (c (? . 0) q ->)) q (6328 . 3)) ((c form c (c (? . 3) q opt-lambda)) q (9245 . 2)) ((c def c (c (? . 5) q build-share)) q (15304 . 3)) ((c def c (c (? . 6) q call-with-input-file*)) q (9650 . 5)) ((c form c (c (? . 8) q match-define)) q (14028 . 2)) ((c form c (c (? . 3) q recur)) q (9286 . 2)) ((c form c (c (? . 8) q define-match-expander)) q (14061 . 4)) ((c form c (c (? . 10) q class100*-asi)) q (3449 . 2)) ((c def c (c (? . 5) q current-build-share-name-hook)) q (15778 . 5)) ((c def c (c (? . 16) q keyword-get)) q (12504 . 5)) ((c form c (c (? . 8) q match-lambda*)) q (13835 . 2)) ((c form c (c (? . 0) q ->pp)) q (7288 . 11)) ((c def c (c (? . 5) q current-read-eval-convert-print-prompt)) q (16351 . 4)) ((c form c (c (? . 9) q make-->vector)) q (24846 . 2)) ((c def c (c (? . 1) q 1-)) q (5050 . 3)) ((c def c (c (? . 1) q flush-output-port)) q (5185 . 3)) ((c form c (c (? . 3) q this-expression-file-name)) q (9513 . 3)) ((c def c (c (? . 0) q vectorof)) q (6006 . 3)) ((c form c (c (? . 3) q let+)) q (8675 . 11)) ((c form c (c (? . 10) q class100*)) q (1742 . 36)) ((c form c (c (? . 9) q copy-struct)) q (24475 . 3)) ((c def c (c (? . 4) q read-from-string)) q (23985 . 6)) ((c def c (c (? . 11) q match:substring)) q (1511 . 4)) ((c def c (c (? . 1) q =?)) q (4727 . 3)) ((c form c (c (? . 12) q include/reader)) q (11312 . 2)) ((c def c (c (? . 3) q loop-until)) q (8947 . 6)) ((c def c (c (? . 1) q real-time)) q (5280 . 2)) ((c form c (c (? . 14) q struct~s/ctc)) q (26394 . 2)) ((c def c (c (? . 5) q install-converting-printer)) q (16643 . 2)) ((c def c (c (? . 11) q match:start)) q (1245 . 4)) ((c def c (c (? . 0) q box/c)) q (5940 . 3)) ((c def c (c (? . 4) q expr->string)) q (23922 . 3)) ((c def c (c (? . 7) q last-pair)) q (13196 . 3)) ((c def c (c (? . 1) q gentmp)) q (5099 . 3)) ((c form c (c (? . 10) q class100-asi)) q (3390 . 2)) ((c form c (c (? . 0) q struct/c)) q (6149 . 2)) ((c form c (c (? . 0) q define/contract)) q (5879 . 2)) ((c def c (c (? . 18) q getpid)) q (14428 . 2)) ((c def c (c (? . 5) q print-convert)) q (16693 . 4)) ((c def c (c (? . 0) q vector/c)) q (6075 . 3)) ((c def c (c (? . 2) q prop:print-converter)) q (17370 . 2)) ((c form c (c (? . 12) q include)) q (10944 . 10)) ((c form c (c (? . 0) q ->pp-rest)) q (7649 . 13)) ((c def c (c (? . 5) q constructor-style-printing)) q (15357 . 4)) ((c def c (c (? . 13) q spawn)) q (4336 . 3)) ((c def c (c (? . 4) q string-uppercase!)) q (23588 . 3)) ((c form c (c (? . 3) q hash-table)) q (9583 . 2)) ((q def ((lib "mzlib/port.rkt") strip-shell-command-start)) q (17968 . 3)) ((c form c (c (? . 10) q class100)) q (3309 . 4)) ((c def c (c (? . 5) q current-print-convert-hook)) q (15972 . 8)) ((c def c (c (? . 1) q putprop)) q (5666 . 5)) ((c def c (c (? . 13) q channel-recv-evt)) q (4432 . 3)) ((q form ((lib "mzlib/plt-match.rkt") define-match-expander)) q (17811 . 4)) ((c form c (c (? . 3) q begin-lifted)) q (8350 . 2)) ((c form c (c (? . 3) q define-syntax-set)) q (8435 . 2)) ((c def c (c (? . 3) q namespace-defined?)) q (9126 . 3)) ((c def c (c (? . 7) q rest)) q (13149 . 3)) ((c def c (c (? . 4) q read-from-string-all)) q (24228 . 6)) ((c form c (c (? . 14) q struct/ctc)) q (26167 . 7)) ((q form ((lib "mzlib/cmdline.rkt") command-line)) q (3561 . 21)) ((c form c (c (? . 14) q struct~s)) q (26378 . 2)) ((c form c (c (? . 15) q define-serializable-struct/versions)) q (22485 . 13)) ((c form c (c (? . 16) q lambda/kw)) q (11360 . 2)) ((c def c (c (? . 0) q build-flat-contract)) q (6203 . 4)) ((c def c (c (? . 7) q quicksort)) q (13517 . 4)) ((c def c (c (? . 7) q seventh)) q (13020 . 3)) ((c def c (c (? . 20) q consumer-thread)) q (24880 . 4)) ((c form c (c (? . 8) q match)) q (13634 . 5)) ((c form c (c (? . 8) q define/match)) q (13744 . 2)) ((c def c (c (? . 5) q abbreviate-cons-as-list)) q (14596 . 4)) ((c form c (c (? . 14) q struct~r)) q (26342 . 2)) ((c def c (c (? . 1) q 1+)) q (5001 . 3)) ((c def c (c (? . 1) q new-cafe)) q (5784 . 3)) ((c def c (c (? . 7) q sixth)) q (12957 . 3)) ((c def c (c (? . 1) q atom?)) q (5322 . 3)) ((q def ((lib "mzlib/sandbox.rkt") make-evaluator)) q (20889 . 15)) ((c def c (c (? . 13) q channel)) q (4398 . 2)) ((q def ((lib "mzlib/math.rkt") e)) q (14373 . 2)) ((c form c (c (? . 10) q super-init)) q (3521 . 2)) ((c form c (c (? . 0) q opt->)) q (6579 . 3)) ((c def c (c (? . 5) q named/undefined-handler)) q (15007 . 4)) ((c form c (c (? . 14) q struct)) q (26013 . 7)) ((c def c (c (? . 5) q booleans-as-true/false)) q (14722 . 4)) ((c form c (c (? . 3) q nand)) q (9196 . 2)) ((c def c (c (? . 7) q fourth)) q (12830 . 3)) ((c form c (c (? . 1) q define-structure)) q (5368 . 4)) ((q def ((lib "mzlib/restart.rkt") restart-mzscheme)) q (20534 . 9)) ((c form c (c (? . 8) q match-lambda)) q (13800 . 2)) ((c def c (c (? . 19) q transcript-on)) q (25909 . 3)) ((c def c (c (? . 17) q pregexp-split)) q (19476 . 9)) ((c def c (c (? . 7) q fifth)) q (12894 . 3)) ((c def c (c (? . 13) q thread-done-evt)) q (4577 . 3)) ((c def c (c (? . 2) q print-convert-constructor-name)) q (17713 . 3)) ((c form c (c (? . 0) q object-contract)) q (8278 . 2)) ((c def c (c (? . 7) q first)) q (12655 . 3)) ((c def c (c (? . 17) q pregexp-match)) q (18044 . 15)) ((c def c (c (? . 18) q truncate-file)) q (14467 . 4)) ((c form c (c (? . 11) q awk)) q (0 . 38)) ((c def c (c (? . 5) q show-sharing)) q (17138 . 4)) ((c def c (c (? . 13) q current-time)) q (4639 . 2)) ((c def c (c (? . 5) q add-make-prefix-to-constructor)) q (15164 . 4)) ((c def c (c (? . 17) q pregexp-replace*)) q (20214 . 7)) ((c def c (c (? . 1) q >=?)) q (4946 . 3)) ((c def c (c (? . 5) q print-convert-expr)) q (16811 . 7)) ((c def c (c (? . 7) q eighth)) q (13085 . 3)) ((c form c (c (? . 0) q ->*)) q (6417 . 6)) ((c def c (c (? . 19) q transcript-off)) q (25977 . 2)) ((c def c (c (? . 8) q match-equality-test)) q (14218 . 4)) ((c def c (c (? . 4) q string-lowercase!)) q (23492 . 3)) ((c def c (c (? . 7) q merge-sorted-lists)) q (13248 . 5)) ((c form c (c (? . 0) q ->d*)) q (6946 . 3)) ((c def c (c (? . 5) q current-build-share-hook)) q (15501 . 7)) ((c def c (c (? . 20) q run-server)) q (24997 . 21)) ((c def c (c (? . 1) q <?)) q (4783 . 3)) ((c def c (c (? . 18) q gethostname)) q (14391 . 2)) ((c form c (c (? . 16) q define/kw)) q (11403 . 32)) ((c form c (c (? . 3) q evcase)) q (8484 . 3)) ((c form c (c (? . 8) q match-let)) q (13871 . 2)) ((c def c (c (? . 1) q <=?)) q (4891 . 3)) ((c def c (c (? . 13) q time-evt)) q (4675 . 3)) ((c form c (c (? . 14) q struct~r/ctc)) q (26358 . 2)) ((c form c (c (? . 0) q opt->*)) q (6728 . 3)) ((c def c (c (? . 11) q match:end)) q (1379 . 4)) ((c def c (c (? . 5) q get-shared)) q (16492 . 5)) ((c form c (c (? . 12) q include-at/relative-to/reader)) q (11232 . 2)) ((c def c (c (? . 3) q identity)) q (8624 . 3)) ((c form c (c (? . 8) q match-let*)) q (13922 . 2)) ((c def c (c (? . 5) q use-named/undefined-handler)) q (14842 . 4)) ((c def c (c (? . 17) q pregexp-replace)) q (19895 . 7)) ((c form c (c (? . 3) q nor)) q (9221 . 2)) ((c def c (c (? . 7) q mergesort)) q (13400 . 4)) ((c def c (c (? . 13) q channel-send-evt)) q (4495 . 4))))
syntax
(awk next-record-expr
     (record field-id ...)
     maybe-counter
     ((state-variable init-expr) ...)
     maybe-continue
  clause ...)
 
maybe-counter   = 
                | id
                   
maybe-continue  = 
                | id
                   
clause          = (test body ...+)
                | (test => procedure-expr)
                | (/ regexp-str / (id-or-false ...+) body ...+)
                | (range excl-start-test excl-stop-test body ...+)
                | (:range incl-start-test excl-stop-test body ...+)
                | (range: excl-start-test incl-stop-test body ...+)
                | (:range: incl-start-test incl-stop-test body ...+)
                | (else body ...+)
                | (after body ...+)
                   
test            = integer
                | regexp-string
                | expr
                   
excl-start-test = test
                   
excl-stop-test  = test
                   
incl-start-test = test
                   
incl-stop-test  = test
                   
id-or-false     = id
                | #f
procedure
(match:start rec [which]) -> exact-nonnegative-integer?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(match:end rec [which]) -> exact-nonnegative-integer?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(match:substring rec [which]) -> string?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(regexp-exec re s) -> (or/c .... false/c)
  re : (or/c string? regexp?)
  s : string?
syntax
(class100* superclass-expr (interface-expr ...) init-ids
  class100-clause
  ...)
 
init-ids            = id
                    | (id ... id-with-default ...)
                    | (id ... id-with-default ... . id)
                       
id-with-default     = (id default-expr)
                       
class100-clause     = (sequence expr ...)
                    | (public public-method-decl ...)
                    | (override public-method-decl ...)
                    | (augment public-method-decl ...)
                    | (pubment public-method-decl ...)
                    | (overment public-method-decl ...)
                    | (augride public-method-decl ...)
                    | (private private-method-decl ...)
                    | (private-field private-var-decl ...)
                    | (inherit inherit-method-decl ...)
                    | (rename rename-method-decl ...)
                       
public-method-decl  = ((internal-id external-id) method-procedure)
                    | (id method-procedure)
                       
private-method-decl = (id method-procedure)
                       
private-var-decl    = (id initial-value-expr)
                    | (id)
                    | id
                       
inherit-method-decl = id
                    | (internal-instance-id external-inherited-id)
                       
rename-method-decl  = (internal-id external-id)
syntax
(class100 superclass-expr init-ids
    class100-clause
    ...)
syntax
(class100-asi superclass instance-id-clause ...)
syntax
(class100*-asi superclass interfaces instance-id-clause ...)
syntax
(super-init init-arg-expr ...)
syntax
(command-line program-name-expr argv-expr clause ...)
 
clause      = (multi flag-spec ...)
            | (once-each flag-spec ...)
            | (once-any flag-spec ...)
            | (final flag-spec ...)
            | (help-labels string ...)
            | (args arg-formals body-expr ...+)
            | (=> finish-proc-expr arg-help-expr help-proc-expr
                  unknown-proc-expr)
               
flag-spec   = (flags id ... help-str ...+ body-expr ...+)
            | (flags => handler-expr help-expr)
               
flags       = flag-string
            | (flag-string ...+)
               
arg-formals = id
            | (id ...)
            | (id ...+ . id)
procedure
(spawn thunk) -> thread?
  thunk : (-> any)
procedure
(channel) -> channel?
procedure
(channel-recv-evt ch) -> evt?
  ch : channel?
procedure
(channel-send-evt ch v) -> evt?
  ch : channel?
  v : any/c
procedure
(thread-done-evt thd) -> any
  thd : thread?
procedure
(current-time) -> real?
procedure
(time-evt tm) -> evt?
  tm : real?
procedure
(=? n ...+) -> boolean?
  n : number?
procedure
(<? n ...+) -> boolean?
  n : real?
procedure
(>? n ...+) -> boolean?
  n : real?
procedure
(<=? n ...+) -> boolean?
  n : real?
procedure
(>=? n ...+) -> boolean?
  n : real?
procedure
(1+ n) -> number?
  n : number?
procedure
(1- n) -> number?
  n : number?
procedure
(gentmp [base]) -> symbol?
  base : (or/c string? symbol?) = "g"
procedure
(flush-output-port [o]) -> void?
  o : output-port? = (current-output-port)
procedure
(real-time) -> exact-integer?
procedure
(atom? v) -> any
  v : any/c
syntax
(define-structure (name-id field-id ...))
(define-structure (name-id field-id ...)
                  ((init-field-id init-expr) ...))
procedure
(getprop sym property [default]) -> any/c
  sym : symbol?
  property : symbol?
  default : any/c = #f
procedure
(putprop sym property value) -> void?
  sym : symbol?
  property : symbol?
  value : any/c
procedure
(new-cafe [eval-handler]) -> any
  eval-handler : (any/c . -> . any) = #f
syntax
(define/contract id contract-expr init-value-expr)
procedure
(box/c c) -> flat-contract?
  c : flat-contract?
procedure
(vectorof c) -> flat-contract?
  c : flat-contract?
procedure
(vector/c c ...) -> flat-contract?
  c : flat-contract?
syntax
(struct/c struct-id flat-contract-expr ...)
procedure
(build-flat-contract name predicate) -> flat-contract?
  name : symbol?
  predicate : (-> any/c any)
syntax
(-> contract-dom-expr ... any)
(-> contract-dom-expr ... contract-rng-expr)
syntax
(->* (contract-dom-expr ...) ->*rng)
(->* (contract-dom-expr ...) contract-rest-expr ->*rng)
 
->*rng = (contract-rng-expr ...)
       | any
syntax
(opt-> (contract-req-expr ...) (contact-opt-expr ...) any)
(opt-> (contract-req-expr ...) (contact-opt-expr ...) contract-rng-expr)
syntax
(opt->* (contract-req-expr ...) (contact-opt-expr ...) any)
(opt->* (contract-req-expr ...) (contact-opt-expr ...) (contract-rng-expr ...))
syntax
(->d contract-dom-expr ... contract-rng-fun-expr)
syntax
(->d* (contract-dom-expr ...) contract-rng-fun-expr)
(->d* (contract-dom-expr ...) contract-rest-expr contract-rng-fun-expr)
syntax
(->r ([dom-x contract-dom-expr] ...) rng)
(->r ([dom-x contract-dom-expr] ...) rest-x contract-rest-expr rng)
 
rng = any
    | (values contract-expr ...)
    | contract-expr
syntax
(->pp ([dom-x contract-dom-expr] ...) pre-cond-expr any)
(->pp ([dom-x contract-dom-expr] ...)
      pre-cond-expr
      (values [rng-x contract-rng-expr] ...)
      post-cond-expr)
(->pp ([dom-x contract-dom-expr] ...)
      pre-cond-expr
      contract-rng-expr
      rng-x
      post-cond-expr)
syntax
(->pp-rest ([dom-x contract-dom-expr] ...) rest-x rest-contract-expr pre-cond-expr any)
(->pp-rest ([dom-x contract-dom-expr] ...)
           rest-x rest-contract-expr
           pre-cond-expr
           (values [rng-x contract-rng-expr] ...)
           post-cond-expr)
(->pp-rest ([dom-x contract-dom-expr] ...)
           rest-x rest-contract-expr
           pre-cond-expr
           contract-rng-expr
           rng-x
           post-cond-expr)
syntax
(case-> mzlib/contract-arrow-contract-expr ...)
syntax
(object-contract [id mzlib/contract-arrow-contract-expr] ...)
syntax
(begin-lifted expr ...+)
syntax
(begin-with-definitions defn-or-expr ...)
syntax
(define-syntax-set (id ...) defn ...)
syntax
(evcase key-expr (value-expr body-expr ...) ...+)
(evcase key-expr (value-expr body-expr ...) ... [else body-expr ...])
procedure
(identity v) -> any/c
  v : any/c
syntax
(let+ clause body-expr ...+)
 
clause = (val target expr)
       | (rec target expr)
       | (vals (target ...) expr)
       | (recs (target expr) ...)
       | (_ expr ...)
          
target = id
       | (values id ...)
procedure
(loop-until start done? next f) -> void?
  start : any/c
  done? : (any/c . -> . any)
  next : (any/c . -> . any/c)
  f : (any/c . -> . any)
procedure
(namespace-defined? sym) -> boolean?
  sym : symbol?
syntax
(nand expr ...)
syntax
(nor expr ...)
syntax
(opt-lambda formals body ...+)
syntax
(recur id bindings body ...+)
syntax
(rec id value-expr)
(rec (id arg-id ...) expr)
(rec (id arg-id ... . rest-id) expr)
syntax
(this-expression-source-directory)
(this-expression-source-directory datum)
syntax
(this-expression-file-name)
(this-expression-file-name datum)
syntax
(hash-table (quote flag) ... (key-expr val-expr) ...)
procedure
(call-with-input-file* file proc [mode]) -> any
  file : path-string?
  proc : (input-port? -> any)
  mode : (one-of/c 'text 'binary) = 'binary
procedure
(call-with-output-file*  file         
                         proc         
                        [mode         
                         exists]) -> any
  file : path-string?
  proc : (output-port? -> any)
  mode : (one-of/c 'text 'binary) = 'binary
  exists : (one-of/c 'error 'append 'update
                     'replace 'truncate 'truncate/replace)
         = 'error
procedure
(build-relative-path base sub ...) -> (and/c path? relative-path?)
  base : (or/c path-string?
               (one-of/c 'up 'same))
  sub : (or/c (and/c path-string?
                     relative-path?)
              (one-of/c 'up 'same))
procedure
(build-absolute-path base sub ...) -> (and/c path? absolute-path?)
  base : (or/c (and/c path-string?
                      (not/c relative-path?))
               (one-of/c 'up 'same))
  sub : (or/c (and/c path-string?
                     (not/c complete-path?))
              (one-of/c 'up 'same))
syntax
(include path-spec)
 
path-spec = string
          | (build-path elem ...+)
          | (lib file-string collection-string ...)
             
elem      = string
          | up
          | same
syntax
(include-at/relative-to context source path-spec)
syntax
(include-at/relative-to/reader context source path-spec reader-expr)
syntax
(include/reader path-spec reader-expr)
syntax
(lambda/kw kw-formals body ...+)
syntax
(define/kw (head args) body ...+)
 
kw-formals     = id
               | (id ... [#:optional optional-spec ...]
                         [#:key key-spec ...]
                         [rest/mode-spec ...])
               | (id ... . id)
                  
optional-spec  = id
               | (id default-expr)
                  
key-spec       = id
               | (id default-expr)
               | (id keyword default-expr)
                  
rest/mode-spec = #:rest id
               | #:other-keys id
               | #:other-keys+body id
               | #:all-keys id
               | #:body kw-formals
               | #:allow-other-keys
               | #:forbid-other-keys
               | #:allow-duplicate-keys
               | #:forbid-duplicate-keys
               | #:allow-body
               | #:forbid-body
               | #:allow-anything
               | #:forbid-anything
                  
head           = id
               | (head . kw-formals)
procedure
(keyword-get args kw not-found) -> any
  args : (listof (cons/c keyword? any/c))
  kw : keyword?
  not-found : (-> any)
procedure
(first v) -> any/c
  v : pair?
procedure
(second v) -> any/c
  v : (and/c pair? ....)
procedure
(third v) -> any/c
  v : (and/c pair? ....)
procedure
(fourth v) -> any/c
  v : (and/c pair? ....)
procedure
(fifth v) -> any/c
  v : (and/c pair? ....)
procedure
(sixth v) -> any/c
  v : (and/c pair? ....)
procedure
(seventh v) -> any/c
  v : (and/c pair? ....)
procedure
(eighth v) -> any/c
  v : (and/c pair? ....)
procedure
(rest v) -> any/c
  v : pair?
procedure
(last-pair v) -> pair?
  v : pair?
procedure
(merge-sorted-lists lst1 lst2 less-than?) -> list?
  lst1 : list?
  lst2 : lst?
  less-than? : (any/c any/c . -> . any/c)
procedure
(mergesort lst less-than?) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
procedure
(quicksort lst less-than?) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
syntax
(match val-expr clause ...)
 
clause = [pat expr ...+]
       | [pat (=> id) expr ...+]
syntax
(define/match (head args) match*-clause ...)
syntax
(match-lambda clause ...)
syntax
(match-lambda* clause ...)
syntax
(match-let ([pat expr] ...) body ...+)
syntax
(match-let* ([pat expr] ...) body ...+)
syntax
(match-letrec ([pat expr] ...) body ...+)
syntax
(match-define pat expr)
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
(define-match-expander id proc-expr proc-expr proc-expr)
parameter
(match-equality-test) -> (any/c any/c . -> . any)
(match-equality-test comp-proc) -> void?
  comp-proc : (any/c any/c . -> . any)
value
e : real?
procedure
(gethostname) -> string?
procedure
(getpid) -> exact-integer?
procedure
(truncate-file file [n-bytes]) -> void?
  file : path-string?
  n-bytes : exact-nonnegative-integer? = 0
parameter
(abbreviate-cons-as-list) -> boolean?
(abbreviate-cons-as-list abbreviate?) -> void?
  abbreviate? : any/c
parameter
(booleans-as-true/false) -> boolean?
(booleans-as-true/false use-name?) -> void?
  use-name? : any/c
parameter
(use-named/undefined-handler) -> (any/c . -> . any/c)
(use-named/undefined-handler use-handler) -> void?
  use-handler : (any/c . -> . any/c)
parameter
(named/undefined-handler) -> (any/c . -> . any/c)
(named/undefined-handler use-handler) -> void?
  use-handler : (any/c . -> . any/c)
parameter
(add-make-prefix-to-constructor) -> boolean?
(add-make-prefix-to-constructor add-prefix?) -> void?
  add-prefix? : any/c
procedure
(build-share v) -> ....
  v : any/c
parameter
(constructor-style-printing) -> boolean?
(constructor-style-printing use-constructors?) -> void?
  use-constructors? : any/c
parameter
(current-build-share-hook)
 -> (any/c (any/c . -> . void?)
           (any/c . -> . void?) . -> . any)
(current-build-share-hook hook) -> void?
  hook : (any/c (any/c . -> . void?)
                (any/c . -> . void?) . -> . any)
parameter
(current-build-share-name-hook)
 -> (any/c . -> . (or/c symbol? false/c))
(current-build-share-name-hook hook) -> void?
  hook : (any/c . -> . (or/c symbol? false/c))
parameter
(current-print-convert-hook) -> (any/c (any/c . -> . any/c)
                                       (any/c . -> . any/c)
                                       . -> . any/c)
(current-print-convert-hook hook) -> void?
  hook : (any/c (any/c . -> . any/c)
                (any/c . -> . any/c)
                . -> . any/c)
parameter
(current-read-eval-convert-print-prompt) -> string?
(current-read-eval-convert-print-prompt str) -> void?
  str : string?
procedure
(get-shared share-info [cycles-only?])
 -> (list-of (cons/c symbol? any/c))
  share-info : ....
  cycles-only? : any/c = #f
procedure
(install-converting-printer) -> void?
procedure
(print-convert v [cycles-only?]) -> any/c
  v : any/c
  cycles-only? : any/c = (show-sharing)
procedure
(print-convert-expr share-info        
                    v                 
                    unroll-once?) -> any/c
  share-info : ....
  v : any/c
  unroll-once? : any/c
parameter
(quasi-read-style-printing) -> boolean?
(quasi-read-style-printing on?) -> void?
  on? : any/c
parameter
(show-sharing) -> boolean?
(show-sharing show?) -> void?
  show? : any/c
parameter
(whole/fractional-exact-numbers) -> boolean?
(whole/fractional-exact-numbers whole-frac?) -> void?
  whole-frac? : any/c
value
prop:print-converter : property?
procedure
(print-converter? v) -> any
  v : any/c
procedure
(print-converter-proc v)
 -> (any/c (any/c . -> . any/c) . -> . any/c)
  v : print-converter?
value
prop:print-convert-constructor-name : property?
procedure
(print-convert-named-constructor? v) -> any
  v : any/c
procedure
(print-convert-constructor-name v) -> any
  v : print-convert-named-constructor?
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
(define-match-expander id proc-expr proc-expr proc-expr)
procedure
(strip-shell-command-start in) -> void?
  in : input-port?
procedure
(pregexp-match  pattern       
                input         
               [start-pos     
                end-pos       
                output-port]) 
 -> (or/c (listof (or/c (cons (or/c string? bytes?)
                              (or/c string? bytes?))
                        false/c))
          false/c)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
  output-port : (or/c output-port? false/c) = #f
procedure
(pregexp-match-positions  pattern       
                          input         
                         [start-pos     
                          end-pos       
                          output-port]) 
 -> (or/c (listof (or/c (cons exact-nonnegative-integer?
                              exact-nonnegative-integer?)
                        false/c))
          false/c)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
  output-port : (or/c output-port? false/c) = #f
procedure
(pregexp-split  pattern       
                input         
               [start-pos     
                end-pos]) -> (listof (or/c string? bytes?))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
procedure
(pregexp-replace pattern input insert) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 (string? . -> . string?)
                 (bytes? . -> . bytes?))
procedure
(pregexp-replace* pattern input insert) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 (string? . -> . string?)
                 (bytes? . -> . bytes?))
procedure
(restart-mzscheme init-argv             
                  adjust-flag-table     
                  argv                  
                  init-namespace)   -> boolean?
  init-argv : (vectorof string?)
  adjust-flag-table : (any/c . -> . any/c)
  argv : (vectorof string?)
  init-namespace : (-> any)
procedure
(make-evaluator language               
                requires               
                input-program ...) -> (any/c . -> . any)
  language : (or/c module-path?
                   (one-of/c 'r5rs 'beginner 'beginner-abbr
                             'intermediate 'intermediate-lambda 'advanced)
                   (list/c (one-of/c 'special) symbol?)
                   (list/c (one-of/c 'special) symbol?)
                   (cons/c (one-of/c 'begin) list?))
  requires : (or/c (cons/c 'begin list?)
                   (listof (or/c module-path? path?)))
  input-program : any/c
(make-evaluator module-decl) -> (any/c . -> . any)
  module-decl : (or/c syntax? pair?)
procedure
(send-event  receiver-bytes        
             event-class-bytes     
             event-id-bytes        
            [direct-arg-v          
             argument-list])   -> any/c
  receiver-bytes : (lambda (s) (and (bytes? s)
                                    (= 4 (bytes-length s))))
  event-class-bytes : (lambda (s) (and (bytes? s)
                                       (= 4 (bytes-length s))))
  event-id-bytes : (lambda (s) (and (bytes? s)
                                    (= 4 (bytes-length s))))
  direct-arg-v : any/c = (void)
  argument-list : list? = null
syntax
(define-serializable-struct id-maybe-super (field-id ...) maybe-inspector-expr)
syntax
(define-serializable-struct/versions id-maybe-super vers-num (field-id ...)
                                     (other-version-clause ...)
                                     maybe-inspector-expr)
 
id-maybe-super       = id
                     | (id super-id)
                        
maybe-inspector-expr = 
                     | inspector-expr
                        
other-version-clause = (other-vers make-proc-expr
                                   cycle-make-proc-expr)
procedure
(glob->regexp [str                 
               hide-dots?          
               case-sensitive?     
               simple?])       -> (or/c regexp? byte-regexp?)
  str : (or/c string bytes?) = ?
  hide-dots? : any/c = #t
  case-sensitive? : any/c
                  = (eq? (system-path-convention-type)'unix)
  simple? : any/c = #f
procedure
(string-lowercase! str) -> void?
  str : (and/c string? (not/c immutable?))
procedure
(string-uppercase! str) -> void?
  str : (and/c string? (not/c immutable?))
procedure
(eval-string str [err-handler]) -> list?
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
procedure
(expr->string expr) -> string?
  expr : any/c
procedure
(read-from-string str [err-handler]) -> any/c
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
procedure
(read-from-string-all str [err-handler]) -> list?
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
syntax
(copy-struct struct-id struct-expr
             (accessor-id field-expr) ...)
syntax
(define-struct/properties id (field-id ...)
                          ((prop-expr val-expr) ...)
                          maybe-inspector-expr)
 
maybe-inspector-expr = 
                     | expr
syntax
(make-->vector struct-id)
procedure
(consumer-thread f [init]) -> thread? procedure?
  f : procedure?
  init : (-> any) = void
procedure
(run-server  port-no            
             conn-proc          
             conn-timeout       
            [handler            
             listen             
             close              
             accept             
             accept/break]) -> void?
  port-no : (integer-in 1 65535)
  conn-proc : (input-port? output-port? . -> . any)
  conn-timeout : (and/c real? (not/c negative?))
  handler : (exn? . -> . any/c) = void
  listen : ((integer-in 1 65535) (one-of/c 5) (one-of/c #t)
            . -> . listener?)
         = tcp-listen
  close : (listener? . -> . any) = tcp-close
  accept : (listener? . ->* . (input-port? output-port?))
         = tcp-accept
  accept/break : (listener? . ->* . (input-port? output-port?))
               = tcp-accept/enable-break
procedure
(transcript-on filename) -> any
  filename : any/c
procedure
(transcript-off) -> any
syntax
(struct id (field-id ...) omit-decl ...)
 
omit-decl = -type
          | -selectors
          | -setters
          | -constructor
syntax
(struct/ctc id ([field-id contract-expr] ...) omit-decl ...)
 
omit-decl = -type
          | -selectors
          | -setters
          | -constructor
syntax
struct~r
syntax
struct~r/ctc
syntax
struct~s
syntax
struct~s/ctc
