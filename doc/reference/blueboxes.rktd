159211
((3) 0 () 125 ((q quote #%kernel) (q lib "racket/unsafe/ops.rkt") (q lib "racket/private/base.rkt") (q lib "racket/extflonum.rkt") (q lib "racket/private/class-internal.rkt") (q 192660 . 4) (q lib "racket/private/stxcase-scheme.rkt") (q lib "racket/file.rkt") (q lib "racket/control.rkt") (q lib "racket/list.rkt") (q lib "racket/unit.rkt") (q lib "racket/math.rkt") (q lib "racket/contract/private/guts.rkt") (q lib "racket/flonum.rkt") (q 195492 . 4) (q lib "racket/private/more-scheme.rkt") (q lib "racket/set.rkt") (q lib "racket/function.rkt") (q 195842 . 9) (q lib "racket/contract/private/blame.rkt") (q lib "racket/vector.rkt") (q lib "racket/provide-transform.rkt") (q 234537 . 8) (q lib "racket/port.rkt") (q lib "racket/private/letstx-scheme.rkt") (q lib "racket/require-transform.rkt") (q lib "racket/splicing.rkt") (q lib "racket/private/misc.rkt") (q lib "racket/fixnum.rkt") (q lib "racket/private/list.rkt") (q lib "racket/place.rkt") (q lib "racket/dict.rkt") (q lib "racket/syntax.rkt") (q lib "racket/sandbox.rkt") (q 324568 . 5) (q lib "racket/struct-info.rkt") (q lib "racket/contract/private/misc.rkt") (q lib "racket/pretty.rkt") (q lib "racket/match.rkt") (q 369360 . 5) (q lib "racket/contract/base.rkt") (q lib "racket/future.rkt") (q lib "racket/udp.rkt") (q 194441 . 4) (q lib "racket/format.rkt") (q lib "racket/path.rkt") (q 193180 . 4) (q lib "racket/contract/private/prop.rkt") (q lib "racket/stream.rkt") (q 192811 . 6) (q lib "racket/system.rkt") (q lib "racket/tcp.rkt") (q 193317 . 4) (q 193761 . 4) (q 232328 . 7) (q 194159 . 7) (q 368405 . 23) (q lib "racket/trait.rkt") (q lib "racket/date.rkt") (q lib "racket/promise.rkt") (q lib "racket/generic.rkt") (q lib "racket/require.rkt") (q lib "racket/string.rkt") (q 135976 . 3) (q lib "racket/trace.rkt") (q 332323 . 5) (q 264851 . 29) (q lib "racket/generator.rkt") (q 192315 . 5) (q 193924 . 5) (q 176781 . 4) (q lib "racket/private/serialize.rkt") (q lib "racket/contract/private/base.rkt") (q 129010 . 4) (q 192495 . 5) (q 193015 . 5) (q lib "racket/sequence.rkt") (q 192139 . 5) (q 191379 . 4) (q 195359 . 4) (q lib "racket/async-channel.rkt") (q lib "racket/runtime-path.rkt") (q lib "racket/private/qqstx.rkt") (q lib "racket/unit-exptime.rkt") (q 231421 . 19) (q lib "racket/private/map.rkt") (q lib "racket/contract/private/ds.rkt") (q 153727 . 3) (q 191620 . 4) (q 194797 . 4) (q 195201 . 5) (q lib "racket/provide-syntax.rkt") (q lib "racket/bool.rkt") (q lib "racket/contract/region.rkt") (q 194939 . 4) (q lib "racket/class.rkt") (q lib "racket/engine.rkt") (q lib "racket/keyword-transform.rkt") (q 191185 . 6) (q 191773 . 5) (q lib "racket/serialize.rkt") (q lib "racket/contract/private/vector.rkt") (q lib "racket/provide.rkt") (q 191488 . 4) (q lib "racket/contract.rkt") (q 195077 . 4) (q 191953 . 5) (q 193600 . 4) (q 331293 . 6) (q 193464 . 4) (q lib "racket/include.rkt") (q 322947 . 29) (q lib "racket/contract/private/box.rkt") (q 330927 . 5) (q lib "racket/bytes.rkt") (q lib "racket/cmdline.rkt") (q lib "racket/stxparam-exptime.rkt") (q 194571 . 5) (q lib "racket/contract/private/opt.rkt") (q lib "racket/fasl.rkt") (q lib "racket/contract/private/struct-dc.rkt") (q lib "racket/require-syntax.rkt") (q lib "racket/stxparam.rkt") (q lib "racket/performance-hint.rkt") (q lib "racket/contract/parametric.rkt")) () (h ! (equal) ((c def c (c (? . 0) q struct-info)) q (322190 . 3)) ((c def c (c (? . 1) q unsafe-f64vector-ref)) q (384849 . 4)) ((c def c (c (? . 0) q module->namespace)) q (296086 . 3)) ((c def c (c (? . 7) q file->value)) q (341850 . 4)) ((c def c (c (? . 0) q module-compiled-name)) q (304886 . 9)) ((c def c (c (? . 0) q bytes=?)) q (56827 . 4)) ((c def c (c (? . 12) q coerce-chaperone-contracts)) q (174982 . 4)) ((q form ((lib "racket/block.rkt") block)) q (16799 . 2)) ((c def c (c (? . 3) q extflexpt)) q (36910 . 4)) ((c def c (c (? . 0) q prefab-key?)) q (137578 . 3)) ((c def c (c (? . 1) q unsafe-extfl>=)) q (386738 . 4)) ((c def c (c (? . 0) q list)) q (83147 . 3)) ((c def c (c (? . 0) q peek-byte)) q (273123 . 4)) ((c form c (c (? . 2) q define-sequence-syntax)) q (15814 . 8)) ((c def c (c (? . 6) q check-duplicate-identifier)) q (221316 . 3)) ((c form c (c (? . 48) q stream)) q (109132 . 2)) ((c def c (c (? . 0) q string-locale-ci>?)) q (43579 . 4)) ((c def c (c (? . 0) q namespace-module-registry)) q (295999 . 3)) ((c def c (c (? . 0) q current-thread)) q (204543 . 2)) ((c def c (c (? . 2) q make-exn:fail:syntax:unbound)) c (? . 5)) ((c def c (c (? . 0) q impersonate-prompt-tag)) q (312027 . 18)) ((c def c (c (? . 60) q exn:fail:support?)) c (? . 63)) ((c def c (c (? . 11) q sqr)) q (27489 . 3)) ((c def c (c (? . 0) q module-declared?)) q (307252 . 5)) ((c def c (c (? . 0) q make-input-port)) q (247595 . 49)) ((c def c (c (? . 20) q vector-memq)) q (97792 . 4)) ((c def c (c (? . 13) q flvector-set!)) q (30895 . 5)) ((c def c (c (? . 0) q symbol->string)) q (64841 . 3)) ((c def c (c (? . 19) q blame-update)) q (176360 . 5)) ((c def c (c (? . 32) q generate-temporary)) q (239516 . 3)) ((c form c (c (? . 24) q quasiquote)) q (16669 . 2)) ((c def c (c (? . 4) q make-generic)) q (145947 . 4)) ((c def c (c (? . 0) q add1)) q (20411 . 3)) ((c def c (c (? . 0) q srcloc-line)) c (? . 18)) ((c def c (c (? . 1) q unsafe-u16vector-set!)) q (385419 . 5)) ((c def c (c (? . 3) q extfltruncate)) q (36291 . 3)) ((c def c (c (? . 0) q null?)) q (82866 . 3)) ((c def c (c (? . 44) q ~a)) q (45756 . 23)) ((c def c (c (? . 0) q list->vector)) q (94741 . 3)) ((c def c (c (? . 0) q read-language)) q (278535 . 4)) ((c def c (c (? . 21) q export-protect?)) c (? . 22)) ((c def c (c (? . 16) q weak-seteqv)) q (119869 . 3)) ((c def c (c (? . 1) q unsafe-unbox*)) q (383000 . 3)) ((c form c (c (? . 2) q except-in)) q (4265 . 2)) ((c def c (c (? . 0) q char-whitespace?)) q (63931 . 3)) ((c form c (c (? . 4) q set-field!)) q (145475 . 2)) ((c form c (c (? . 2) q for*/vector)) q (14817 . 2)) ((c form c (c (? . 2) q for*)) q (14618 . 2)) ((c def c (c (? . 0) q pregexp)) q (65588 . 3)) ((c def c (c (? . 2) q exn:fail:syntax:unbound)) c (? . 5)) ((c form c (c (? . 6) q syntax-id-rules)) q (217362 . 3)) ((c form c (c (? . 8) q control)) q (200467 . 2)) ((c def c (c (? . 0) q append)) q (83685 . 6)) ((c def c (c (? . 0) q banner)) q (373845 . 2)) ((c def c (c (? . 0) q string-ci>?)) q (42275 . 4)) ((c def c (c (? . 0) q hash?)) q (98376 . 3)) ((c def c (c (? . 6) q syntax-pattern-variable?)) q (217510 . 3)) ((c def c (c (? . 7) q file->lines)) q (342196 . 8)) ((c def c (c (? . 9) q splitf-at-right)) q (90784 . 4)) ((c def c (c (? . 1) q unsafe-fxxor)) q (378916 . 4)) ((c def c (c (? . 42) q udp-multicast-join-group!)) q (358535 . 7)) ((c def c (c (? . 2) q arity-at-least)) c (? . 73)) ((c form c (c (? . 10) q unit)) q (154168 . 22)) ((c def c (c (? . 8) q abort/cc)) q (199904 . 4)) ((c def c (c (? . 0) q struct->vector)) q (136761 . 4)) ((c form c (c (? . 15) q parameterize*)) q (210465 . 3)) ((c def c (c (? . 0) q integer-length)) q (23581 . 3)) ((c form c (c (? . 72) q recursive-contract)) q (182343 . 3)) ((c def c (c (? . 37) q pretty-printing)) q (288318 . 4)) ((c def c (c (? . 0) q error)) q (186298 . 10)) ((c def c (c (? . 41) q current-future)) q (211406 . 2)) ((c def c (c (? . 3) q extfl+)) q (35130 . 4)) ((c def c (c (? . 0) q sleep)) q (205170 . 3)) ((c def c (c (? . 0) q char-numeric?)) q (63666 . 3)) ((c form c (c (? . 2) q all-from-out)) q (5919 . 2)) ((c form c (c (? . 4) q ->dm)) q (148473 . 6)) ((c def c (c (? . 0) q channel-put-evt?)) q (207776 . 3)) ((c def c (c (? . 0) q call-with-semaphore/enable-break)) q (208759 . 9)) ((c def c (c (? . 9) q ninth)) q (89448 . 3)) ((c form c (c (? . 10) q struct/ctc)) q (159277 . 10)) ((c def c (c (? . 0) q bytes->immutable-bytes)) q (55201 . 3)) ((c def c (c (? . 11) q pi)) q (27320 . 2)) ((c def c (c (? . 0) q call-with-values)) q (186095 . 4)) ((c def c (c (? . 0) q string-normalize-nfkc)) q (42985 . 3)) ((c def c (c (? . 2) q make-exn:break:terminate)) c (? . 14)) ((c def c (c (? . 0) q raise-type-error)) q (188487 . 10)) ((c def c (c (? . 2) q make-exn:fail:syntax:missing-module)) c (? . 49)) ((c def c (c (? . 30) q place-channel?)) q (212199 . 3)) ((c form c (c (? . 38) q match-lambda**)) q (184965 . 2)) ((c def c (c (? . 2) q in-range)) q (103748 . 7)) ((c def c (c (? . 2) q gen:custom-write)) q (290046 . 2)) ((c def c (c (? . 0) q module-provide-protected?)) q (296247 . 5)) ((c def c (c (? . 0) q regexp-match)) q (66140 . 17)) ((c form c (c (? . 4) q override-final)) q (141630 . 2)) ((c def c (c (? . 27) q find-executable-path)) q (338177 . 7)) ((c form c (c (? . 10) q define-unit/s)) q (159036 . 6)) ((c def c (c (? . 12) q value-contract)) q (182048 . 3)) ((c def c (c (? . 2) q make-exn:fail:filesystem:exists)) c (? . 107)) ((c def c (c (? . 28) q fx*)) q (32122 . 4)) ((c form c (c (? . 10) q define-unit)) q (156793 . 7)) ((c def c (c (? . 7) q user-write-bit)) q (349959 . 2)) ((c def c (c (? . 13) q make-shared-flvector)) q (31855 . 4)) ((c def c (c (? . 0) q exn:break:terminate?)) c (? . 14)) ((c form c (c (? . 4) q case->m)) q (148422 . 2)) ((c def c (c (? . 35) q struct-info?)) q (137635 . 3)) ((c def c (c (? . 0) q make-pseudo-random-generator)) q (24104 . 2)) ((c def c (c (? . 2) q make-keyword-procedure)) q (128353 . 5)) ((c def c (c (? . 0) q poll-guard-evt)) q (206880 . 3)) ((c def c (c (? . 15) q call-with-break-parameterization)) q (203925 . 5)) ((c def c (c (? . 0) q continuation-mark-set->list*)) q (202323 . 10)) ((c def c (c (? . 23) q dup-output-port)) q (259832 . 4)) ((c def c (c (? . 0) q subprocess-pid)) q (361315 . 3)) ((c def c (c (? . 0) q local-transformer-expand)) q (225040 . 9)) ((c def c (c (? . 0) q mcdr)) q (93802 . 3)) ((c def c (c (? . 0) q sync/timeout/enable-break)) q (206310 . 4)) ((c def c (c (? . 4) q object-interface)) q (152416 . 3)) ((c def c (c (? . 1) q unsafe-fl+)) q (379778 . 4)) ((c def c (c (? . 4) q printable<%>)) q (151871 . 2)) ((c form c (c (? . 16) q for*/mutable-set)) q (121426 . 2)) ((c def c (c (? . 0) q syntax-property-symbol-keys)) q (236378 . 3)) ((c def c (c (? . 0) q thread-suspend)) q (204791 . 3)) ((c def c (c (? . 1) q unsafe-fl<)) q (380228 . 4)) ((c def c (c (? . 7) q other-execute-bit)) q (350183 . 2)) ((c def c (c (? . 17) q arity-includes?)) q (130886 . 4)) ((c def c (c (? . 67) q sequence->repeated-generator)) q (110916 . 3)) ((c def c (c (? . 71) q serialized=?)) q (290654 . 4)) ((c form c (c (? . 40) q ->d)) q (168431 . 34)) ((c def c (c (? . 0) q syntax-local-make-definition-context)) q (226624 . 4)) ((c form c (c (? . 26) q splicing-local)) q (236137 . 2)) ((c def c (c (? . 17) q curryr)) q (130446 . 6)) ((c def c (c (? . 0) q string-locale-ci=?)) q (43369 . 4)) ((c def c (c (? . 2) q procedure->method)) q (127124 . 3)) ((c def c (c (? . 1) q unsafe-set-box!)) q (382922 . 4)) ((c def c (c (? . 0) q real->single-flonum)) q (19609 . 3)) ((c def c (c (? . 0) q srcloc-span)) c (? . 18)) ((c def c (c (? . 19) q raise-blame-error)) q (176463 . 9)) ((c def c (c (? . 0) q logger-name)) q (366837 . 3)) ((c def c (c (? . 0) q round)) q (20783 . 3)) ((c form c (c (? . 36) q any)) q (165730 . 2)) ((c def c (c (? . 0) q pseudo-random-generator?)) q (24175 . 3)) ((c def c (c (? . 0) q exn:fail:filesystem:missing-module?)) c (? . 55)) ((c def c (c (? . 20) q vector-copy)) q (96891 . 5)) ((c def c (c (? . 0) q regexp-match-peek-positions-immediate)) q (73792 . 19)) ((c def c (c (? . 1) q unsafe-flatan)) q (381252 . 3)) ((c def c (c (? . 0) q set-mcdr!)) q (93922 . 4)) ((c form c (c (? . 2) q for-template)) q (6463 . 2)) ((c def c (c (? . 0) q bytes)) q (55147 . 3)) ((c form c (c (? . 2) q for*/fold/derived)) q (15694 . 4)) ((c def c (c (? . 0) q caar)) q (86353 . 3)) ((c def c (c (? . 21) q export-out-sym)) c (? . 22)) ((c def c (c (? . 29) q remv*)) q (84981 . 4)) ((c def c (c (? . 0) q vector-set!)) q (94527 . 5)) ((c def c (c (? . 25) q current-require-module-path)) q (232628 . 4)) ((c def c (c (? . 23) q peeking-input-port)) q (257927 . 9)) ((c form c (c (? . 16) q for*/weak-set)) q (121766 . 2)) ((c def c (c (? . 0) q exact-integer?)) q (18621 . 3)) ((c def c (c (? . 0) q eq?)) q (17604 . 4)) ((c def c (c (? . 1) q unsafe-cdr)) q (382196 . 3)) ((c form c (c (? . 24) q let-syntax)) q (10891 . 2)) ((c def c (c (? . 0) q impersonate-vector)) q (309569 . 13)) ((c def c (c (? . 45) q find-relative-path)) q (336759 . 8)) ((c def c (c (? . 0) q raise-arguments-error)) q (187543 . 10)) ((c def c (c (? . 25) q prop:require-transformer)) q (231298 . 2)) ((c def c (c (? . 9) q in-permutations)) q (92653 . 3)) ((c form c (c (? . 26) q splicing-letrec-syntax)) q (236007 . 2)) ((c def c (c (? . 15) q hash-has-key?)) q (100988 . 4)) ((c def c (c (? . 0) q subprocess-kill)) q (361210 . 4)) ((c def c (c (? . 0) q system-path-convention-type)) q (333585 . 2)) ((c def c (c (? . 0) q make-struct-field-mutator)) q (134098 . 8)) ((c def c (c (? . 0) q keyword?)) q (82501 . 3)) ((c def c (c (? . 1) q unsafe-fl*)) q (379934 . 4)) ((c def c (c (? . 0) q struct:exn:fail)) c (? . 78)) ((c def c (c (? . 0) q eval)) q (297703 . 4)) ((c def c (c (? . 0) q char-ready?)) q (274359 . 3)) ((c def c (c (? . 0) q error-print-context-length)) q (190612 . 4)) ((c def c (c (? . 0) q date-year-day)) c (? . 56)) ((c def c (c (? . 0) q make-thread-cell)) q (209707 . 4)) ((c def c (c (? . 0) q struct?)) q (136864 . 3)) ((c form c (c (? . 8) q control0-at)) q (200985 . 2)) ((c def c (c (? . 0) q read-on-demand-source)) q (280441 . 5)) ((c def c (c (? . 27) q getenv)) q (373099 . 3)) ((c def c (c (? . 0) q read-decimal-as-inexact)) q (279458 . 4)) ((c def c (c (? . 0) q syntax-local-value)) q (227482 . 8)) ((c def c (c (? . 0) q exn:fail:read?)) c (? . 75)) ((c def c (c (? . 0) q current-namespace)) q (293158 . 4)) ((c def c (c (? . 0) q compile-syntax)) q (301115 . 3)) ((c def c (c (? . 7) q make-temporary-file)) q (346072 . 7)) ((c def c (c (? . 2) q in-hash-values)) q (105634 . 3)) ((c def c (c (? . 23) q call-with-output-bytes)) q (253716 . 3)) ((c def c (c (? . 28) q fxvector-copy)) q (34075 . 5)) ((c def c (c (? . 0) q exact-nonnegative-integer?)) q (18681 . 3)) ((c def c (c (? . 29) q foldl)) q (84214 . 5)) ((c def c (c (? . 16) q list->mutable-set)) q (120329 . 4)) ((c def c (c (? . 0) q exn:fail:syntax?)) c (? . 74)) ((c def c (c (? . 3) q extflvector-ref)) q (37676 . 4)) ((c def c (c (? . 23) q read-bytes-line-evt)) q (264702 . 4)) ((c def c (c (? . 16) q mutable-seteqv)) q (119570 . 4)) ((c def c (c (? . 30) q dynamic-place)) q (212259 . 9)) ((c def c (c (? . 4) q object?)) q (151938 . 3)) ((c def c (c (? . 47) q prop:chaperone-contract)) q (177151 . 2)) ((c def c (c (? . 31) q dict-remove)) q (112050 . 4)) ((c def c (c (? . 0) q semaphore-post)) q (207991 . 3)) ((c def c (c (? . 0) q peek-char-or-special)) q (273303 . 5)) ((c def c (c (? . 0) q custodian-require-memory)) q (320745 . 7)) ((c def c (c (? . 2) q exn:fail:contract:continuation)) c (? . 77)) ((c def c (c (? . 2) q regexp-match-peek-positions*)) q (74841 . 17)) ((c def c (c (? . 20) q vector-member)) q (97586 . 4)) ((c def c (c (? . 9) q append*)) q (91379 . 7)) ((c def c (c (? . 0) q expand-once)) q (237416 . 3)) ((c def c (c (? . 1) q unsafe-extflmax)) q (386919 . 4)) ((c def c (c (? . 0) q cddar)) q (87101 . 3)) ((c def c (c (? . 2) q namespace-anchor->namespace)) q (293071 . 3)) ((c def c (c (? . 31) q dict-key-contract)) q (114679 . 3)) ((c def c (c (? . 2) q in-mlist)) q (104069 . 3)) ((c def c (c (? . 27) q path-string?)) q (332531 . 3)) ((c form c (c (? . 24) q =>)) q (11726 . 2)) ((c form c (c (? . 2) q for/or)) q (14131 . 2)) ((c def c (c (? . 33) q exn:fail:sandbox-terminated?)) c (? . 34)) ((c form c (c (? . 2) q define-namespace-anchor)) q (292878 . 2)) ((c def c (c (? . 32) q format-id)) q (238037 . 13)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:version)) c (? . 53)) ((c form c (c (? . 16) q gen:set)) q (122442 . 2)) ((c def c (c (? . 0) q chaperone-prompt-tag)) q (317652 . 18)) ((c def c (c (? . 15) q call-with-exception-handler)) q (189793 . 4)) ((c def c (c (? . 0) q atan)) q (22312 . 6)) ((c def c (c (? . 0) q make-continuation-mark-key)) q (202174 . 4)) ((c def c (c (? . 0) q equal?/recur)) q (17676 . 5)) ((c def c (c (? . 0) q bytes-fill!)) q (56339 . 4)) ((c def c (c (? . 0) q srcloc-position)) c (? . 18)) ((c def c (c (? . 11) q exact-floor)) q (27888 . 3)) ((c def c (c (? . 2) q make-date*)) c (? . 39)) ((c def c (c (? . 0) q prop:exn:srclocs)) q (195629 . 2)) ((c def c (c (? . 16) q set-copy-clear)) q (123343 . 3)) ((c form c (c (? . 4) q get-field)) q (145337 . 2)) ((c def c (c (? . 31) q dict-iter-contract)) q (114809 . 3)) ((c def c (c (? . 0) q arithmetic-shift)) q (23476 . 4)) ((c def c (c (? . 33) q exn:fail:sandbox-terminated-reason)) c (? . 34)) ((c def c (c (? . 19) q blame-add-context)) q (175447 . 9)) ((c def c (c (? . 19) q blame-original?)) q (176147 . 3)) ((c def c (c (? . 28) q fx<)) q (32973 . 4)) ((c def c (c (? . 35) q struct-auto-info?)) q (138099 . 3)) ((c def c (c (? . 0) q current-security-guard)) q (320105 . 4)) ((c form c (c (? . 33) q with-limits)) q (332272 . 2)) ((c def c (c (? . 0) q use-collection-link-paths)) q (390440 . 4)) ((c def c (c (? . 4) q object-method-arity-includes?)) q (153046 . 7)) ((c def c (c (? . 36) q symbols)) q (162257 . 3)) ((c def c (c (? . 23) q merge-input)) q (257603 . 5)) ((c def c (c (? . 37) q tentative-pretty-print-port-cancel)) q (288924 . 3)) ((c def c (c (? . 0) q hash-iterate-key)) q (103144 . 4)) ((c def c (c (? . 31) q make-custom-hash-types)) q (115367 . 24)) ((c def c (c (? . 27) q read-eval-print-loop)) q (300270 . 2)) ((c def c (c (? . 27) q port?)) q (240279 . 3)) ((c def c (c (? . 30) q place-channel)) q (213738 . 2)) ((c def c (c (? . 16) q set-map)) q (124802 . 4)) ((c def c (c (? . 0) q hash-eqv?)) q (98490 . 3)) ((c def c (c (? . 2) q exn:fail:network)) c (? . 43)) ((c def c (c (? . 2) q exn:fail:out-of-memory)) c (? . 89)) ((c def c (c (? . 1) q unsafe-flabs)) q (380090 . 3)) ((c def c (c (? . 0) q shell-execute)) q (361758 . 11)) ((c def c (c (? . 7) q pathlist-closure)) q (345296 . 6)) ((c form c (c (? . 38) q match/derived)) q (185822 . 2)) ((c def c (c (? . 2) q procedure-keywords)) q (128208 . 4)) ((c def c (c (? . 4) q class->interface)) q (152343 . 3)) ((c def c (c (? . 33) q call-with-custodian-shutdown)) c (? . 113)) ((c def c (c (? . 0) q void?)) q (130988 . 3)) ((c def c (c (? . 21) q struct:export)) c (? . 22)) ((c form c (c (? . 2) q define-struct/derived)) q (132316 . 3)) ((c def c (c (? . 0) q log-message)) q (367043 . 7)) ((c def c (c (? . 0) q resolved-module-path?)) q (301853 . 3)) ((c def c (c (? . 20) q vector-take-right)) q (96317 . 4)) ((c def c (c (? . 0) q path<?)) q (333386 . 4)) ((c def c (c (? . 36) q make-none/c)) q (182269 . 3)) ((c def c (c (? . 0) q read-curly-brace-as-paren)) q (278942 . 4)) ((c def c (c (? . 1) q unsafe-fxmin)) q (379618 . 4)) ((c def c (c (? . 0) q file-stream-buffer-mode)) q (241238 . 6)) ((c def c (c (? . 37) q pretty-print)) q (284605 . 5)) ((c form c (c (? . 4) q this%)) q (141217 . 2)) ((c def c (c (? . 62) q string-trim)) q (45360 . 11)) ((c form c (c (? . 61) q filtered-in)) q (9185 . 2)) ((c def c (c (? . 0) q char-upcase)) q (64403 . 3)) ((c form c (c (? . 4) q generic)) q (145779 . 2)) ((c form c (c (? . 30) q place)) q (213225 . 2)) ((c def c (c (? . 19) q blame-swapped?)) q (176209 . 3)) ((c def c (c (? . 23) q make-limited-input-port)) q (257048 . 7)) ((c def c (c (? . 50) q system)) q (362085 . 4)) ((c def c (c (? . 0) q byte-pregexp)) q (65721 . 3)) ((c def c (c (? . 0) q date*-time-zone-name)) c (? . 39)) ((c form c (c (? . 40) q case->)) q (169654 . 9)) ((c def c (c (? . 0) q current-custodian)) q (320465 . 4)) ((c form c (c (? . 2) q combine-out)) q (6128 . 2)) ((c def c (c (? . 25) q import-source-mode)) c (? . 54)) ((c form c (c (? . 110) q include-at/relative-to)) q (237849 . 2)) ((c def c (c (? . 21) q prop:provide-transformer)) q (234283 . 2)) ((c def c (c (? . 37) q pretty-format)) q (285004 . 4)) ((c form c (c (? . 81) q runtime-paths)) q (341528 . 2)) ((c def c (c (? . 41) q processor-count)) q (211583 . 2)) ((c def c (c (? . 42) q udp-receive!*)) q (355797 . 12)) ((c def c (c (? . 1) q unsafe-bytes-length)) q (384287 . 3)) ((c def c (c (? . 0) q srcloc->string)) q (196203 . 3)) ((c form c (c (? . 2) q protect-out)) q (6168 . 2)) ((c def c (c (? . 7) q file->bytes-lines)) q (342549 . 8)) ((c form c (c (? . 4) q augride*)) q (142297 . 2)) ((c def c (c (? . 0) q make-polar)) q (22501 . 4)) ((c def c (c (? . 19) q blame-replace-negative)) q (176270 . 4)) ((c def c (c (? . 33) q sandbox-propagate-breaks)) q (326537 . 4)) ((c def c (c (? . 13) q flround)) q (29144 . 3)) ((c def c (c (? . 20) q vector-count)) q (97268 . 4)) ((c def c (c (? . 0) q read-case-sensitive)) q (278720 . 4)) ((c form c (c (? . 2) q planet)) q (4803 . 5)) ((c def c (c (? . 0) q struct-mutator-procedure?)) q (137190 . 3)) ((c def c (c (? . 0) q box-cas!)) q (98219 . 5)) ((c def c (c (? . 0) q port-count-lines!)) q (241886 . 3)) ((c def c (c (? . 36) q cons/c)) q (163537 . 4)) ((c def c (c (? . 23) q relocate-output-port)) q (260368 . 11)) ((c def c (c (? . 11) q pi.f)) q (27341 . 2)) ((c def c (c (? . 33) q call-in-sandbox-context)) q (331798 . 7)) ((c def c (c (? . 4) q dynamic-get-field)) q (145370 . 4)) ((c def c (c (? . 0) q current-directory)) q (340140 . 4)) ((c def c (c (? . 7) q make-handle-get-preference-locked)) q (348158 . 16)) ((c def c (c (? . 30) q prop:place-location)) q (214162 . 2)) ((c def c (c (? . 3) q extfl<=)) q (35766 . 4)) ((c def c (c (? . 13) q make-flrectangular)) q (30040 . 5)) ((c def c (c (? . 1) q unsafe-flacos)) q (381192 . 3)) ((c form c (c (? . 15) q set!-values)) q (13072 . 2)) ((c def c (c (? . 0) q semaphore-try-wait?)) q (208127 . 3)) ((c def c (c (? . 2) q make-exn:fail:network)) c (? . 43)) ((c def c (c (? . 0) q max)) q (20561 . 3)) ((c def c (c (? . 44) q ~s)) q (48038 . 23)) ((c form c (c (? . 26) q splicing-letrec-values)) q (235950 . 2)) ((c def c (c (? . 1) q unsafe-flimag-part)) q (381802 . 3)) ((c def c (c (? . 0) q eval-jit-enabled)) q (301649 . 4)) ((c def c (c (? . 2) q exn:fail:read:eof)) c (? . 46)) ((c def c (c (? . 2) q prop:sequence)) q (107189 . 2)) ((c def c (c (? . 13) q fl=)) q (28636 . 4)) ((c def c (c (? . 0) q struct:exn:fail:network)) c (? . 43)) ((c def c (c (? . 2) q call-with-output-file)) q (244023 . 11)) ((c def c (c (? . 45) q shrink-path-wrt)) q (337776 . 4)) ((c def c (c (? . 7) q preferences-lock-file-mode)) q (348086 . 2)) ((c form c (c (? . 4) q override-final*)) q (142220 . 2)) ((c def c (c (? . 0) q resolve-path)) q (335062 . 3)) ((c def c (c (? . 33) q sandbox-make-inspector)) q (329649 . 4)) ((c def c (c (? . 0) q pseudo-random-generator-vector?)) q (24879 . 3)) ((c def c (c (? . 59) q promise-running?)) q (196752 . 3)) ((c form c (c (? . 27) q define-syntax-rule)) q (217435 . 2)) ((c def c (c (? . 36) q >=/c)) q (161698 . 3)) ((c def c (c (? . 0) q make-set!-transformer)) q (223630 . 3)) ((c def c (c (? . 45) q some-system-path->string)) q (337553 . 3)) ((c def c (c (? . 2) q make-exn:fail:read:eof)) c (? . 46)) ((c form c (c (? . 4) q overment*)) q (142184 . 2)) ((c def c (c (? . 23) q transplant-output-port)) q (261481 . 17)) ((c def c (c (? . 0) q make-channel)) q (207448 . 2)) ((c def c (c (? . 4) q exn:fail:object?)) c (? . 87)) ((c def c (c (? . 0) q flush-output)) q (241144 . 3)) ((c def c (c (? . 58) q date-display-format)) q (370145 . 18)) ((c def c (c (? . 38) q prop:match-expander)) q (185556 . 2)) ((c def c (c (? . 0) q string)) q (39865 . 3)) ((c def c (c (? . 0) q current-seconds)) q (368190 . 2)) ((c def c (c (? . 51) q tcp-abandon-port)) q (351831 . 3)) ((c def c (c (? . 0) q cdar)) q (86481 . 3)) ((c def c (c (? . 0) q print-struct)) q (282264 . 4)) ((c def c (c (? . 0) q char>=?)) q (62818 . 4)) ((c def c (c (? . 7) q call-with-file-lock/timeout)) q (348925 . 15)) ((c def c (c (? . 0) q syntax-local-make-delta-introducer)) q (230230 . 4)) ((c def c (c (? . 31) q dict-copy)) q (114016 . 3)) ((c def c (c (? . 0) q exact-positive-integer?)) q (18753 . 3)) ((c def c (c (? . 29) q remove)) q (84523 . 5)) ((c def c (c (? . 16) q set-for-each)) q (124913 . 4)) ((c def c (c (? . 47) q prop:flat-contract)) q (177207 . 2)) ((c form c (c (? . 124) q parametric->/c)) q (170027 . 2)) ((c def c (c (? . 1) q unsafe-cons-list)) q (382517 . 4)) ((c def c (c (? . 2) q with-input-from-file)) q (245338 . 7)) ((c form c (c (? . 2) q except-out)) q (6006 . 2)) ((c def c (c (? . 0) q bitwise-bit-set?)) q (23143 . 4)) ((c def c (c (? . 28) q fx=)) q (32901 . 4)) ((c form c (c (? . 24) q letrec-syntaxes)) q (11074 . 2)) ((c form c (c (? . 0) q #%top)) q (9598 . 2)) ((c def c (c (? . 16) q weak-set)) q (119774 . 3)) ((c def c (c (? . 0) q prop:evt)) q (207171 . 2)) ((c def c (c (? . 0) q make-prefab-struct)) q (137342 . 4)) ((c form c (c (? . 10) q unit/s)) q (158916 . 6)) ((c def c (c (? . 31) q dict-iterate-first)) q (112175 . 3)) ((c def c (c (? . 48) q stream?)) q (108795 . 3)) ((c form c (c (? . 4) q with-method)) q (145265 . 3)) ((c def c (c (? . 83) q unit-static-signatures)) q (160096 . 9)) ((c def c (c (? . 23) q call-with-input-string)) q (253960 . 4)) ((c def c (c (? . 80) q async-channel?)) q (209135 . 3)) ((c def c (c (? . 42) q udp?)) q (356742 . 3)) ((c def c (c (? . 0) q identifier-template-binding)) q (222430 . 12)) ((c form c (c (? . 8) q control0)) q (200822 . 2)) ((c def c (c (? . 0) q syntax-local-module-defined-identifiers)) q (230414 . 3)) ((c def c (c (? . 0) q custodian-box?)) q (321377 . 3)) ((c def c (c (? . 0) q make-syntax-delta-introducer)) q (229886 . 9)) ((c def c (c (? . 13) q flabs)) q (28584 . 3)) ((c def c (c (? . 21) q export-orig-stx)) c (? . 22)) ((c form c (c (? . 4) q public-final*)) q (142108 . 2)) ((c def c (c (? . 0) q exn:fail:syntax:missing-module-path)) c (? . 49)) ((c def c (c (? . 19) q blame-negative)) q (175863 . 3)) ((c def c (c (? . 1) q unsafe-extflatan)) q (387638 . 3)) ((c def c (c (? . 0) q cdr)) q (83029 . 3)) ((c def c (c (? . 0) q char-ci>?)) q (63201 . 4)) ((c def c (c (? . 2) q make-exn:fail:contract:arity)) c (? . 88)) ((c def c (c (? . 28) q fxvector)) q (33570 . 3)) ((c def c (c (? . 9) q first)) q (88990 . 3)) ((c def c (c (? . 0) q system-type)) q (373406 . 5)) ((c def c (c (? . 0) q fixnum?)) q (18881 . 3)) ((c def c (c (? . 0) q syntax-line)) q (217750 . 3)) ((c def c (c (? . 0) q struct:exn:fail:read:non-char)) c (? . 52)) ((c def c (c (? . 0) q call/ec)) q (198877 . 3)) ((c def c (c (? . 0) q readtable-mapping)) q (289572 . 9)) ((c form c (c (? . 15) q define-logger)) q (367016 . 2)) ((c def c (c (? . 0) q quotient)) q (20076 . 4)) ((c def c (c (? . 0) q identifier-prune-lexical-context)) q (219804 . 5)) ((c def c (c (? . 23) q peek-bytes-avail!-evt)) c (? . 66)) ((c def c (c (? . 28) q fl->fx)) q (33462 . 3)) ((c def c (c (? . 16) q seteq)) q (119384 . 3)) ((c def c (c (? . 36) q procedure-arity-includes/c)) q (164882 . 3)) ((c def c (c (? . 11) q sgn)) q (27539 . 3)) ((c def c (c (? . 0) q cdaddr)) q (88365 . 3)) ((c def c (c (? . 13) q make-flvector)) q (30581 . 4)) ((c def c (c (? . 19) q exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q byte-regexp?)) q (65414 . 3)) ((c def c (c (? . 0) q print-reader-abbreviations)) q (282742 . 4)) ((c def c (c (? . 50) q system*/exit-code)) q (363063 . 15)) ((c def c (c (? . 0) q current-readtable)) q (280072 . 4)) ((c form c (c (? . 2) q struct-copy)) q (136629 . 5)) ((c form c (c (? . 10) q compound-unit/infer)) q (156950 . 18)) ((c def c (c (? . 1) q unsafe-mcdr)) q (382304 . 3)) ((c def c (c (? . 0) q bytes-copy)) q (55854 . 3)) ((c def c (c (? . 30) q place-channel-put/get)) q (213998 . 4)) ((c def c (c (? . 0) q port-closed?)) q (240468 . 3)) ((c def c (c (? . 1) q unsafe-vector*-ref)) q (383671 . 4)) ((c form c (c (? . 16) q for*/weak-seteqv)) q (121876 . 2)) ((c def c (c (? . 0) q raise-user-error)) q (186513 . 10)) ((c def c (c (? . 36) q >/c)) q (161587 . 3)) ((c def c (c (? . 0) q write-special-evt)) q (277292 . 4)) ((c def c (c (? . 51) q tcp-accept-ready?)) q (351535 . 3)) ((c def c (c (? . 0) q byte-ready?)) q (274267 . 3)) ((c def c (c (? . 47) q build-chaperone-contract-property)) q (178548 . 23)) ((c def c (c (? . 4) q externalizable<%>)) q (151828 . 2)) ((c def c (c (? . 33) q sandbox-make-logger)) q (329917 . 4)) ((c def c (c (? . 2) q exn:fail:read:non-char)) c (? . 52)) ((c def c (c (? . 0) q string-foldcase)) q (42681 . 3)) ((c def c (c (? . 0) q make-struct-type-property)) q (134469 . 13)) ((c def c (c (? . 0) q acos)) q (22261 . 3)) ((c def c (c (? . 0) q angle)) q (22790 . 3)) ((q form ((lib "racket/help.rkt") help)) q (390554 . 6)) ((c def c (c (? . 1) q unsafe-flexp)) q (381371 . 3)) ((c def c (c (? . 0) q filesystem-change-evt-cancel)) q (341151 . 3)) ((c def c (c (? . 0) q executable-yield-handler)) q (204287 . 4)) ((c def c (c (? . 16) q set-subtract)) q (124010 . 4)) ((c form c (c (? . 0) q define-values)) q (12210 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:version?)) c (? . 53)) ((c def c (c (? . 37) q pretty-print-depth)) q (285386 . 4)) ((c def c (c (? . 25) q import-source)) c (? . 54)) ((c def c (c (? . 1) q unsafe-flmin)) q (380546 . 4)) ((c def c (c (? . 4) q object-info)) q (153367 . 3)) ((c def c (c (? . 33) q make-evaluator)) c (? . 111)) ((c def c (c (? . 0) q print-graph)) q (282178 . 4)) ((c def c (c (? . 20) q vector-filter)) q (97076 . 4)) ((c form c (c (? . 15) q log-info)) q (367775 . 3)) ((c def c (c (? . 0) q void)) q (131036 . 3)) ((c def c (c (? . 33) q sandbox-network-guard)) q (328126 . 13)) ((c def c (c (? . 0) q exn:fail:filesystem:missing-module-path)) c (? . 55)) ((c def c (c (? . 3) q extflvector)) q (37385 . 3)) ((c def c (c (? . 0) q hash-iterate-value)) q (103251 . 4)) ((c def c (c (? . 0) q make-bytes)) q (55045 . 4)) ((c def c (c (? . 35) q extract-struct-info)) q (137862 . 3)) ((q form ((lib "racket/shared.rkt") shared)) q (11357 . 2)) ((c def c (c (? . 0) q port-counts-lines?)) q (241952 . 3)) ((c def c (c (? . 0) q date-minute)) c (? . 56)) ((c def c (c (? . 2) q exn:fail:filesystem:errno)) c (? . 69)) ((c def c (c (? . 0) q open-input-string)) q (246510 . 4)) ((c def c (c (? . 0) q port-next-location)) q (242022 . 6)) ((c form c (c (? . 4) q send/keyword-apply)) q (144571 . 4)) ((c def c (c (? . 48) q stream-length)) q (109305 . 3)) ((c form c (c (? . 10) q define-signature-form)) q (159172 . 3)) ((c def c (c (? . 11) q cosh)) q (27719 . 3)) ((c def c (c (? . 0) q bytes->string/latin-1)) q (57721 . 9)) ((c form c (c (? . 2) q define-syntax)) q (12250 . 3)) ((c form c (c (? . 38) q match-let)) q (185003 . 2)) ((c def c (c (? . 0) q struct:exn:fail:contract:variable)) c (? . 68)) ((c def c (c (? . 2) q exn:break)) c (? . 90)) ((c def c (c (? . 0) q string-set!)) q (40205 . 5)) ((c def c (c (? . 51) q tcp-listen)) q (350217 . 9)) ((c form c (c (? . 2) q #%top-interaction)) q (16764 . 2)) ((c form c (c (? . 4) q inspect)) q (141230 . 2)) ((c def c (c (? . 1) q unsafe-fl<=)) q (380386 . 4)) ((c def c (c (? . 76) q sequence-length)) q (107620 . 3)) ((c form c (c (? . 2) q for/vector)) q (13626 . 8)) ((c def c (c (? . 23) q port->list)) q (252511 . 4)) ((c def c (c (? . 57) q trait->mixin)) q (146991 . 3)) ((c def c (c (? . 9) q count)) q (91992 . 4)) ((c def c (c (? . 0) q string-length)) q (40023 . 3)) ((c form c (c (? . 38) q match/values)) q (184278 . 2)) ((c def c (c (? . 3) q extflround)) q (36100 . 3)) ((c def c (c (? . 0) q min)) q (20613 . 3)) ((c def c (c (? . 8) q fcontrol)) q (200318 . 4)) ((c def c (c (? . 0) q rational?)) q (18512 . 3)) ((c def c (c (? . 0) q cddr)) q (86545 . 3)) ((c form c (c (? . 86) q contract-struct)) q (170192 . 2)) ((c def c (c (? . 2) q collection-file-path)) q (388764 . 10)) ((c def c (c (? . 29) q compose)) q (126879 . 3)) ((c form c (c (? . 2) q for*/hasheqv)) q (15027 . 2)) ((c def c (c (? . 16) q list->weak-set)) q (120650 . 4)) ((c def c (c (? . 29) q compose1)) q (126950 . 3)) ((c def c (c (? . 16) q set-union)) q (123588 . 4)) ((c def c (c (? . 50) q string-no-nuls?)) q (366455 . 3)) ((c form c (c (? . 24) q when)) q (12972 . 2)) ((c def c (c (? . 0) q write)) q (280988 . 4)) ((c def c (c (? . 12) q coerce-flat-contracts)) q (175203 . 4)) ((c def c (c (? . 0) q chaperone-evt)) q (316909 . 7)) ((c form c (c (? . 8) q cupto)) q (201397 . 2)) ((c def c (c (? . 57) q trait?)) q (146939 . 3)) ((c def c (c (? . 0) q current-compile)) q (300846 . 5)) ((c def c (c (? . 3) q extflsin)) q (36357 . 3)) ((c def c (c (? . 37) q pretty-print-print-hook)) q (287768 . 5)) ((c form c (c (? . 4) q private)) q (141791 . 2)) ((c def c (c (? . 0) q read-byte-or-special)) q (272817 . 3)) ((c def c (c (? . 0) q thread-send)) q (205611 . 6)) ((c def c (c (? . 16) q set/c)) q (122170 . 6)) ((c def c (c (? . 0) q current-inexact-milliseconds)) q (368238 . 2)) ((c def c (c (? . 0) q hash-iterate-first)) q (102899 . 4)) ((c form c (c (? . 4) q define/public-final)) q (142566 . 3)) ((c def c (c (? . 0) q not)) q (17407 . 3)) ((c def c (c (? . 0) q checked-procedure-check-and-extract)) q (129476 . 11)) ((c def c (c (? . 36) q one-of/c)) q (162191 . 3)) ((c def c (c (? . 0) q exn:missing-module?)) q (196342 . 3)) ((c def c (c (? . 0) q make-parameter)) q (210229 . 4)) ((c form c (c (? . 4) q augment)) q (141674 . 2)) ((c def c (c (? . 0) q regexp?)) q (65307 . 3)) ((c form c (c (? . 38) q struct*)) q (185994 . 2)) ((c def c (c (? . 13) q fltan)) q (29469 . 3)) ((c def c (c (? . 58) q date*->seconds)) q (370931 . 4)) ((c def c (c (? . 2) q procedure-reduce-arity)) q (128089 . 4)) ((c def c (c (? . 31) q dict-empty?)) q (113873 . 3)) ((c def c (c (? . 21) q provide-pre-transformer?)) q (234467 . 3)) ((c def c (c (? . 36) q or/c)) q (161174 . 3)) ((c def c (c (? . 0) q negative?)) q (19215 . 3)) ((c def c (c (? . 31) q make-immutable-custom-hash)) q (118136 . 14)) ((c def c (c (? . 7) q group-read-bit)) q (350023 . 2)) ((c def c (c (? . 2) q make-exn:fail:user)) c (? . 105)) ((c def c (c (? . 59) q promise?)) q (196523 . 3)) ((c def c (c (? . 0) q equal-hash-code)) q (103563 . 3)) ((c form c (c (? . 40) q ->i)) q (166833 . 41)) ((c form c (c (? . 36) q prompt-tag/c)) q (165310 . 8)) ((c def c (c (? . 29) q reverse)) q (83810 . 3)) ((c form c (c (? . 93) q define-struct/contract)) q (171838 . 6)) ((c def c (c (? . 0) q custodian-managed-list)) q (320572 . 4)) ((c def c (c (? . 42) q udp-send/enable-break)) q (354980 . 9)) ((c def c (c (? . 0) q write-bytes-avail*)) q (275867 . 10)) ((c def c (c (? . 37) q pretty-print-exact-as-decimal)) q (285553 . 4)) ((c def c (c (? . 0) q bound-identifier=?)) q (220378 . 6)) ((c def c (c (? . 0) q symbol<?)) q (65209 . 4)) ((c def c (c (? . 0) q environment-variables-set!)) q (372407 . 10)) ((c def c (c (? . 0) q tan)) q (22160 . 3)) ((c def c (c (? . 42) q udp-send)) q (353513 . 6)) ((c def c (c (? . 29) q assoc)) q (85915 . 5)) ((c form c (c (? . 4) q class/derived)) q (143246 . 5)) ((c def c (c (? . 2) q in-directory)) q (105767 . 3)) ((c def c (c (? . 0) q values)) q (186043 . 3)) ((c def c (c (? . 2) q namespace-anchor?)) q (292915 . 3)) ((c def c (c (? . 0) q current-process-milliseconds)) q (369616 . 3)) ((c def c (c (? . 0) q peek-bytes-avail!*)) q (271355 . 14)) ((c form c (c (? . 8) q prompt0-at)) q (200888 . 2)) ((c form c (c (? . 26) q splicing-letrec-syntaxes+values)) q (236098 . 2)) ((c def c (c (? . 47) q contract-property?)) q (180964 . 3)) ((c def c (c (? . 23) q port->bytes)) q (252752 . 3)) ((c form c (c (? . 4) q augment*)) q (142262 . 2)) ((c def c (c (? . 0) q cdaaar)) q (88065 . 3)) ((c def c (c (? . 10) q unit?)) q (159582 . 3)) ((c def c (c (? . 13) q flvector-copy)) q (31026 . 5)) ((c def c (c (? . 1) q unsafe-string-ref)) q (384000 . 5)) ((c form c (c (? . 4) q this)) q (141205 . 2)) ((c def c (c (? . 0) q sync/timeout)) q (206098 . 4)) ((c def c (c (? . 4) q field-names)) q (153289 . 3)) ((c def c (c (? . 0) q vector->list)) q (94680 . 3)) ((c def c (c (? . 41) q fsemaphore-count)) q (212012 . 3)) ((c def c (c (? . 0) q print-boolean-long-form)) q (282632 . 4)) ((c def c (c (? . 0) q link-exists?)) q (338524 . 3)) ((c form c (c (? . 60) q define/generic)) q (136048 . 5)) ((c def c (c (? . 31) q dict-ref)) q (111472 . 6)) ((c def c (c (? . 0) q readtable?)) q (289032 . 3)) ((c def c (c (? . 119) q fasl->s-exp)) q (292593 . 3)) ((c def c (c (? . 1) q unsafe-struct-ref)) q (385549 . 4)) ((c def c (c (? . 0) q prop:custom-print-quotable)) q (290308 . 2)) ((c form c (c (? . 2) q for-syntax)) q (6424 . 2)) ((c def c (c (? . 45) q simple-form-path)) q (337481 . 3)) ((c def c (c (? . 0) q string>?)) q (41789 . 4)) ((c form c (c (? . 4) q public*)) q (142039 . 2)) ((c form c (c (? . 61) q path-up)) q (9231 . 2)) ((c form c (c (? . 48) q stream-cons)) q (109088 . 2)) ((c def c (c (? . 0) q syntax-track-origin)) q (236454 . 7)) ((c def c (c (? . 13) q flexp)) q (29732 . 3)) ((c def c (c (? . 51) q tcp-accept)) q (351332 . 3)) ((c form c (c (? . 15) q log-warning)) q (367699 . 3)) ((c def c (c (? . 17) q normalize-arity)) q (130657 . 4)) ((c def c (c (? . 0) q char-alphabetic?)) q (63394 . 3)) ((c form c (c (? . 4) q override)) q (141554 . 2)) ((c form c (c (? . 61) q subtract-in)) q (9128 . 2)) ((c def c (c (? . 33) q gui?)) q (332067 . 2)) ((c def c (c (? . 12) q contract-first-order-passes?)) q (181546 . 4)) ((c def c (c (? . 0) q current-thread-group)) q (321680 . 4)) ((c def c (c (? . 36) q and/c)) q (161248 . 3)) ((c def c (c (? . 0) q string-locale-upcase)) q (43684 . 3)) ((c def c (c (? . 48) q stream-count)) q (110136 . 4)) ((c form c (c (? . 4) q public)) q (141439 . 2)) ((c def c (c (? . 36) q flat-contract?)) q (181928 . 3)) ((c def c (c (? . 62) q string-append*)) q (43840 . 4)) ((c def c (c (? . 1) q unsafe-flvector-length)) q (384582 . 3)) ((c def c (c (? . 2) q double-flonum?)) q (18987 . 3)) ((q form ((lib "racket/lazy-require.rkt") lazy-require)) q (17229 . 5)) ((c def c (c (? . 0) q load)) q (298543 . 3)) ((c def c (c (? . 0) q current-evt-pseudo-random-generator)) q (207212 . 5)) ((c def c (c (? . 0) q set-port-next-location!)) q (242203 . 9)) ((c def c (c (? . 12) q contract-first-order)) q (181657 . 3)) ((c form c (c (? . 2) q combine-in)) q (4409 . 2)) ((c form c (c (? . 2) q define-for-syntax)) q (12367 . 3)) ((c def c (c (? . 37) q pretty-print-columns)) q (285206 . 5)) ((c form c (c (? . 24) q else)) q (11714 . 2)) ((c def c (c (? . 0) q thread-try-receive)) q (205843 . 2)) ((c def c (c (? . 31) q dict-set*)) q (112734 . 5)) ((c def c (c (? . 47) q make-contract)) q (172483 . 17)) ((c def c (c (? . 64) q current-prefix-in)) q (392359 . 4)) ((c def c (c (? . 31) q dict-ref!)) q (112886 . 5)) ((c def c (c (? . 0) q namespace-unprotect-module)) q (295721 . 7)) ((c def c (c (? . 1) q unsafe-bytes-ref)) q (384358 . 4)) ((c def c (c (? . 28) q fxvector-ref)) q (33835 . 4)) ((c def c (c (? . 11) q infinite?)) q (28245 . 3)) ((c def c (c (? . 0) q internal-definition-context?)) q (226550 . 3)) ((c def c (c (? . 1) q unsafe-extfltan)) q (387432 . 3)) ((c form c (c (? . 2) q #%printing-module-begin)) q (1838 . 2)) ((c form c (c (? . 0) q quote)) q (9512 . 2)) ((c def c (c (? . 19) q blame-positive)) q (175805 . 3)) ((c def c (c (? . 1) q unsafe-flvector-set!)) q (384740 . 5)) ((c def c (c (? . 0) q number->string)) q (24956 . 4)) ((c def c (c (? . 9) q cons?)) q (88887 . 3)) ((c def c (c (? . 20) q vector-drop-right)) q (96535 . 4)) ((c def c (c (? . 20) q vector-memv)) q (97690 . 4)) ((c def c (c (? . 2) q syntax-recertify)) q (220114 . 9)) ((c def c (c (? . 60) q struct:exn:fail:support)) c (? . 63)) ((c def c (c (? . 9) q takef)) q (90037 . 4)) ((c def c (c (? . 1) q unsafe-extflasin)) q (387500 . 3)) ((c def c (c (? . 11) q tanh)) q (27770 . 3)) ((c def c (c (? . 0) q filesystem-root-list)) q (340823 . 2)) ((c def c (c (? . 0) q module-predefined?)) q (308113 . 3)) ((c def c (c (? . 0) q bitwise-ior)) q (22840 . 3)) ((c def c (c (? . 48) q stream-first)) q (108909 . 3)) ((c def c (c (? . 1) q unsafe-bytes-set!)) q (384445 . 5)) ((c def c (c (? . 0) q real?)) q (18461 . 3)) ((c def c (c (? . 48) q stream-rest)) q (108997 . 3)) ((c form c (c (? . 40) q unconstrained-domain->)) q (169840 . 2)) ((c def c (c (? . 0) q prop:checked-procedure)) q (129421 . 2)) ((c def c (c (? . 33) q set-eval-handler)) q (330775 . 4)) ((c form c (c (? . 60) q generic-instance/c)) q (136155 . 4)) ((c def c (c (? . 0) q open-input-bytes)) q (246399 . 4)) ((c form c (c (? . 4) q class-field-accessor)) q (145676 . 2)) ((c def c (c (? . 2) q in-values*-sequence)) q (106459 . 3)) ((c def c (c (? . 9) q sixth)) q (89295 . 3)) ((c def c (c (? . 4) q object->vector)) q (152230 . 4)) ((c def c (c (? . 0) q write-special-avail*)) q (276788 . 4)) ((c form c (c (? . 59) q delay/strict)) q (196861 . 2)) ((c form c (c (? . 8) q shift)) q (200628 . 2)) ((c def c (c (? . 23) q make-input-port/read-to-peek)) q (254508 . 50)) ((c def c (c (? . 0) q thread-running?)) q (205236 . 3)) ((c def c (c (? . 0) q set-phantom-bytes!)) q (378068 . 4)) ((c def c (c (? . 0) q current-load-relative-directory)) q (299691 . 5)) ((c def c (c (? . 33) q sandbox-security-guard)) q (327392 . 5)) ((c def c (c (? . 0) q vector->immutable-vector)) q (94802 . 3)) ((c def c (c (? . 0) q char->integer)) q (62109 . 3)) ((c def c (c (? . 0) q exn:missing-module-accessor)) q (196407 . 4)) ((c form c (c (? . 0) q #%variable-reference)) q (9619 . 4)) ((c def c (c (? . 36) q non-empty-listof)) q (163438 . 3)) ((c def c (c (? . 25) q require-transformer?)) q (231355 . 3)) ((c def c (c (? . 0) q printf)) q (281614 . 4)) ((c form c (c (? . 10) q define-values-for-export)) q (155791 . 2)) ((c def c (c (? . 16) q set-clear)) q (123437 . 3)) ((c def c (c (? . 0) q exn:fail:read:eof?)) c (? . 46)) ((c def c (c (? . 2) q regexp-split)) q (79859 . 15)) ((c def c (c (? . 47) q make-flat-contract)) q (173895 . 17)) ((c def c (c (? . 13) q flsqrt)) q (29784 . 3)) ((c def c (c (? . 0) q raise-argument-error)) q (186761 . 13)) ((c def c (c (? . 9) q permutations)) q (92594 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax:unbound)) c (? . 5)) ((c def c (c (? . 29) q remove*)) q (84778 . 5)) ((c def c (c (? . 64) q current-trace-notify)) q (391099 . 4)) ((c def c (c (? . 42) q udp-multicast-interface)) q (359062 . 3)) ((c def c (c (? . 0) q bitwise-not)) q (23071 . 3)) ((c def c (c (? . 0) q hash-remove!)) q (101813 . 4)) ((c def c (c (? . 0) q make-weak-box)) q (376831 . 3)) ((c def c (c (? . 0) q struct:date)) c (? . 56)) ((c def c (c (? . 51) q tcp-port?)) q (352209 . 3)) ((c def c (c (? . 3) q extflasin)) q (36540 . 3)) ((c def c (c (? . 33) q evaluator-alive?)) q (330212 . 3)) ((c def c (c (? . 41) q would-be-future)) q (211511 . 3)) ((c def c (c (? . 0) q expand-syntax)) q (237352 . 3)) ((q form ((lib "racket/enter.rkt") enter!)) q (390658 . 9)) ((c def c (c (? . 0) q exn-message)) c (? . 98)) ((c def c (c (? . 0) q make-weak-hash)) q (99342 . 3)) ((c def c (c (? . 0) q cddddr)) q (88765 . 3)) ((c def c (c (? . 33) q exn:fail:resource-resource)) c (? . 65)) ((c form c (c (? . 2) q for/fold)) q (14522 . 3)) ((c def c (c (? . 42) q udp-multicast-set-ttl!)) q (359570 . 4)) ((c def c (c (? . 0) q date*-nanosecond)) c (? . 39)) ((c def c (c (? . 33) q exn:fail:resource?)) c (? . 65)) ((c def c (c (? . 0) q simplify-path)) q (335317 . 4)) ((c def c (c (? . 16) q list->weak-seteq)) q (120853 . 3)) ((c def c (c (? . 21) q export)) c (? . 22)) ((c def c (c (? . 0) q numerator)) q (21120 . 3)) ((c form c (c (? . 6) q syntax-case*)) q (216025 . 3)) ((c def c (c (? . 0) q syntax-source-module)) q (218190 . 5)) ((c def c (c (? . 0) q cddaar)) q (88465 . 3)) ((c def c (c (? . 0) q current-output-port)) q (240702 . 4)) ((c def c (c (? . 2) q in-input-port-chars)) q (105053 . 3)) ((c def c (c (? . 13) q flasin)) q (29521 . 3)) ((c def c (c (? . 2) q hash-empty?)) q (102836 . 3)) ((c def c (c (? . 1) q unsafe-extflvector-set!)) q (388307 . 5)) ((c def c (c (? . 0) q abs)) q (20513 . 3)) ((c def c (c (? . 33) q set-eval-limits)) q (330574 . 5)) ((c def c (c (? . 1) q unsafe-fx<)) q (379300 . 4)) ((c def c (c (? . 37) q pretty-print-newline)) q (286856 . 4)) ((c def c (c (? . 23) q peek-bytes!-evt)) c (? . 66)) ((c def c (c (? . 0) q current-library-collection-paths)) q (389443 . 5)) ((c def c (c (? . 12) q build-compound-type-name)) q (174610 . 3)) ((c def c (c (? . 0) q string->symbol)) q (64906 . 3)) ((c def c (c (? . 4) q dynamic-send)) q (144759 . 9)) ((c def c (c (? . 0) q make-environment-variables)) q (372061 . 5)) ((c def c (c (? . 0) q expand-user-path)) q (335245 . 3)) ((c def c (c (? . 16) q proper-subset?)) q (124642 . 4)) ((c form c (c (? . 67) q infinite-generator)) q (110640 . 2)) ((c def c (c (? . 28) q fxrshift)) q (32825 . 4)) ((c def c (c (? . 19) q current-blame-format)) q (176938 . 4)) ((c form c (c (? . 2) q for/hash)) q (13875 . 2)) ((c def c (c (? . 0) q exn:fail:contract:variable-id)) c (? . 68)) ((c def c (c (? . 36) q contract?)) q (181740 . 3)) ((q form ((lib "racket/local.rkt") local)) q (11311 . 2)) ((c def c (c (? . 0) q symbol-unreadable?)) q (64771 . 3)) ((c form c (c (? . 0) q #%expression)) q (9560 . 2)) ((c def c (c (? . 0) q exact->inexact)) q (19547 . 3)) ((c form c (c (? . 10) q define-values/invoke-unit)) q (156321 . 4)) ((c def c (c (? . 2) q make-exn:fail:filesystem:errno)) c (? . 69)) ((c def c (c (? . 3) q make-extflvector)) q (37456 . 4)) ((c def c (c (? . 0) q hash-clear)) q (102142 . 3)) ((c def c (c (? . 31) q in-dict-pairs)) q (114562 . 3)) ((c def c (c (? . 0) q bytes-open-converter)) q (60163 . 4)) ((c def c (c (? . 27) q channel-try-get)) q (207544 . 3)) ((c def c (c (? . 28) q fxnot)) q (32697 . 3)) ((c def c (c (? . 0) q peek-bytes!)) q (270237 . 12)) ((c form c (c (? . 61) q multi-in)) q (9265 . 8)) ((c def c (c (? . 4) q equal<%>)) q (151529 . 2)) ((c def c (c (? . 0) q exn:fail:contract:divide-by-zero?)) c (? . 99)) ((c def c (c (? . 0) q eval-syntax)) q (297840 . 4)) ((c def c (c (? . 0) q hash-set)) q (100363 . 5)) ((c def c (c (? . 0) q prop:set!-transformer)) q (223856 . 2)) ((c form c (c (? . 38) q ==)) q (185955 . 3)) ((c def c (c (? . 0) q exn:fail:read:non-char?)) c (? . 52)) ((c def c (c (? . 13) q flsin)) q (29365 . 3)) ((c form c (c (? . 4) q interface*)) q (138418 . 7)) ((c def c (c (? . 42) q udp-multicast-leave-group!)) q (358797 . 7)) ((c def c (c (? . 13) q fl*)) q (28442 . 4)) ((c def c (c (? . 0) q close-output-port)) q (240397 . 3)) ((c form c (c (? . 57) q trait-exclude)) q (147130 . 2)) ((c def c (c (? . 0) q read-syntax)) q (277642 . 4)) ((c def c (c (? . 0) q vector-copy!)) q (95008 . 11)) ((c form c (c (? . 4) q inherit/super)) q (141881 . 2)) ((c def c (c (? . 51) q tcp-connect/enable-break)) q (350932 . 10)) ((c form c (c (? . 10) q define-signature)) q (154849 . 25)) ((c def c (c (? . 19) q exn:fail:contract:blame-object)) c (? . 70)) ((c def c (c (? . 8) q splitter)) q (201173 . 5)) ((c def c (c (? . 2) q in-hash-pairs)) q (105701 . 3)) ((c def c (c (? . 0) q impersonate-continuation-mark-key)) q (312844 . 13)) ((c def c (c (? . 71) q prop:serializable)) q (291960 . 2)) ((c def c (c (? . 0) q free-template-identifier=?)) q (221105 . 4)) ((c def c (c (? . 20) q vector-map)) q (95947 . 4)) ((c def c (c (? . 0) q time-apply)) q (369776 . 7)) ((c def c (c (? . 19) q struct:exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q sync/enable-break)) q (206243 . 3)) ((c form c (c (? . 123) q define-inline)) q (16922 . 14)) ((c def c (c (? . 2) q sequence?)) q (103693 . 3)) ((c def c (c (? . 1) q unsafe-fxquotient)) q (378443 . 4)) ((c def c (c (? . 9) q drop)) q (89836 . 4)) ((c def c (c (? . 0) q open-output-bytes)) q (246621 . 3)) ((c def c (c (? . 50) q system*)) q (362275 . 13)) ((c form c (c (? . 2) q for/product)) q (14254 . 2)) ((c def c (c (? . 0) q custom-write-accessor)) q (290188 . 4)) ((c form c (c (? . 72) q contract)) q (172210 . 6)) ((c def c (c (? . 0) q identifier-label-binding)) q (222882 . 12)) ((c def c (c (? . 16) q set-clear!)) q (123526 . 3)) ((c def c (c (? . 2) q exn:break:terminate)) c (? . 14)) ((c def c (c (? . 2) q make-arity-at-least)) c (? . 73)) ((c def c (c (? . 2) q in-vector)) q (104131 . 6)) ((c def c (c (? . 16) q set-count)) q (122941 . 3)) ((c def c (c (? . 45) q file-name-from-path)) q (336507 . 3)) ((c def c (c (? . 0) q make-readtable)) q (289088 . 13)) ((c form c (c (? . 2) q #%plain-lambda)) q (10457 . 2)) ((c def c (c (? . 0) q char-utf-8-length)) q (62366 . 3)) ((c def c (c (? . 16) q mutable-set)) q (119468 . 4)) ((c def c (c (? . 3) q extflabs)) q (35462 . 3)) ((c def c (c (? . 0) q chaperone-box)) q (314955 . 12)) ((c form c (c (? . 4) q object/c)) q (148631 . 11)) ((c def c (c (? . 0) q call/cc)) q (198322 . 5)) ((c def c (c (? . 0) q rename-transformer?)) q (223910 . 3)) ((c def c (c (? . 0) q string-downcase)) q (42536 . 3)) ((c def c (c (? . 0) q /)) q (19963 . 6)) ((c def c (c (? . 0) q chaperone-continuation-mark-key)) q (318430 . 13)) ((c def c (c (? . 62) q string-normalize-spaces)) q (44393 . 11)) ((c def c (c (? . 0) q cdadar)) q (88265 . 3)) ((c def c (c (? . 0) q exn:fail:contract:variable?)) c (? . 68)) ((c def c (c (? . 2) q make-exn:fail:syntax)) c (? . 74)) ((c def c (c (? . 0) q raise-range-error)) q (187846 . 17)) ((c form c (c (? . 4) q rename-super)) q (141967 . 2)) ((c def c (c (? . 0) q struct:exn:fail:read)) c (? . 75)) ((c def c (c (? . 2) q gen:equal+hash)) q (17870 . 2)) ((c def c (c (? . 0) q local-expand/capture-lifts)) q (225452 . 11)) ((c def c (c (? . 16) q list->seteqv)) q (120149 . 3)) ((c def c (c (? . 31) q dict-clear!)) q (114133 . 3)) ((c form c (c (? . 0) q if)) q (11404 . 2)) ((c def c (c (? . 20) q vector-append)) q (96142 . 3)) ((c def c (c (? . 0) q syntax-local-lift-module-end-declaration)) q (228413 . 3)) ((c def c (c (? . 42) q udp-bound?)) q (356792 . 3)) ((c def c (c (? . 1) q unsafe-fl->fx)) q (381963 . 3)) ((c def c (c (? . 112) q box/c)) q (163033 . 7)) ((c def c (c (? . 0) q struct:exn:break:hang-up)) c (? . 79)) ((c def c (c (? . 0) q thread-wait)) q (205357 . 3)) ((c def c (c (? . 13) q fl>)) q (28780 . 4)) ((c def c (c (? . 12) q coerce-contracts)) q (174769 . 4)) ((c def c (c (? . 11) q order-of-magnitude)) q (28094 . 3)) ((c def c (c (? . 85) q map)) q (83864 . 4)) ((c form c (c (? . 16) q for*/weak-seteq)) q (121820 . 2)) ((c def c (c (? . 3) q extflvector-set!)) q (37794 . 5)) ((c form c (c (? . 26) q splicing-letrec-syntaxes)) q (236066 . 2)) ((c def c (c (? . 76) q sequence-filter)) q (108599 . 4)) ((c def c (c (? . 0) q bitwise-and)) q (22917 . 3)) ((c form c (c (? . 60) q define-generics)) q (135147 . 21)) ((c def c (c (? . 20) q vector-split-at)) q (96647 . 4)) ((c def c (c (? . 2) q namespace-anchor->empty-namespace)) q (292978 . 3)) ((c def c (c (? . 0) q will-try-execute)) q (377642 . 3)) ((c def c (c (? . 0) q datum->syntax)) q (218552 . 18)) ((c def c (c (? . 0) q continuation-mark-key?)) q (203469 . 3)) ((c def c (c (? . 21) q prop:provide-pre-transformer)) q (234340 . 2)) ((c def c (c (? . 0) q struct:exn:fail:contract:continuation)) c (? . 77)) ((c def c (c (? . 0) q read-bytes-avail!/enable-break)) q (268851 . 10)) ((c def c (c (? . 17) q normalized-arity?)) q (130586 . 3)) ((c def c (c (? . 2) q call-with-input-file*)) q (244533 . 7)) ((c def c (c (? . 0) q vector-length)) q (94341 . 3)) ((c def c (c (? . 0) q module-compiled-submodules)) q (305329 . 13)) ((c def c (c (? . 0) q caadr)) q (86691 . 3)) ((c def c (c (? . 36) q real-in)) q (161834 . 4)) ((c def c (c (? . 0) q prop:rename-transformer)) q (224343 . 2)) ((c def c (c (? . 0) q namespace-undefine-variable!)) q (294335 . 5)) ((c form c (c (? . 2) q for*/list)) q (14677 . 2)) ((c def c (c (? . 0) q syntax->datum)) q (218492 . 3)) ((c def c (c (? . 0) q make-thread-group)) q (321508 . 3)) ((c def c (c (? . 4) q class?)) q (151991 . 3)) ((c form c (c (? . 26) q splicing-let)) q (235880 . 2)) ((c def c (c (? . 2) q exn:fail:syntax:missing-module)) c (? . 49)) ((c def c (c (? . 1) q unsafe-extfl>)) q (386561 . 4)) ((c form c (c (? . 40) q contract-out)) q (170519 . 20)) ((c def c (c (? . 8) q call/prompt)) q (199647 . 7)) ((c def c (c (? . 32) q syntax-local-value/record)) q (239303 . 4)) ((c def c (c (? . 0) q call-with-immediate-continuation-mark)) q (203186 . 7)) ((c def c (c (? . 0) q hash-set!)) q (100092 . 5)) ((c form c (c (? . 4) q pubment*)) q (142073 . 2)) ((c def c (c (? . 16) q set=?)) q (124460 . 4)) ((c def c (c (? . 33) q sandbox-make-code-inspector)) q (329778 . 4)) ((c def c (c (? . 2) q exn:fail:filesystem:version)) c (? . 53)) ((c def c (c (? . 0) q filesystem-change-evt)) q (340945 . 6)) ((c def c (c (? . 0) q exn:fail:contract:continuation?)) c (? . 77)) ((c def c (c (? . 37) q pretty-print-print-line)) q (286977 . 15)) ((c form c (c (? . 2) q define-struct)) q (132154 . 6)) ((c def c (c (? . 0) q chaperone-struct-type)) q (316297 . 15)) ((c def c (c (? . 28) q fxvector?)) q (33515 . 3)) ((c def c (c (? . 42) q udp-send-ready-evt)) q (356942 . 3)) ((c def c (c (? . 27) q load-relative)) q (298601 . 3)) ((c def c (c (? . 1) q unsafe-fx>)) q (379379 . 4)) ((c def c (c (? . 0) q prop:liberal-define-context)) q (230830 . 2)) ((c def c (c (? . 44) q ~.s)) q (53839 . 23)) ((c def c (c (? . 37) q pretty-print-show-inexactness)) q (285823 . 4)) ((c def c (c (? . 17) q arity=?)) q (130792 . 4)) ((c def c (c (? . 0) q mcar)) q (93754 . 3)) ((c def c (c (? . 0) q exn:fail:syntax-exprs)) c (? . 74)) ((c def c (c (? . 0) q peek-char)) q (272943 . 4)) ((c def c (c (? . 23) q make-pipe-with-specials)) q (257315 . 7)) ((c form c (c (? . 4) q abstract)) q (141817 . 2)) ((c form c (c (? . 6) q syntax-case)) q (214655 . 28)) ((c def c (c (? . 2) q exn:fail)) c (? . 78)) ((c def c (c (? . 48) q stream-empty?)) q (108848 . 3)) ((c def c (c (? . 0) q byte?)) q (55295 . 3)) ((c def c (c (? . 9) q remove-duplicates)) q (91597 . 7)) ((c def c (c (? . 42) q udp-send-to/enable-break)) q (354449 . 13)) ((c def c (c (? . 0) q regexp-match?)) q (70783 . 13)) ((c def c (c (? . 0) q current-compiled-file-roots)) q (300094 . 4)) ((c def c (c (? . 0) q bytes-append)) q (56449 . 3)) ((c def c (c (? . 17) q negate)) q (130243 . 3)) ((c def c (c (? . 0) q environment-variables-copy)) q (372992 . 3)) ((c form c (c (? . 2) q module+)) q (1771 . 2)) ((c def c (c (? . 42) q udp-multicast-loopback?)) q (359484 . 3)) ((c def c (c (? . 0) q path?)) q (332480 . 3)) ((c def c (c (? . 0) q datum-intern-literal)) q (219510 . 3)) ((c def c (c (? . 13) q fl->exact-integer)) q (29969 . 3)) ((c def c (c (? . 0) q bytes-length)) q (55346 . 3)) ((c def c (c (? . 27) q displayln)) q (281384 . 4)) ((c def c (c (? . 0) q date-year)) c (? . 56)) ((c def c (c (? . 0) q string-ci<?)) q (42078 . 4)) ((c def c (c (? . 0) q module->language-info)) q (307431 . 6)) ((c def c (c (? . 0) q cddadr)) q (88565 . 3)) ((c def c (c (? . 32) q record-disappeared-uses)) q (239430 . 3)) ((c def c (c (? . 0) q symbol-interned?)) q (64703 . 3)) ((c def c (c (? . 16) q list->mutable-seteqv)) q (120436 . 4)) ((c form c (c (? . 4) q instantiate)) q (144141 . 2)) ((c def c (c (? . 0) q namespace-attach-module)) q (295099 . 7)) ((c def c (c (? . 0) q char-symbolic?)) q (63731 . 3)) ((c def c (c (? . 0) q car)) q (82983 . 3)) ((c form c (c (? . 0) q #%datum)) q (9534 . 2)) ((c def c (c (? . 19) q make-exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 31) q dict-iterate-value)) q (112417 . 4)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:missing-module)) c (? . 55)) ((c def c (c (? . 42) q udp-multicast-set-interface!)) q (359147 . 5)) ((c def c (c (? . 29) q assq)) q (86168 . 4)) ((c def c (c (? . 0) q print-as-expression)) q (282858 . 4)) ((c def c (c (? . 0) q struct-type-make-predicate)) q (322691 . 3)) ((c def c (c (? . 76) q sequence->list)) q (107559 . 3)) ((c def c (c (? . 0) q read-string)) q (267209 . 4)) ((c form c (c (? . 4) q overment)) q (141592 . 2)) ((c def c (c (? . 0) q struct:date*)) c (? . 39)) ((c def c (c (? . 33) q sandbox-memory-limit)) q (328673 . 4)) ((c def c (c (? . 36) q contract-name)) q (181988 . 3)) ((c def c (c (? . 41) q future)) q (211252 . 3)) ((c def c (c (? . 0) q syntax-local-get-shadower)) q (229392 . 3)) ((c def c (c (? . 31) q dict-implements?)) q (111046 . 4)) ((c def c (c (? . 0) q chaperone-vector)) q (314437 . 12)) ((c def c (c (? . 23) q read-string-evt)) q (264333 . 4)) ((c def c (c (? . 0) q read-accept-graph)) q (279360 . 4)) ((c def c (c (? . 31) q dict-update)) q (113380 . 8)) ((c def c (c (? . 12) q prop:contracted)) q (177258 . 2)) ((c def c (c (? . 13) q flcos)) q (29417 . 3)) ((c def c (c (? . 1) q unsafe-extflsqrt)) q (387843 . 3)) ((c form c (c (? . 12) q define/final-prop)) q (181171 . 6)) ((c def c (c (? . 50) q process)) q (363743 . 9)) ((c def c (c (? . 0) q exp)) q (21960 . 3)) ((c def c (c (? . 31) q dict-keys)) q (114193 . 3)) ((c def c (c (? . 23) q dup-input-port)) q (259723 . 4)) ((c def c (c (? . 0) q *)) q (19910 . 3)) ((c form c (c (? . 38) q match-define-values)) q (185324 . 2)) ((c form c (c (? . 10) q define-values/invoke-unit/infer)) q (158206 . 8)) ((c def c (c (? . 28) q fxmin)) q (33263 . 4)) ((c def c (c (? . 0) q prefab-key->struct-type)) q (137439 . 4)) ((c def c (c (? . 27) q path-add-suffix)) q (336155 . 4)) ((c def c (c (? . 0) q cdaadr)) q (88165 . 3)) ((c form c (c (? . 0) q set!)) q (13048 . 2)) ((c def c (c (? . 1) q unsafe-set-box*!)) q (383088 . 4)) ((c def c (c (? . 48) q stream-for-each)) q (109922 . 4)) ((c def c (c (? . 0) q make-phantom-bytes)) q (377977 . 3)) ((c def c (c (? . 0) q syntax-source)) q (217690 . 3)) ((c def c (c (? . 0) q thread?)) q (204491 . 3)) ((c def c (c (? . 0) q byte-pregexp?)) q (65472 . 3)) ((c def c (c (? . 20) q vector-filter-not)) q (97170 . 4)) ((c def c (c (? . 13) q flatan)) q (29627 . 3)) ((c def c (c (? . 23) q with-output-to-bytes)) q (253886 . 3)) ((c def c (c (? . 0) q bytes-ref)) q (55429 . 4)) ((c def c (c (? . 9) q empty)) q (88865 . 2)) ((c def c (c (? . 19) q blame-swap)) q (176092 . 3)) ((c def c (c (? . 27) q guard-evt)) q (206737 . 3)) ((c def c (c (? . 0) q vector-ref)) q (94424 . 4)) ((c def c (c (? . 2) q procedure-arity)) q (127784 . 3)) ((c def c (c (? . 0) q string-titlecase)) q (42608 . 3)) ((c def c (c (? . 0) q bytes?)) q (54993 . 3)) ((c def c (c (? . 0) q call-with-escape-continuation)) q (198778 . 3)) ((c def c (c (? . 0) q char-ci<?)) q (63008 . 4)) ((c def c (c (? . 33) q sandbox-propagate-exceptions)) q (326663 . 4)) ((c def c (c (? . 91) q syntax-local-provide-introduce)) q (12780 . 3)) ((c def c (c (? . 0) q syntax-span)) q (218029 . 3)) ((c def c (c (? . 1) q unsafe-list-tail)) q (382741 . 4)) ((c def c (c (? . 0) q hash-map)) q (102307 . 4)) ((c def c (c (? . 2) q make-exn:break:hang-up)) c (? . 79)) ((c def c (c (? . 16) q set-member?)) q (122457 . 4)) ((c def c (c (? . 80) q async-channel-put-evt)) q (209554 . 4)) ((c form c (c (? . 4) q define/pubment)) q (142486 . 3)) ((c form c (c (? . 17) q thunk*)) q (130215 . 2)) ((c form c (c (? . 57) q trait-exclude-field)) q (147169 . 2)) ((c def c (c (? . 0) q integer?)) q (18567 . 3)) ((c form c (c (? . 3) q for/extflvector)) q (38383 . 2)) ((c def c (c (? . 23) q transplant-input-port)) q (260798 . 17)) ((c def c (c (? . 36) q =/c)) q (161477 . 3)) ((c def c (c (? . 0) q compile-context-preservation-enabled)) q (301513 . 4)) ((c def c (c (? . 0) q make-hasheq)) q (99238 . 3)) ((c def c (c (? . 0) q parameter-procedure=?)) q (210845 . 4)) ((c form c (c (? . 15) q log-fatal)) q (367555 . 3)) ((c def c (c (? . 11) q sinh)) q (27668 . 3)) ((c def c (c (? . 62) q string-join)) q (43947 . 11)) ((c def c (c (? . 45) q normalize-path)) q (337133 . 5)) ((c def c (c (? . 0) q syntax-local-module-required-identifiers)) q (230499 . 7)) ((c def c (c (? . 0) q module-path-index-submodule)) q (304443 . 4)) ((c def c (c (? . 0) q char-title-case?)) q (63598 . 3)) ((c form c (c (? . 120) q struct/c)) q (163796 . 2)) ((c def c (c (? . 36) q flat-contract)) q (165801 . 3)) ((c def c (c (? . 3) q extflacos)) q (36602 . 3)) ((c form c (c (? . 36) q flat-murec-contract)) q (165651 . 2)) ((c def c (c (? . 23) q regexp-match-evt)) q (266048 . 4)) ((c form c (c (? . 31) q gen:dict)) q (111414 . 2)) ((c def c (c (? . 8) q abort)) q (200185 . 3)) ((c def c (c (? . 2) q hash->list)) q (102561 . 3)) ((c def c (c (? . 28) q make-fxvector)) q (33632 . 4)) ((c form c (c (? . 16) q for/weak-seteq)) q (121655 . 2)) ((c form c (c (? . 2) q only-meta-in)) q (4501 . 2)) ((c def c (c (? . 0) q peek-bytes-avail!)) q (270729 . 14)) ((c def c (c (? . 1) q unsafe-vector*-set!)) q (383788 . 5)) ((c def c (c (? . 4) q method-in-interface?)) q (152855 . 4)) ((c def c (c (? . 0) q peek-string)) q (269298 . 5)) ((c def c (c (? . 31) q make-custom-hash)) q (116694 . 14)) ((c form c (c (? . 16) q for/weak-seteqv)) q (121710 . 2)) ((c def c (c (? . 25) q syntax-local-require-certifier)) q (233257 . 4)) ((c def c (c (? . 0) q build-path)) q (333654 . 6)) ((c def c (c (? . 4) q member-name-key?)) q (143720 . 3)) ((c form c (c (? . 82) q unsyntax)) q (217110 . 2)) ((c def c (c (? . 0) q make-directory)) q (340529 . 3)) ((c def c (c (? . 97) q syntax-procedure-alias-property)) q (234917 . 8)) ((c def c (c (? . 0) q bytes->string/utf-8)) q (57115 . 6)) ((c form c (c (? . 0) q begin-for-syntax)) q (12935 . 2)) ((c form c (c (? . 2) q lib)) q (4746 . 2)) ((c form c (c (? . 81) q define-runtime-module-path)) q (341475 . 2)) ((c def c (c (? . 16) q mutable-seteq)) q (119673 . 4)) ((c def c (c (? . 9) q add-between)) q (90883 . 13)) ((c def c (c (? . 0) q make-resolved-module-path)) q (301920 . 7)) ((c def c (c (? . 0) q write-bytes-avail/enable-break)) q (276251 . 10)) ((c def c (c (? . 0) q string<=?)) q (41693 . 4)) ((c def c (c (? . 0) q module->imports)) q (307660 . 6)) ((c def c (c (? . 60) q raise-support-error)) q (135886 . 4)) ((c def c (c (? . 2) q make-do-sequence)) q (106744 . 8)) ((c def c (c (? . 2) q exn:break:hang-up)) c (? . 79)) ((c form c (c (? . 82) q unsyntax-splicing)) q (217134 . 2)) ((c def c (c (? . 2) q hash-keys)) q (102423 . 3)) ((c form c (c (? . 57) q trait-alias)) q (147214 . 2)) ((c def c (c (? . 0) q subprocess)) q (359752 . 31)) ((c form c (c (? . 10) q export)) q (156060 . 2)) ((c def c (c (? . 0) q exn:fail:network?)) c (? . 43)) ((c form c (c (? . 10) q contracted)) q (155842 . 2)) ((c def c (c (? . 115) q parse-command-line)) q (376109 . 15)) ((c def c (c (? . 0) q compile-allow-set!-undefined)) q (301387 . 4)) ((c def c (c (? . 25) q import-req-mode)) c (? . 84)) ((c def c (c (? . 0) q expt)) q (21888 . 4)) ((c def c (c (? . 2) q in-indexed)) q (106110 . 3)) ((c def c (c (? . 1) q unsafe-flreal-part)) q (381701 . 3)) ((c def c (c (? . 33) q sandbox-path-permissions)) q (327584 . 9)) ((c form c (c (? . 2) q #%plain-app)) q (9808 . 3)) ((c def c (c (? . 0) q make-vector)) q (94047 . 4)) ((c form c (c (? . 4) q super-instantiate)) q (144244 . 2)) ((c def c (c (? . 0) q integer-bytes->integer)) q (25330 . 11)) ((c form c (c (? . 2) q for*/hasheq)) q (14961 . 2)) ((c def c (c (? . 76) q empty-sequence)) q (107524 . 2)) ((c def c (c (? . 7) q user-read-bit)) q (349929 . 2)) ((c form c (c (? . 2) q for/fold/derived)) q (15575 . 4)) ((c def c (c (? . 51) q tcp-accept/enable-break)) q (351427 . 3)) ((c def c (c (? . 0) q chaperone-channel)) q (317146 . 12)) ((c def c (c (? . 0) q module-path-index-split)) q (304282 . 5)) ((c form c (c (? . 10) q define-unit/new-import-export)) q (158719 . 6)) ((c def c (c (? . 9) q shuffle)) q (92540 . 3)) ((c def c (c (? . 0) q variable-reference->empty-namespace)) q (296618 . 3)) ((c def c (c (? . 28) q fxmodulo)) q (32350 . 4)) ((c form c (c (? . 38) q match-define)) q (185291 . 2)) ((c def c (c (? . 0) q arity-at-least?)) c (? . 73)) ((c def c (c (? . 83) q signature-members)) q (160442 . 8)) ((c def c (c (? . 3) q extflcos)) q (36418 . 3)) ((c def c (c (? . 41) q fsemaphore-post)) q (211788 . 3)) ((c def c (c (? . 6) q generate-temporaries)) q (219696 . 3)) ((c def c (c (? . 0) q regexp)) q (65531 . 3)) ((c def c (c (? . 13) q ->fl)) q (29911 . 3)) ((c def c (c (? . 0) q syntax?)) q (217580 . 3)) ((c def c (c (? . 0) q dynamic-require-for-syntax)) q (306970 . 7)) ((c def c (c (? . 67) q yield)) q (110589 . 3)) ((c def c (c (? . 9) q split-at)) q (89931 . 4)) ((c def c (c (? . 30) q place-kill)) q (213568 . 3)) ((c def c (c (? . 0) q hash-copy)) q (103360 . 3)) ((c form c (c (? . 4) q private*)) q (142373 . 2)) ((c def c (c (? . 0) q bitwise-xor)) q (22994 . 3)) ((c def c (c (? . 31) q dict-value-contract)) q (114743 . 3)) ((c def c (c (? . 1) q unsafe-struct*-ref)) q (385735 . 4)) ((c form c (c (? . 60) q impersonate-generics)) q (136253 . 4)) ((c def c (c (? . 0) q char-foldcase)) q (64588 . 3)) ((c def c (c (? . 0) q make-impersonator-property)) q (318938 . 5)) ((c def c (c (? . 3) q extfl=)) q (35523 . 4)) ((c def c (c (? . 35) q struct-auto-info-lists)) q (138162 . 4)) ((c def c (c (? . 1) q unsafe-fxrshift)) q (379138 . 4)) ((c def c (c (? . 13) q flvector?)) q (30464 . 3)) ((c def c (c (? . 0) q make-log-receiver)) q (367976 . 5)) ((c def c (c (? . 0) q caadar)) q (87465 . 3)) ((c def c (c (? . 27) q reroot-path)) q (336320 . 4)) ((c def c (c (? . 0) q vector-immutable)) q (94213 . 4)) ((c def c (c (? . 0) q dynamic-wind)) q (199440 . 7)) ((c def c (c (? . 0) q current-milliseconds)) q (369563 . 2)) ((c def c (c (? . 38) q exn:misc:match?)) q (185377 . 3)) ((c def c (c (? . 0) q exit)) q (204116 . 3)) ((c def c (c (? . 2) q make-exn:fail)) c (? . 78)) ((c form c (c (? . 16) q for/mutable-seteqv)) q (121367 . 2)) ((c form c (c (? . 81) q define-runtime-path-list)) q (341329 . 2)) ((c def c (c (? . 58) q julian/scalinger->string)) q (371664 . 3)) ((c def c (c (? . 44) q ~e)) q (49181 . 23)) ((c def c (c (? . 1) q unsafe-fxmax)) q (379698 . 4)) ((c form c (c (? . 81) q runtime-require)) q (341437 . 2)) ((c def c (c (? . 0) q string->number)) q (25068 . 4)) ((c form c (c (? . 28) q for*/fxvector)) q (34572 . 9)) ((c def c (c (? . 0) q variable-reference->module-source)) q (297092 . 4)) ((c form c (c (? . 4) q send)) q (144405 . 3)) ((c def c (c (? . 33) q sandbox-output)) q (325457 . 14)) ((c def c (c (? . 76) q sequence-ormap)) q (108167 . 4)) ((c def c (c (? . 25) q struct:import)) c (? . 84)) ((c def c (c (? . 33) q sandbox-run-submodules)) q (329504 . 4)) ((c def c (c (? . 0) q regexp-max-lookbehind)) q (66019 . 3)) ((c def c (c (? . 0) q current-load/use-compiled)) q (299054 . 13)) ((c def c (c (? . 20) q vector-take)) q (96211 . 4)) ((c def c (c (? . 42) q udp-close)) q (356673 . 3)) ((c def c (c (? . 0) q get-output-bytes)) q (246796 . 9)) ((c def c (c (? . 38) q prop:legacy-match-expander)) q (185608 . 2)) ((c def c (c (? . 0) q peek-bytes-avail!/enable-break)) q (271987 . 14)) ((c def c (c (? . 0) q syntax-local-expand-expression)) q (224950 . 3)) ((c def c (c (? . 0) q variable-reference->namespace)) q (296725 . 3)) ((c def c (c (? . 4) q interface->method-names)) q (152957 . 3)) ((c def c (c (? . 27) q putenv)) q (373204 . 4)) ((c def c (c (? . 64) q current-trace-print-results)) q (391941 . 10)) ((c def c (c (? . 3) q extfl<)) q (35604 . 4)) ((c def c (c (? . 0) q current-logger)) q (366917 . 4)) ((c def c (c (? . 42) q udp-connect!)) q (352784 . 8)) ((c def c (c (? . 0) q terminal-port?)) q (240995 . 3)) ((c form c (c (? . 4) q define/public)) q (142408 . 3)) ((c def c (c (? . 9) q range)) q (92194 . 7)) ((c def c (c (? . 2) q make-exn:fail:read:non-char)) c (? . 52)) ((c def c (c (? . 0) q char=?)) q (62445 . 4)) ((c def c (c (? . 1) q unsafe-extfllog)) q (387707 . 3)) ((c form c (c (? . 67) q generator)) q (110549 . 2)) ((c def c (c (? . 9) q takef-right)) q (90608 . 4)) ((c def c (c (? . 0) q progress-evt?)) q (274451 . 6)) ((c def c (c (? . 2) q in-input-port-bytes)) q (104979 . 3)) ((c form c (c (? . 10) q define-compound-unit/infer)) q (157804 . 5)) ((c def c (c (? . 23) q port->bytes-lines)) q (253069 . 6)) ((c def c (c (? . 0) q caddar)) q (87865 . 3)) ((c def c (c (? . 48) q stream-add-between)) q (110338 . 4)) ((c def c (c (? . 28) q fx+)) q (31980 . 4)) ((c def c (c (? . 0) q call-with-continuation-barrier)) q (199016 . 3)) ((c form c (c (? . 2) q prefix-in)) q (4307 . 2)) ((c def c (c (? . 15) q current-break-parameterization)) q (203853 . 2)) ((c def c (c (? . 0) q hash-placeholder?)) q (93279 . 3)) ((c def c (c (? . 0) q byte-regexp)) q (65653 . 3)) ((c def c (c (? . 32) q current-recorded-disappeared-uses)) q (239040 . 5)) ((c form c (c (? . 0) q let-values)) q (10701 . 2)) ((c def c (c (? . 23) q convert-stream)) q (266185 . 9)) ((c def c (c (? . 0) q string-ci=?)) q (41980 . 4)) ((c def c (c (? . 0) q thread-dead-evt)) q (205417 . 3)) ((c def c (c (? . 2) q sequence-generate)) q (107304 . 3)) ((c def c (c (? . 4) q object%)) q (138604 . 2)) ((c def c (c (? . 0) q cos)) q (22110 . 3)) ((c form c (c (? . 2) q for*/product)) q (15282 . 2)) ((c def c (c (? . 0) q exn:fail:network:errno-errno)) c (? . 117)) ((c def c (c (? . 1) q unsafe-extflvector-ref)) q (388214 . 4)) ((c form c (c (? . 10) q define-unit/contract)) q (159835 . 10)) ((c def c (c (? . 21) q expand-export)) q (233381 . 4)) ((c def c (c (? . 0) q module-path-index?)) q (304117 . 3)) ((c def c (c (? . 85) q ormap)) q (84037 . 4)) ((c def c (c (? . 0) q seconds->date)) q (368290 . 4)) ((c def c (c (? . 0) q current-input-port)) q (240595 . 4)) ((c def c (c (? . 80) q async-channel-put)) q (209462 . 4)) ((c def c (c (? . 0) q read-string!)) q (267519 . 7)) ((c def c (c (? . 80) q async-channel-try-get)) q (209385 . 3)) ((c form c (c (? . 0) q letrec-syntaxes+values)) q (11143 . 4)) ((c form c (c (? . 86) q define-contract-struct)) q (170367 . 2)) ((c def c (c (? . 0) q make-derived-parameter)) q (210540 . 7)) ((c def c (c (? . 23) q copy-port)) q (266466 . 4)) ((c def c (c (? . 0) q quotient/remainder)) q (20235 . 4)) ((c form c (c (? . 57) q trait-rename)) q (147259 . 2)) ((c def c (c (? . 42) q udp-send*)) q (354210 . 6)) ((c def c (c (? . 0) q read-syntax/recursive)) q (278063 . 11)) ((c def c (c (? . 0) q read-square-bracket-as-paren)) q (278822 . 4)) ((c form c (c (? . 4) q override*)) q (142148 . 2)) ((c def c (c (? . 23) q with-input-from-bytes)) q (254288 . 4)) ((c def c (c (? . 0) q integer->integer-bytes)) q (25794 . 14)) ((c def c (c (? . 0) q char-punctuation?)) q (63797 . 3)) ((c def c (c (? . 51) q tcp-addresses)) q (351908 . 7)) ((c form c (c (? . 38) q match)) q (183923 . 6)) ((c def c (c (? . 37) q pretty-print-pre-print-hook)) q (287960 . 5)) ((c def c (c (? . 0) q vector)) q (94157 . 3)) ((c def c (c (? . 31) q dict-for-each)) q (113764 . 4)) ((c def c (c (? . 37) q pretty-print-current-style-table)) q (286162 . 4)) ((c def c (c (? . 0) q integer-sqrt/remainder)) q (21807 . 3)) ((c def c (c (? . 7) q get-preference)) q (346780 . 18)) ((c def c (c (? . 2) q date*)) c (? . 39)) ((c def c (c (? . 0) q system-language+country)) q (373630 . 2)) ((c def c (c (? . 2) q make-base-namespace)) q (292830 . 2)) ((c form c (c (? . 4) q inherit-field)) q (141361 . 2)) ((c def c (c (? . 96) q engine-run)) q (214414 . 4)) ((c def c (c (? . 0) q current-error-port)) q (240815 . 4)) ((c def c (c (? . 9) q eighth)) q (89397 . 3)) ((c def c (c (? . 15) q hash-update)) q (101493 . 9)) ((c def c (c (? . 0) q cleanse-path)) q (335130 . 3)) ((c form c (c (? . 59) q delay/idle)) q (197036 . 8)) ((c form c (c (? . 121) q define-require-syntax)) q (12501 . 3)) ((c def c (c (? . 29) q sort)) q (85060 . 9)) ((c def c (c (? . 0) q print-hash-table)) q (282536 . 4)) ((c def c (c (? . 4) q dynamic-set-field!)) q (145515 . 5)) ((c def c (c (? . 0) q char<?)) q (62538 . 4)) ((c def c (c (? . 0) q bytes-utf-8-index)) q (59712 . 11)) ((c def c (c (? . 76) q sequence-add-between)) q (108705 . 4)) ((c def c (c (? . 29) q assv)) q (86076 . 4)) ((c form c (c (? . 32) q define/with-syntax)) q (238694 . 4)) ((c def c (c (? . 0) q error-value->string-handler)) q (190767 . 9)) ((c def c (c (? . 0) q string->bytes/locale)) q (58329 . 6)) ((c def c (c (? . 0) q syntax-tainted?)) q (236658 . 3)) ((c def c (c (? . 31) q dict-iterate-next)) q (112242 . 4)) ((c def c (c (? . 0) q read-accept-quasiquote)) q (279768 . 4)) ((c def c (c (? . 7) q other-read-bit)) q (350120 . 2)) ((c def c (c (? . 0) q exn:fail?)) c (? . 78)) ((c def c (c (? . 0) q string>=?)) q (41884 . 4)) ((c def c (c (? . 47) q build-contract-property)) q (179832 . 21)) ((c form c (c (? . 2) q for/and)) q (14069 . 2)) ((c def c (c (? . 71) q serialize)) q (290544 . 3)) ((c def c (c (? . 2) q in-hash-keys)) q (105569 . 3)) ((c form c (c (? . 16) q for/weak-set)) q (121602 . 2)) ((c def c (c (? . 13) q fl+)) q (28300 . 4)) ((c def c (c (? . 48) q in-stream)) q (109159 . 3)) ((c def c (c (? . 19) q blame-contract)) q (175921 . 3)) ((c form c (c (? . 38) q match-let*-values)) q (185171 . 2)) ((c def c (c (? . 0) q syntax-property)) q (236195 . 8)) ((c def c (c (? . 0) q -)) q (19797 . 6)) ((c def c (c (? . 0) q thread-cell?)) q (209649 . 3)) ((c def c (c (? . 0) q pair?)) q (82815 . 3)) ((c def c (c (? . 1) q unsafe-extfl+)) q (385957 . 4)) ((c def c (c (? . 0) q collect-garbage)) q (377713 . 2)) ((c def c (c (? . 0) q break-enabled)) q (203709 . 4)) ((c def c (c (? . 15) q hash-ref!)) q (100880 . 5)) ((c def c (c (? . 0) q string-copy!)) q (40601 . 11)) ((c def c (c (? . 0) q regexp-match-positions)) q (68743 . 19)) ((c def c (c (? . 0) q caaaar)) q (87265 . 3)) ((c form c (c (? . 3) q for*/extflvector)) q (38452 . 9)) ((c def c (c (? . 30) q place-channel-get)) q (213908 . 3)) ((c def c (c (? . 23) q reencode-input-port)) q (258362 . 16)) ((c def c (c (? . 0) q current-module-declare-source)) q (303436 . 5)) ((c def c (c (? . 0) q uncaught-exception-handler)) q (189907 . 4)) ((c def c (c (? . 25) q import-src-mod-path)) c (? . 84)) ((c def c (c (? . 3) q extfl->exact-integer)) q (37060 . 3)) ((c def c (c (? . 1) q unsafe-extfl-)) q (386047 . 4)) ((c def c (c (? . 0) q char<=?)) q (62631 . 4)) ((c def c (c (? . 28) q fxand)) q (32478 . 4)) ((c def c (c (? . 16) q set-add!)) q (122627 . 4)) ((c def c (c (? . 0) q bytes->path-element)) q (333066 . 4)) ((c def c (c (? . 11) q exact-round)) q (27821 . 3)) ((c def c (c (? . 11) q nan?)) q (28195 . 3)) ((c def c (c (? . 0) q path-element->string)) q (333230 . 3)) ((c form c (c (? . 36) q flat-rec-contract)) q (165595 . 2)) ((c def c (c (? . 2) q chaperone-procedure)) q (313416 . 11)) ((c def c (c (? . 0) q sqrt)) q (21695 . 3)) ((c def c (c (? . 3) q extflfloor)) q (36163 . 3)) ((c form c (c (? . 16) q for*/mutable-seteqv)) q (121542 . 2)) ((c def c (c (? . 0) q always-evt)) q (206963 . 2)) ((c def c (c (? . 0) q custodian-memory-accounting-available?)) q (320680 . 2)) ((c def c (c (? . 33) q kill-evaluator)) q (330305 . 3)) ((c form c (c (? . 6) q syntax/loc)) q (217167 . 2)) ((c def c (c (? . 0) q call-with-composable-continuation)) q (198510 . 6)) ((c def c (c (? . 95) q implementation?/c)) q (151367 . 3)) ((c def c (c (? . 36) q impersonator-contract?)) q (181860 . 3)) ((c form c (c (? . 0) q quote-syntax)) q (16735 . 2)) ((c def c (c (? . 1) q unsafe-extflacos)) q (387569 . 3)) ((c def c (c (? . 0) q namespace-module-identifier)) q (293461 . 4)) ((c def c (c (? . 29) q foldr)) q (84327 . 5)) ((c def c (c (? . 0) q system-big-endian?)) q (27275 . 2)) ((c def c (c (? . 23) q read-string!-evt)) q (264438 . 4)) ((c def c (c (? . 1) q unsafe-fl>=)) q (380466 . 4)) ((c def c (c (? . 4) q member-name-key-hash-code)) q (143902 . 3)) ((c def c (c (? . 0) q bytes>?)) q (57019 . 4)) ((c def c (c (? . 71) q deserialize)) q (290602 . 3)) ((c def c (c (? . 0) q current-read-interaction)) q (300576 . 4)) ((c def c (c (? . 33) q sandbox-override-collection-paths)) q (327227 . 4)) ((c def c (c (? . 25) q convert-relative-module-path)) q (232809 . 10)) ((c def c (c (? . 4) q exn:fail:object)) c (? . 87)) ((c def c (c (? . 0) q cadadr)) q (87765 . 3)) ((c def c (c (? . 45) q string->some-system-path)) q (337644 . 4)) ((c def c (c (? . 0) q syntax-column)) q (217840 . 3)) ((c def c (c (? . 2) q make-exn:fail:contract:continuation)) c (? . 77)) ((c form c (c (? . 82) q quasisyntax)) q (217079 . 2)) ((c def c (c (? . 0) q make-hasheqv)) q (99132 . 3)) ((c def c (c (? . 0) q cadaar)) q (87665 . 3)) ((c def c (c (? . 0) q struct-type?)) q (136912 . 3)) ((c def c (c (? . 0) q symbol?)) q (64650 . 3)) ((c def c (c (? . 0) q prop:equal+hash)) q (17901 . 2)) ((c def c (c (? . 1) q unsafe-extflceiling)) q (387151 . 3)) ((c def c (c (? . 0) q current-drive)) q (340416 . 2)) ((c def c (c (? . 2) q make-date)) c (? . 56)) ((c def c (c (? . 0) q thread-resume-evt)) q (205480 . 3)) ((c def c (c (? . 0) q primitive?)) q (129878 . 3)) ((c def c (c (? . 0) q make-weak-hasheqv)) q (99464 . 3)) ((c def c (c (? . 0) q abort-current-continuation)) q (197678 . 5)) ((c form c (c (? . 61) q matching-identifiers-in)) q (9073 . 2)) ((c def c (c (? . 20) q vector-map!)) q (96044 . 4)) ((c def c (c (? . 0) q call-with-current-continuation)) q (198060 . 6)) ((c def c (c (? . 0) q make-string)) q (39751 . 4)) ((c form c (c (? . 2) q only-in)) q (4211 . 2)) ((c def c (c (? . 0) q syntax-local-phase-level)) q (228927 . 2)) ((c def c (c (? . 0) q make-placeholder)) q (93051 . 3)) ((c def c (c (? . 71) q serializable?)) q (290485 . 3)) ((c def c (c (? . 23) q reencode-output-port)) q (259046 . 16)) ((c def c (c (? . 0) q exn:fail:syntax:missing-module?)) c (? . 49)) ((c def c (c (? . 0) q exn:fail:read-srclocs)) c (? . 75)) ((c def c (c (? . 0) q read-char-or-special)) q (272691 . 3)) ((c form c (c (? . 6) q syntax-rules)) q (217284 . 3)) ((c def c (c (? . 92) q symbol=?)) q (17998 . 4)) ((c form c (c (? . 122) q syntax-parameterize)) q (235654 . 2)) ((c def c (c (? . 0) q inexact?)) q (19431 . 3)) ((c def c (c (? . 0) q bytes-utf-8-ref)) q (59418 . 7)) ((c def c (c (? . 0) q hash-weak?)) q (98611 . 3)) ((c def c (c (? . 2) q exn:fail:contract:arity)) c (? . 88)) ((c def c (c (? . 1) q unsafe-extfl<=)) q (386649 . 4)) ((c def c (c (? . 0) q inexact->exact)) q (19487 . 3)) ((c def c (c (? . 76) q sequence-count)) q (108493 . 4)) ((c def c (c (? . 0) q make-reader-graph)) q (92933 . 3)) ((c def c (c (? . 0) q make-hasheqv-placeholder)) q (93536 . 3)) ((c def c (c (? . 0) q current-pseudo-random-generator)) q (24245 . 4)) ((c def c (c (? . 0) q make-rectangular)) q (22421 . 4)) ((c form c (c (? . 38) q match-lambda)) q (184894 . 2)) ((c form c (c (? . 2) q rename-out)) q (5959 . 2)) ((c form c (c (? . 24) q let-syntaxes)) q (11008 . 2)) ((c def c (c (? . 28) q fx<=)) q (33117 . 4)) ((c def c (c (? . 4) q make-object)) q (143992 . 4)) ((c def c (c (? . 2) q make-exn:fail:out-of-memory)) c (? . 89)) ((c def c (c (? . 37) q pretty-write)) q (284772 . 4)) ((c def c (c (? . 13) q fl-)) q (28371 . 4)) ((c def c (c (? . 0) q prop:input-port)) q (247498 . 2)) ((c def c (c (? . 0) q make-special-comment)) q (289835 . 3)) ((c def c (c (? . 0) q eqv?)) q (17531 . 4)) ((c def c (c (? . 16) q set-intersect!)) q (123902 . 4)) ((c def c (c (? . 0) q read-accept-box)) q (279056 . 4)) ((c form c (c (? . 2) q for-label)) q (6504 . 2)) ((c def c (c (? . 19) q exn:fail:contract:blame?)) c (? . 70)) ((c def c (c (? . 16) q set-empty?)) q (122876 . 3)) ((c def c (c (? . 2) q make-exn:break)) c (? . 90)) ((c def c (c (? . 0) q make-sibling-inspector)) q (321966 . 3)) ((c def c (c (? . 0) q mcons)) q (93687 . 4)) ((c def c (c (? . 76) q sequence-append)) q (107904 . 3)) ((c def c (c (? . 0) q regexp-match-peek-positions/end)) q (77545 . 22)) ((c def c (c (? . 59) q force)) q (196630 . 3)) ((c def c (c (? . 0) q syntax-local-lift-context)) q (228364 . 2)) ((c def c (c (? . 0) q string->path)) q (332656 . 3)) ((c form c (c (? . 38) q define-match-expander)) q (185460 . 3)) ((c def c (c (? . 0) q string-locale-downcase)) q (43761 . 3)) ((c def c (c (? . 47) q flat-contract-property?)) q (181102 . 3)) ((c def c (c (? . 16) q list->seteq)) q (120240 . 3)) ((c def c (c (? . 0) q parameterization?)) q (211189 . 3)) ((c def c (c (? . 31) q dict-set!)) q (111665 . 5)) ((c def c (c (? . 1) q unsafe-extflmin)) q (386827 . 4)) ((c form c (c (? . 24) q cond)) q (11449 . 7)) ((c def c (c (? . 101) q vector/c)) q (162656 . 8)) ((c form c (c (? . 6) q quote-syntax/prune)) q (217252 . 2)) ((c def c (c (? . 27) q normal-case-path)) q (335492 . 3)) ((c form c (c (? . 16) q define-custom-set-types)) q (125079 . 12)) ((c def c (c (? . 42) q udp-send-to)) q (353060 . 13)) ((c def c (c (? . 62) q string-split)) q (45024 . 9)) ((c form c (c (? . 24) q unless)) q (13009 . 2)) ((c def c (c (? . 48) q stream-ormap)) q (109822 . 4)) ((c def c (c (? . 0) q compiled-expression?)) q (301193 . 3)) ((c def c (c (? . 0) q hash-count)) q (102756 . 3)) ((c def c (c (? . 0) q +)) q (19744 . 3)) ((c def c (c (? . 25) q import-source?)) c (? . 54)) ((c def c (c (? . 9) q make-list)) q (89649 . 4)) ((c form c (c (? . 57) q trait-rename-field)) q (147305 . 2)) ((c def c (c (? . 0) q delete-file)) q (338595 . 3)) ((c def c (c (? . 2) q in-naturals)) q (103920 . 3)) ((q def ((lib "racket/contract/private/hash.rkt") hash/c)) q (164981 . 9)) ((c def c (c (? . 0) q remainder)) q (20155 . 4)) ((c form c (c (? . 8) q control-at)) q (200548 . 2)) ((c def c (c (? . 33) q sandbox-make-namespace)) q (327064 . 2)) ((c form c (c (? . 0) q #%declare)) q (1923 . 4)) ((c def c (c (? . 1) q unsafe-mcar)) q (382249 . 3)) ((c form c (c (? . 2) q for*/lists)) q (14741 . 2)) ((c def c (c (? . 27) q path-list-string->path-list)) q (337964 . 6)) ((c def c (c (? . 0) q placeholder-get)) q (93212 . 3)) ((c def c (c (? . 0) q caddr)) q (86855 . 3)) ((c def c (c (? . 0) q identifier-binding-symbol)) q (223331 . 6)) ((c def c (c (? . 0) q regexp-match-peek-immediate)) q (73131 . 15)) ((c def c (c (? . 31) q in-dict-keys)) q (114430 . 3)) ((c form c (c (? . 91) q define-provide-syntax)) q (12681 . 3)) ((c def c (c (? . 0) q resolved-module-path-name)) q (302264 . 8)) ((c def c (c (? . 0) q struct:exn:fail:unsupported)) c (? . 94)) ((c def c (c (? . 0) q string-utf-8-length)) q (58937 . 5)) ((c def c (c (? . 23) q eof-evt)) q (263863 . 3)) ((c form c (c (? . 4) q send-generic)) q (145825 . 3)) ((c def c (c (? . 16) q set-eqv?)) q (118943 . 3)) ((c def c (c (? . 0) q syntax-local-lift-values-expression)) q (228223 . 5)) ((c def c (c (? . 0) q current-library-collection-links)) q (389650 . 11)) ((c form c (c (? . 4) q augment-final)) q (141748 . 2)) ((c def c (c (? . 0) q string-fill!)) q (41033 . 4)) ((c def c (c (? . 0) q pipe-content-length)) q (247399 . 3)) ((c def c (c (? . 36) q continuation-mark-key/c)) q (165507 . 3)) ((c def c (c (? . 92) q boolean=?)) q (18075 . 4)) ((c form c (c (? . 81) q define-runtime-path)) q (341243 . 2)) ((c def c (c (? . 0) q make-immutable-hasheq)) q (99965 . 4)) ((c def c (c (? . 0) q sync)) q (206044 . 3)) ((c def c (c (? . 0) q evt?)) q (205994 . 3)) ((c def c (c (? . 0) q cdadr)) q (87019 . 3)) ((c def c (c (? . 0) q exit-handler)) q (204170 . 4)) ((c def c (c (? . 27) q load-relative-extension)) q (298977 . 3)) ((c def c (c (? . 4) q make-exn:fail:object)) c (? . 87)) ((c def c (c (? . 0) q make-continuation-prompt-tag)) q (197829 . 4)) ((c def c (c (? . 3) q extfllog)) q (36726 . 3)) ((c def c (c (? . 1) q unsafe-s16vector-set!)) q (385174 . 5)) ((c def c (c (? . 0) q port-file-identity)) q (246302 . 3)) ((c def c (c (? . 58) q date->julian/scalinger)) q (371584 . 3)) ((c def c (c (? . 0) q impersonator-property-accessor-procedure?)) q (319221 . 3)) ((c def c (c (? . 0) q continuation?)) q (199311 . 3)) ((c def c (c (? . 0) q exn:fail:contract?)) c (? . 103)) ((c def c (c (? . 2) q regexp-quote)) q (65791 . 7)) ((c def c (c (? . 16) q set-symmetric-difference)) q (124223 . 4)) ((c def c (c (? . 7) q make-lock-file-name)) q (349700 . 6)) ((c def c (c (? . 0) q port-display-handler)) q (283881 . 6)) ((c def c (c (? . 0) q namespace-symbol->identifier)) q (293259 . 3)) ((c form c (c (? . 64) q trace)) q (391049 . 2)) ((c def c (c (? . 0) q syntax-local-lift-expression)) q (228140 . 3)) ((c def c (c (? . 2) q exn:fail:read)) c (? . 75)) ((c def c (c (? . 28) q fxior)) q (32551 . 4)) ((c def c (c (? . 0) q vector-set-performance-stats!)) q (374235 . 5)) ((c def c (c (? . 0) q make-weak-hasheq)) q (99587 . 3)) ((c def c (c (? . 2) q in-parallel)) q (106315 . 3)) ((c def c (c (? . 37) q pretty-print-post-print-hook)) q (288138 . 5)) ((c form c (c (? . 4) q super)) q (143380 . 3)) ((c def c (c (? . 80) q make-async-channel)) q (209195 . 3)) ((c form c (c (? . 2) q for)) q (13110 . 16)) ((c def c (c (? . 2) q impersonate-procedure)) q (308571 . 11)) ((c def c (c (? . 17) q identity)) q (130084 . 3)) ((c def c (c (? . 0) q port-writes-special?)) q (277485 . 3)) ((c form c (c (? . 2) q all-defined-out)) q (5894 . 2)) ((c def c (c (? . 0) q current-write-relative-directory)) q (283156 . 11)) ((c def c (c (? . 0) q current-command-line-arguments)) q (373898 . 4)) ((c form c (c (? . 59) q delay/sync)) q (196895 . 2)) ((c def c (c (? . 16) q seteqv)) q (119298 . 3)) ((c def c (c (? . 0) q syntax-local-lift-provide)) q (228676 . 3)) ((c def c (c (? . 1) q unsafe-flround)) q (380706 . 3)) ((c form c (c (? . 4) q augment-final*)) q (142332 . 2)) ((c form c (c (? . 4) q define-member-name)) q (143587 . 2)) ((c def c (c (? . 0) q raise)) q (186210 . 4)) ((c def c (c (? . 0) q make-hash-placeholder)) q (93342 . 3)) ((c def c (c (? . 0) q make-syntax-introducer)) q (229819 . 2)) ((c def c (c (? . 1) q unsafe-fxior)) q (378836 . 4)) ((c form c (c (? . 93) q with-contract)) q (171228 . 12)) ((c def c (c (? . 31) q prop:dict)) q (111430 . 2)) ((c form c (c (? . 10) q define-unit-from-context)) q (158483 . 2)) ((c def c (c (? . 30) q place-break)) q (213622 . 4)) ((c form c (c (? . 2) q for/list)) q (13563 . 2)) ((c def c (c (? . 42) q udp-open-socket)) q (352264 . 5)) ((c def c (c (? . 0) q date?)) c (? . 56)) ((c def c (c (? . 0) q cons)) q (82917 . 4)) ((c def c (c (? . 0) q port-writes-atomic?)) q (277409 . 3)) ((c form c (c (? . 2) q file)) q (4781 . 2)) ((c def c (c (? . 9) q flatten)) q (91547 . 3)) ((c def c (c (? . 23) q with-input-from-string)) q (254190 . 4)) ((c def c (c (? . 0) q exn:fail:unsupported?)) c (? . 94)) ((c def c (c (? . 47) q chaperone-contract-property?)) q (181028 . 3)) ((c def c (c (? . 0) q write-bytes-avail-evt)) q (276912 . 9)) ((c def c (c (? . 0) q bytes-copy!)) q (55915 . 11)) ((c def c (c (? . 0) q custodian-limit-memory)) q (321003 . 7)) ((c def c (c (? . 28) q fx>)) q (33045 . 4)) ((c def c (c (? . 0) q directory-exists?)) q (340453 . 3)) ((c def c (c (? . 0) q namespace-set-variable-value!)) q (293989 . 9)) ((c def c (c (? . 51) q tcp-accept-evt)) q (351753 . 3)) ((c def c (c (? . 13) q flexpt)) q (29837 . 4)) ((c def c (c (? . 1) q unsafe-fx+)) q (378209 . 4)) ((c def c (c (? . 29) q remq*)) q (84902 . 4)) ((c def c (c (? . 0) q namespace?)) q (292671 . 3)) ((c def c (c (? . 19) q blame-source)) q (176034 . 3)) ((c form c (c (? . 4) q super-make-object)) q (144219 . 2)) ((c def c (c (? . 2) q hash-values)) q (102491 . 3)) ((c def c (c (? . 0) q load-extension)) q (298909 . 3)) ((c def c (c (? . 0) q print-box)) q (282352 . 4)) ((c def c (c (? . 36) q string-len/c)) q (162053 . 3)) ((c form c (c (? . 2) q local-require)) q (5062 . 2)) ((c form c (c (? . 2) q struct-field-index)) q (132116 . 2)) ((c def c (c (? . 3) q extflonum?)) q (35027 . 3)) ((c def c (c (? . 3) q extfl->exact)) q (37196 . 3)) ((c def c (c (? . 0) q char-ci=?)) q (62912 . 4)) ((c def c (c (? . 0) q thread-cell-values?)) q (210164 . 3)) ((c def c (c (? . 12) q coerce-contract)) q (174684 . 4)) ((c def c (c (? . 0) q inspector?)) q (321801 . 3)) ((c def c (c (? . 2) q hash-copy-clear)) q (102243 . 3)) ((c def c (c (? . 37) q pretty-print-handler)) q (285143 . 3)) ((c def c (c (? . 95) q make-mixin-contract)) q (151183 . 3)) ((c def c (c (? . 2) q open-input-file)) q (242685 . 4)) ((c form c (c (? . 0) q define-syntaxes)) q (12325 . 2)) ((c def c (c (? . 0) q find-system-path)) q (337897 . 3)) ((c def c (c (? . 0) q port-read-handler)) q (280629 . 10)) ((c def c (c (? . 0) q current-subprocess-custodian-mode)) q (361468 . 5)) ((c def c (c (? . 0) q =)) q (21329 . 4)) ((c form c (c (? . 4) q field)) q (141329 . 2)) ((c form c (c (? . 15) q let/cc)) q (198954 . 2)) ((c form c (c (? . 4) q define-serializable-class*)) q (151563 . 4)) ((c def c (c (? . 0) q exact?)) q (19377 . 3)) ((c def c (c (? . 0) q log-max-level)) q (367440 . 4)) ((c def c (c (? . 0) q string-locale<?)) q (43165 . 4)) ((c def c (c (? . 0) q procedure?)) q (126677 . 3)) ((c def c (c (? . 0) q thread-dead?)) q (205298 . 3)) ((c def c (c (? . 96) q engine)) q (214275 . 3)) ((c def c (c (? . 2) q make-base-empty-namespace)) q (292776 . 2)) ((c form c (c (? . 26) q splicing-let-syntax)) q (235980 . 2)) ((c def c (c (? . 9) q drop-right)) q (90395 . 4)) ((c def c (c (? . 0) q namespace-attach-module-declaration)) q (295392 . 7)) ((c def c (c (? . 0) q struct:exn:fail:contract:non-fixnum-result)) c (? . 106)) ((c def c (c (? . 0) q integer->char)) q (62180 . 5)) ((c def c (c (? . 41) q futures-enabled?)) q (211363 . 2)) ((c form c (c (? . 4) q class-field-mutator)) q (145728 . 2)) ((c def c (c (? . 4) q class-info)) q (153456 . 10)) ((c form c (c (? . 4) q define/augride)) q (142994 . 3)) ((c def c (c (? . 16) q set-intersect)) q (123795 . 4)) ((c def c (c (? . 7) q file->bytes)) q (341708 . 4)) ((c def c (c (? . 76) q sequence-andmap)) q (108062 . 4)) ((c def c (c (? . 25) q import)) c (? . 84)) ((c def c (c (? . 25) q import-mode)) c (? . 84)) ((c def c (c (? . 0) q cadr)) q (86417 . 3)) ((c def c (c (? . 36) q parameter/c)) q (164782 . 4)) ((c def c (c (? . 48) q stream-append)) q (109575 . 3)) ((c form c (c (? . 59) q lazy)) q (196604 . 2)) ((c def c (c (? . 0) q struct-constructor-procedure?)) q (136970 . 3)) ((c def c (c (? . 0) q struct:exn:fail:out-of-memory)) c (? . 89)) ((c def c (c (? . 0) q truncate)) q (21034 . 3)) ((c def c (c (? . 0) q make-rename-transformer)) q (223975 . 6)) ((c form c (c (? . 0) q #%stratified-body)) q (16833 . 2)) ((c def c (c (? . 41) q touch)) q (211315 . 3)) ((c def c (c (? . 4) q struct:exn:fail:object)) c (? . 87)) ((c def c (c (? . 28) q fxabs)) q (32426 . 3)) ((c def c (c (? . 2) q make-exn:fail:filesystem:missing-module)) c (? . 55)) ((c def c (c (? . 33) q get-user-custodian)) q (330482 . 3)) ((c def c (c (? . 16) q set-remove)) q (122706 . 4)) ((c def c (c (? . 31) q dict->list)) q (114311 . 3)) ((c def c (c (? . 23) q call-with-input-bytes)) q (254075 . 4)) ((c def c (c (? . 3) q extfl>)) q (35685 . 4)) ((c def c (c (? . 0) q prefab-struct-key)) q (137261 . 3)) ((c def c (c (? . 97) q syntax-procedure-converted-arguments-property)) q (235257 . 8)) ((c def c (c (? . 2) q regexp-try-match)) q (67965 . 17)) ((c form c (c (? . 8) q prompt)) q (200439 . 2)) ((c def c (c (? . 9) q splitf-at)) q (90201 . 4)) ((c form c (c (? . 81) q define-runtime-paths)) q (341282 . 2)) ((c def c (c (? . 0) q make-inspector)) q (321857 . 3)) ((c def c (c (? . 80) q async-channel-get)) q (209312 . 3)) ((c form c (c (? . 38) q match*/derived)) q (185884 . 2)) ((c form c (c (? . 10) q unit/new-import-export)) q (158538 . 6)) ((c def c (c (? . 4) q interface?)) q (152043 . 3)) ((c form c (c (? . 16) q for/mutable-seteq)) q (121309 . 2)) ((c def c (c (? . 0) q complex?)) q (18407 . 3)) ((c def c (c (? . 0) q current-locale)) q (240041 . 4)) ((c def c (c (? . 0) q string-ci<=?)) q (42176 . 4)) ((c form c (c (? . 2) q define)) q (11917 . 14)) ((c def c (c (? . 0) q exn-continuation-marks)) c (? . 98)) ((c def c (c (? . 13) q fltruncate)) q (29308 . 3)) ((c def c (c (? . 23) q read-bytes-evt)) q (263920 . 4)) ((c def c (c (? . 0) q string->immutable-string)) q (39927 . 3)) ((c def c (c (? . 0) q char-ci<=?)) q (63104 . 4)) ((c def c (c (? . 116) q make-parameter-rename-transformer)) q (235794 . 3)) ((c def c (c (? . 0) q explode-path)) q (335840 . 4)) ((c def c (c (? . 11) q exact-truncate)) q (28024 . 3)) ((c form c (c (? . 0) q case-lambda)) q (10327 . 6)) ((c def c (c (? . 3) q extfl*)) q (35296 . 4)) ((c def c (c (? . 31) q in-dict-values)) q (114495 . 3)) ((c def c (c (? . 0) q version)) q (373791 . 2)) ((c def c (c (? . 36) q flat-named-contract)) q (160800 . 7)) ((c def c (c (? . 1) q unsafe-extfl/)) q (386227 . 4)) ((c form c (c (? . 16) q for/set)) q (120952 . 2)) ((c def c (c (? . 9) q seventh)) q (89345 . 3)) ((c def c (c (? . 0) q system-library-subpath)) q (373679 . 3)) ((c def c (c (? . 16) q set-symmetric-difference!)) q (124341 . 4)) ((c def c (c (? . 1) q unsafe-extfl->fx)) q (388071 . 3)) ((c def c (c (? . 31) q dict-count)) q (113936 . 3)) ((c def c (c (? . 0) q file-exists?)) q (338453 . 3)) ((c form c (c (? . 4) q member-name-key)) q (143629 . 2)) ((c def c (c (? . 0) q current-module-declare-name)) q (303262 . 5)) ((c def c (c (? . 0) q prop:arity-string)) q (129371 . 2)) ((c def c (c (? . 0) q print-pair-curly-braces)) q (281860 . 4)) ((c def c (c (? . 0) q module-path-index-resolve)) q (304181 . 3)) ((c def c (c (? . 0) q sub1)) q (20462 . 3)) ((c def c (c (? . 42) q udp-bind!)) q (352482 . 9)) ((c form c (c (? . 16) q for/seteqv)) q (121050 . 2)) ((c def c (c (? . 0) q impersonator-prop:application-mark)) q (319308 . 2)) ((c def c (c (? . 3) q in-extflvector)) q (38137 . 6)) ((c form c (c (? . 67) q in-generator)) q (110680 . 5)) ((c form c (c (? . 4) q define/private)) q (143166 . 3)) ((c def c (c (? . 4) q member-name-key=?)) q (143782 . 4)) ((c def c (c (? . 13) q flvector)) q (30519 . 3)) ((c def c (c (? . 32) q wrong-syntax)) q (238912 . 5)) ((c def c (c (? . 2) q exn:fail:contract:divide-by-zero)) c (? . 99)) ((c def c (c (? . 0) q real-part)) q (22599 . 3)) ((c def c (c (? . 31) q dict-values)) q (114251 . 3)) ((c def c (c (? . 4) q instanceof/c)) q (148922 . 3)) ((c def c (c (? . 1) q unsafe-fxlshift)) q (379055 . 4)) ((c form c (c (? . 13) q for*/flvector)) q (31523 . 9)) ((c def c (c (? . 0) q logger?)) q (366576 . 3)) ((c def c (c (? . 9) q dropf-right)) q (90696 . 4)) ((c def c (c (? . 25) q struct:import-source)) c (? . 54)) ((c def c (c (? . 0) q open-output-string)) q (246708 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax:missing-module)) c (? . 49)) ((c def c (c (? . 2) q keyword-apply)) q (127364 . 13)) ((c def c (c (? . 0) q variable-reference->phase)) q (297239 . 3)) ((c def c (c (? . 0) q modulo)) q (20334 . 4)) ((c def c (c (? . 0) q list-tail)) q (83585 . 4)) ((c form c (c (? . 100) q serializable-struct/versions)) q (291179 . 7)) ((c def c (c (? . 0) q port-commit-peeked)) q (274061 . 6)) ((c def c (c (? . 13) q flvector-length)) q (30699 . 3)) ((c def c (c (? . 0) q environment-variables-ref)) q (372223 . 5)) ((c def c (c (? . 2) q exn:fail:syntax)) c (? . 74)) ((c def c (c (? . 1) q unsafe-extflexp)) q (387775 . 3)) ((c def c (c (? . 0) q exn:fail:syntax:unbound?)) c (? . 5)) ((c def c (c (? . 9) q tenth)) q (89498 . 3)) ((c def c (c (? . 0) q current-print)) q (300735 . 4)) ((c def c (c (? . 0) q struct:exn:break:terminate)) c (? . 14)) ((c def c (c (? . 25) q import-src-sym)) c (? . 84)) ((c def c (c (? . 9) q split-at-right)) q (90496 . 4)) ((c def c (c (? . 16) q set-eq?)) q (118997 . 3)) ((c def c (c (? . 12) q has-contract?)) q (182117 . 3)) ((c def c (c (? . 2) q make-srcloc)) c (? . 18)) ((c def c (c (? . 31) q dict-mutable?)) q (111218 . 3)) ((c form c (c (? . 118) q define-opt/c)) q (182522 . 2)) ((c def c (c (? . 0) q internal-definition-context-seal)) q (227072 . 3)) ((c def c (c (? . 21) q export?)) c (? . 22)) ((c def c (c (? . 47) q prop:contract)) q (177105 . 2)) ((c def c (c (? . 31) q dict-can-remove-keys?)) q (111277 . 3)) ((c def c (c (? . 0) q continuation-mark-set-first)) q (202764 . 10)) ((c form c (c (? . 10) q define-unit-binding)) q (157956 . 6)) ((c def c (c (? . 9) q fifth)) q (89245 . 3)) ((c def c (c (? . 0) q regexp-match/end)) q (75876 . 20)) ((c def c (c (? . 0) q alarm-evt)) q (207052 . 3)) ((c def c (c (? . 29) q remv)) q (84708 . 4)) ((c def c (c (? . 23) q filter-read-input-port)) q (262172 . 27)) ((c def c (c (? . 31) q dict-remove!)) q (111936 . 4)) ((c def c (c (? . 21) q export-mode)) c (? . 22)) ((c def c (c (? . 33) q sandbox-namespace-specs)) q (326797 . 6)) ((c def c (c (? . 32) q internal-definition-context-apply)) q (239608 . 5)) ((c form c (c (? . 4) q send/apply)) q (144505 . 2)) ((c form c (c (? . 10) q extends)) q (156217 . 2)) ((c def c (c (? . 0) q path-for-some-system?)) q (332589 . 3)) ((c def c (c (? . 9) q filter-not)) q (92441 . 4)) ((c def c (c (? . 0) q exn:fail:filesystem:errno-errno)) c (? . 69)) ((c def c (c (? . 76) q sequence-for-each)) q (108271 . 4)) ((c def c (c (? . 0) q unbox)) q (98065 . 3)) ((c def c (c (? . 31) q dict?)) q (110995 . 3)) ((c form c (c (? . 24) q let/ec)) q (198985 . 2)) ((c def c (c (? . 0) q box-immutable)) q (97989 . 3)) ((c def c (c (? . 0) q date-hour)) c (? . 56)) ((c def c (c (? . 0) q chaperone-struct)) q (313767 . 16)) ((c def c (c (? . 0) q string<?)) q (41598 . 4)) ((c def c (c (? . 64) q current-prefix-out)) q (392464 . 4)) ((c def c (c (? . 0) q set!-transformer-procedure)) q (223733 . 4)) ((c def c (c (? . 16) q set-add)) q (122542 . 4)) ((c def c (c (? . 0) q log)) q (22010 . 3)) ((c def c (c (? . 0) q expand-to-top-form)) q (237567 . 3)) ((c def c (c (? . 1) q unsafe-list-ref)) q (382617 . 4)) ((c def c (c (? . 16) q set?)) q (119050 . 3)) ((c def c (c (? . 0) q read)) q (277562 . 3)) ((c def c (c (? . 0) q syntax-local-transforming-module-provides?)) q (230345 . 2)) ((c def c (c (? . 12) q contract-continuation-mark-key)) q (182565 . 2)) ((c def c (c (? . 0) q print-vector-length)) q (282434 . 4)) ((c def c (c (? . 0) q compiled-module-expression?)) q (304813 . 3)) ((c def c (c (? . 0) q current-load-extension)) q (298729 . 5)) ((c def c (c (? . 1) q unsafe-fl=)) q (380149 . 4)) ((c def c (c (? . 0) q procedure-struct-type?)) q (129195 . 3)) ((c def c (c (? . 0) q port-progress-evt)) q (273831 . 4)) ((c def c (c (? . 16) q list->weak-seteqv)) q (120751 . 4)) ((c form c (c (? . 95) q object-contract)) q (149011 . 51)) ((c def c (c (? . 0) q chaperone-hash)) q (315389 . 20)) ((c def c (c (? . 0) q relative-path?)) q (334511 . 3)) ((c def c (c (? . 0) q file-or-directory-modify-seconds)) q (338908 . 8)) ((c def c (c (? . 1) q unsafe-struct-set!)) q (385630 . 5)) ((c form c (c (? . 0) q unquote-splicing)) q (16711 . 2)) ((c def c (c (? . 0) q read-bytes)) q (267365 . 4)) ((c def c (c (? . 2) q in-bytes-lines)) q (105315 . 5)) ((c def c (c (? . 25) q import-source-mod-path-stx)) c (? . 54)) ((c form c (c (? . 59) q delay/thread)) q (196927 . 5)) ((c def c (c (? . 0) q current-module-name-resolver)) q (302661 . 19)) ((c def c (c (? . 31) q make-weak-custom-hash)) q (117405 . 14)) ((c def c (c (? . 0) q variable-reference-constant?)) q (296520 . 3)) ((c def c (c (? . 0) q vector?)) q (93994 . 3)) ((c def c (c (? . 0) q caaddr)) q (87565 . 3)) ((c def c (c (? . 35) q struct:struct-info)) q (137954 . 2)) ((c def c (c (? . 0) q expand-syntax-once)) q (237498 . 3)) ((c def c (c (? . 0) q environment-variables?)) q (371762 . 3)) ((c def c (c (? . 0) q namespace-base-phase)) q (293342 . 3)) ((c def c (c (? . 0) q mpair?)) q (93635 . 3)) ((c def c (c (? . 0) q caaadr)) q (87365 . 3)) ((c def c (c (? . 2) q procedure-rename)) q (127022 . 4)) ((c def c (c (? . 2) q memq)) q (85658 . 4)) ((c form c (c (? . 15) q parameterize-break)) q (203799 . 2)) ((c def c (c (? . 2) q in-list)) q (104013 . 3)) ((c def c (c (? . 7) q group-write-bit)) q (350054 . 2)) ((c def c (c (? . 0) q current-inspector)) q (322083 . 4)) ((c def c (c (? . 0) q vector->pseudo-random-generator)) q (24550 . 4)) ((c def c (c (? . 95) q mixin-contract)) q (151148 . 2)) ((c def c (c (? . 0) q dynamic-require)) q (306691 . 7)) ((c form c (c (? . 10) q compound-unit)) q (156437 . 12)) ((c form c (c (? . 0) q letrec-values)) q (10826 . 2)) ((c form c (c (? . 2) q #%app)) q (9743 . 2)) ((c def c (c (? . 29) q filter)) q (84440 . 4)) ((c def c (c (? . 4) q generate-member-key)) q (143666 . 2)) ((c def c (c (? . 0) q subprocess-status)) q (361051 . 4)) ((c def c (c (? . 0) q identifier-binding)) q (221423 . 14)) ((c def c (c (? . 0) q struct-accessor-procedure?)) q (137118 . 3)) ((c def c (c (? . 36) q printable/c)) q (162154 . 2)) ((c def c (c (? . 4) q implementation?)) q (152668 . 4)) ((c def c (c (? . 0) q struct-predicate-procedure?)) q (137045 . 3)) ((c form c (c (? . 102) q filtered-out)) q (9465 . 2)) ((c def c (c (? . 0) q number?)) q (18354 . 3)) ((c form c (c (? . 16) q for*/mutable-seteq)) q (121483 . 2)) ((c def c (c (? . 0) q raise-mismatch-error)) q (188772 . 8)) ((c def c (c (? . 0) q current-environment-variables)) q (371830 . 4)) ((c form c (c (? . 38) q match*)) q (184082 . 6)) ((c def c (c (? . 0) q even?)) q (19270 . 3)) ((c def c (c (? . 0) q call-in-nested-thread)) q (204661 . 4)) ((c def c (c (? . 7) q put-preferences)) q (347751 . 9)) ((c def c (c (? . 29) q build-vector)) q (95642 . 4)) ((c def c (c (? . 30) q place-channel-put)) q (213800 . 4)) ((c form c (c (? . 2) q prefix-out)) q (6059 . 2)) ((c def c (c (? . 95) q subclass?/c)) q (151457 . 3)) ((c def c (c (? . 0) q namespace-variable-value)) q (293614 . 9)) ((c def c (c (? . 0) q impersonator?)) q (308219 . 3)) ((c def c (c (? . 0) q floating-point-bytes->real)) q (26364 . 9)) ((c def c (c (? . 44) q ~v)) q (46895 . 23)) ((c def c (c (? . 62) q string-replace)) q (44850 . 6)) ((c def c (c (? . 45) q path-only)) q (337357 . 3)) ((c def c (c (? . 32) q format-symbol)) q (238548 . 4)) ((c def c (c (? . 33) q get-output)) c (? . 108)) ((c def c (c (? . 20) q vector-argmin)) q (97386 . 4)) ((c def c (c (? . 0) q make-shared-bytes)) q (56657 . 4)) ((c def c (c (? . 0) q syntax-local-context)) q (228825 . 3)) ((c def c (c (? . 27) q find-library-collection-links)) q (388663 . 3)) ((c form c (c (? . 100) q serializable-struct)) q (290915 . 3)) ((c def c (c (? . 28) q in-fxvector)) q (34266 . 6)) ((c def c (c (? . 1) q unsafe-vector*-length)) q (383570 . 3)) ((c def c (c (? . 4) q object=?)) q (152153 . 4)) ((c def c (c (? . 0) q impersonator-property?)) q (319153 . 3)) ((c def c (c (? . 0) q char-downcase)) q (64463 . 3)) ((c form c (c (? . 4) q class/c)) q (147357 . 27)) ((c def c (c (? . 0) q current-module-path-for-load)) q (303648 . 11)) ((c def c (c (? . 42) q udp-receive!)) q (355337 . 11)) ((c def c (c (? . 0) q string->list)) q (41220 . 3)) ((c def c (c (? . 0) q current-get-interaction-input-port)) q (300421 . 4)) ((c def c (c (? . 0) q string->bytes/utf-8)) q (58083 . 6)) ((c def c (c (? . 37) q pretty-print-remap-stylable)) q (286676 . 5)) ((c form c (c (? . 2) q for/hasheqv)) q (14003 . 2)) ((c def c (c (? . 21) q make-provide-transformer)) q (233639 . 10)) ((c def c (c (? . 104) q make-proj-contract)) q (182629 . 15)) ((c def c (c (? . 0) q bytes->path)) q (332717 . 4)) ((c def c (c (? . 1) q unsafe-make-flrectangular)) q (381571 . 5)) ((c def c (c (? . 13) q in-flvector)) q (31217 . 6)) ((c def c (c (? . 1) q unsafe-struct*-set!)) q (385834 . 5)) ((c def c (c (? . 2) q syntax-local-certifier)) q (229482 . 5)) ((c def c (c (? . 0) q syntax-local-lift-require)) q (228502 . 5)) ((c def c (c (? . 0) q null)) q (83075 . 2)) ((c form c (c (? . 40) q ->)) q (165991 . 9)) ((c def c (c (? . 1) q unsafe-extflround)) q (387011 . 3)) ((c form c (c (? . 4) q new)) q (144091 . 2)) ((c form c (c (? . 4) q public-final)) q (141512 . 2)) ((c def c (c (? . 15) q hash-update!)) q (101076 . 11)) ((c def c (c (? . 2) q directory-list)) q (340671 . 4)) ((c def c (c (? . 2) q regexp-match*)) q (66948 . 20)) ((c def c (c (? . 37) q pretty-print-extend-style-table)) q (286343 . 8)) ((c def c (c (? . 0) q read-accept-lang)) q (279976 . 4)) ((c form c (c (? . 16) q for/seteq)) q (121000 . 2)) ((c def c (c (? . 0) q syntax-local-submodules)) q (229333 . 2)) ((c def c (c (? . 0) q make-empty-namespace)) q (292727 . 2)) ((c def c (c (? . 30) q place-enabled?)) q (212106 . 2)) ((c def c (c (? . 9) q fourth)) q (89194 . 3)) ((c def c (c (? . 0) q cdddr)) q (87183 . 3)) ((c def c (c (? . 9) q empty?)) q (88938 . 3)) ((c def c (c (? . 31) q dict-update!)) q (112994 . 10)) ((c def c (c (? . 0) q impersonate-struct)) q (308935 . 15)) ((c def c (c (? . 12) q contract-stronger?)) q (181455 . 4)) ((c def c (c (? . 0) q vector->values)) q (95440 . 5)) ((c form c (c (? . 15) q case)) q (11783 . 5)) ((c def c (c (? . 0) q port-count-lines-enabled)) q (242573 . 4)) ((c def c (c (? . 0) q write-char)) q (274598 . 4)) ((c def c (c (? . 0) q write-bytes)) q (275201 . 7)) ((c def c (c (? . 0) q port-closed-evt)) q (240532 . 3)) ((c def c (c (? . 0) q read-bytes-line)) q (266991 . 5)) ((c def c (c (? . 2) q regexp-match-positions*)) q (69746 . 17)) ((c def c (c (? . 2) q call-with-input-file)) q (243735 . 7)) ((c def c (c (? . 0) q file-or-directory-identity)) q (339659 . 5)) ((c def c (c (? . 101) q vector-immutableof)) q (162587 . 3)) ((c def c (c (? . 36) q flat-contract-predicate)) q (165899 . 3)) ((c def c (c (? . 0) q procedure-arity?)) q (127865 . 3)) ((c def c (c (? . 1) q unsafe-vector-ref)) q (383380 . 4)) ((c def c (c (? . 0) q current-load)) q (297964 . 15)) ((c form c (c (? . 102) q matching-identifiers-out)) q (9409 . 2)) ((c def c (c (? . 13) q fllog)) q (29680 . 3)) ((c def c (c (? . 0) q string-normalize-nfc)) q (42908 . 3)) ((c def c (c (? . 2) q stop-before)) q (106533 . 4)) ((c def c (c (? . 0) q sin)) q (22060 . 3)) ((c def c (c (? . 2) q exn:fail:contract)) c (? . 103)) ((c def c (c (? . 33) q sandbox-init-hook)) q (324830 . 4)) ((c def c (c (? . 0) q flonum?)) q (18934 . 3)) ((c def c (c (? . 23) q with-output-to-string)) q (253810 . 3)) ((c def c (c (? . 1) q unsafe-fx-)) q (378287 . 4)) ((c def c (c (? . 0) q regexp-replace)) q (80500 . 15)) ((c def c (c (? . 0) q variable-reference?)) q (296455 . 3)) ((c def c (c (? . 33) q sandbox-eval-handlers)) q (329185 . 7)) ((c def c (c (? . 25) q import-orig-stx)) c (? . 84)) ((c form c (c (? . 4) q interface)) q (138293 . 5)) ((c def c (c (? . 27) q path-replace-suffix)) q (335986 . 4)) ((c def c (c (? . 0) q read-bytes!)) q (267843 . 7)) ((c def c (c (? . 0) q print-unreadable)) q (282082 . 4)) ((c form c (c (? . 6) q ...)) q (217490 . 2)) ((c def c (c (? . 0) q <)) q (21405 . 4)) ((c form c (c (? . 2) q for*/sum)) q (15219 . 2)) ((c def c (c (? . 0) q make-semaphore)) q (207894 . 3)) ((c form c (c (? . 38) q failure-cont)) q (185438 . 2)) ((c def c (c (? . 0) q string-locale-ci<?)) q (43474 . 4)) ((c def c (c (? . 1) q unsafe-extflvector-length)) q (388137 . 3)) ((c def c (c (? . 0) q char-graphic?)) q (63866 . 3)) ((c def c (c (? . 0) q kill-thread)) q (204988 . 3)) ((c def c (c (? . 8) q spawn)) q (201091 . 3)) ((c form c (c (? . 8) q shift0)) q (200856 . 2)) ((c def c (c (? . 0) q make-custodian)) q (320290 . 3)) ((c form c (c (? . 10) q provide-signature-elements)) q (159633 . 2)) ((c def c (c (? . 33) q sandbox-make-environment-variables)) q (330034 . 5)) ((c def c (c (? . 0) q read-accept-dot)) q (279568 . 4)) ((c def c (c (? . 17) q const)) q (130135 . 3)) ((c def c (c (? . 0) q port-try-file-lock?)) q (246095 . 4)) ((c def c (c (? . 25) q import?)) c (? . 84)) ((c def c (c (? . 1) q unsafe-string-set!)) q (384148 . 5)) ((c def c (c (? . 85) q andmap)) q (83950 . 4)) ((c form c (c (? . 38) q define/match)) q (184327 . 18)) ((c def c (c (? . 0) q current-gc-milliseconds)) q (369720 . 2)) ((c def c (c (? . 33) q get-uncovered-expressions)) q (331528 . 7)) ((c def c (c (? . 104) q struct-type-property/c)) q (170420 . 3)) ((c def c (c (? . 25) q make-require-transformer)) q (231059 . 5)) ((c def c (c (? . 0) q cadddr)) q (87965 . 3)) ((c def c (c (? . 23) q read-bytes-avail!-evt)) q (264206 . 4)) ((c def c (c (? . 2) q make-exn)) c (? . 98)) ((c def c (c (? . 6) q syntax-protect)) q (236889 . 3)) ((c def c (c (? . 1) q unsafe-fxremainder)) q (378528 . 4)) ((c def c (c (? . 0) q free-identifier=?)) q (220586 . 10)) ((c def c (c (? . 7) q group-execute-bit)) q (350086 . 2)) ((c def c (c (? . 0) q regexp-match-peek)) q (71541 . 15)) ((c def c (c (? . 12) q coerce-flat-contract)) q (175108 . 4)) ((c def c (c (? . 16) q set-first)) q (123023 . 3)) ((c def c (c (? . 0) q custom-print-quotable-accessor)) q (290422 . 2)) ((c def c (c (? . 0) q impersonator-of?)) q (308334 . 4)) ((c def c (c (? . 0) q current-directory-for-user)) q (340269 . 4)) ((c def c (c (? . 9) q last)) q (89548 . 3)) ((c def c (c (? . 0) q split-path)) q (335611 . 5)) ((c def c (c (? . 1) q unsafe-flcos)) q (381014 . 3)) ((c def c (c (? . 32) q syntax-local-eval)) q (239803 . 4)) ((c def c (c (? . 2) q in-sequences)) q (106175 . 3)) ((c form c (c (? . 4) q define/overment)) q (142738 . 3)) ((c form c (c (? . 8) q prompt-at)) q (200500 . 2)) ((c def c (c (? . 0) q variable-reference->module-declaration-inspector)) q (297465 . 4)) ((c form c (c (? . 2) q struct)) q (131088 . 31)) ((c def c (c (? . 0) q string->keyword)) q (82630 . 3)) ((c def c (c (? . 0) q denominator)) q (21179 . 3)) ((c def c (c (? . 21) q provide-transformer?)) q (234401 . 3)) ((c def c (c (? . 2) q make-exn:fail:contract:variable)) c (? . 68)) ((c def c (c (? . 0) q chaperone-of?)) q (308419 . 4)) ((c def c (c (? . 42) q udp-send-evt)) q (357576 . 9)) ((c def c (c (? . 1) q unsafe-fx->fl)) q (381903 . 3)) ((c def c (c (? . 0) q make-logger)) q (366629 . 5)) ((c def c (c (? . 0) q char-lower-case?)) q (63462 . 3)) ((c def c (c (? . 0) q make-immutable-hash)) q (99708 . 4)) ((c form c (c (? . 40) q ->*)) q (166159 . 24)) ((c def c (c (? . 0) q string-append)) q (41151 . 3)) ((c def c (c (? . 1) q unsafe-fxand)) q (378756 . 4)) ((c form c (c (? . 0) q let*-values)) q (10763 . 2)) ((c def c (c (? . 0) q current-reader-guard)) q (280308 . 4)) ((c form c (c (? . 4) q send*)) q (145032 . 5)) ((c def c (c (? . 0) q custodian-shutdown-all)) q (320389 . 3)) ((c def c (c (? . 0) q continuation-marks)) q (201441 . 5)) ((c form c (c (? . 59) q delay)) q (196577 . 2)) ((c def c (c (? . 33) q call-with-limits)) q (332091 . 5)) ((c form c (c (? . 4) q augride)) q (141711 . 2)) ((c def c (c (? . 1) q unsafe-unbox)) q (382866 . 3)) ((c def c (c (? . 2) q in-producer)) q (105858 . 7)) ((c def c (c (? . 0) q channel-put-evt)) q (207683 . 4)) ((c def c (c (? . 0) q hash-remove)) q (101927 . 4)) ((c form c (c (? . 32) q with-disappeared-uses)) q (239234 . 4)) ((c def c (c (? . 16) q set-union!)) q (123691 . 4)) ((c def c (c (? . 16) q set-mutable?)) q (119100 . 3)) ((c form c (c (? . 10) q invoke-unit/infer)) q (158102 . 5)) ((c form c (c (? . 4) q init-rest)) q (141404 . 3)) ((c def c (c (? . 0) q odd?)) q (19324 . 3)) ((c form c (c (? . 81) q define-runtime-module-path-index)) q (341373 . 2)) ((c def c (c (? . 28) q fxremainder)) q (32271 . 4)) ((c def c (c (? . 0) q syntax-local-module-exports)) q (228996 . 7)) ((c form c (c (? . 10) q link)) q (156098 . 2)) ((c def c (c (? . 16) q set-implements?)) q (121991 . 4)) ((c def c (c (? . 3) q extfl>=)) q (35848 . 4)) ((c def c (c (? . 0) q >)) q (21550 . 4)) ((c def c (c (? . 50) q system/exit-code)) q (362823 . 5)) ((c def c (c (? . 0) q random)) q (23656 . 8)) ((c def c (c (? . 0) q syntax-arm)) q (236725 . 5)) ((c def c (c (? . 16) q list->set)) q (120059 . 3)) ((c def c (c (? . 0) q struct:exn:fail:user)) c (? . 105)) ((c def c (c (? . 0) q free-label-identifier=?)) q (221212 . 4)) ((c def c (c (? . 28) q fx->fl)) q (33409 . 3)) ((c def c (c (? . 0) q format)) q (281777 . 4)) ((c def c (c (? . 41) q fsemaphore-try-wait?)) q (211932 . 3)) ((q def ((lib "racket/rerequire.rkt") dynamic-rerequire)) q (390835 . 5)) ((c def c (c (? . 0) q exn:fail:contract:non-fixnum-result?)) c (? . 106)) ((c def c (c (? . 1) q unsafe-flsqrt)) q (381430 . 3)) ((c form c (c (? . 24) q and)) q (11736 . 2)) ((c def c (c (? . 2) q regexp-replace-quote)) q (82369 . 5)) ((c def c (c (? . 3) q extfltan)) q (36479 . 3)) ((c def c (c (? . 0) q list->bytes)) q (56588 . 3)) ((c def c (c (? . 3) q extflonum-available?)) q (35083 . 2)) ((c def c (c (? . 36) q any/c)) q (161111 . 2)) ((c def c (c (? . 50) q process/ports)) q (364736 . 11)) ((c def c (c (? . 0) q make-ephemeron)) q (377059 . 4)) ((c def c (c (? . 0) q syntax-transforming?)) q (229634 . 2)) ((c def c (c (? . 0) q read-line)) q (266778 . 5)) ((c def c (c (? . 2) q call-with-output-file*)) q (244824 . 11)) ((c def c (c (? . 0) q bytes-utf-8-length)) q (59151 . 7)) ((c def c (c (? . 13) q shared-flvector)) q (31786 . 3)) ((c def c (c (? . 1) q unsafe-flsin)) q (380955 . 3)) ((c def c (c (? . 48) q gen:stream)) q (110422 . 2)) ((c def c (c (? . 1) q unsafe-extfl=)) q (386385 . 4)) ((c def c (c (? . 0) q load-on-demand-enabled)) q (301745 . 4)) ((c form c (c (? . 2) q struct-out)) q (6104 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:exists?)) c (? . 107)) ((c form c (c (? . 59) q delay/name)) q (196829 . 2)) ((c def c (c (? . 0) q weak-box?)) q (377004 . 3)) ((c def c (c (? . 20) q vector-drop)) q (96429 . 4)) ((c def c (c (? . 0) q make-hasheq-placeholder)) q (93438 . 3)) ((c def c (c (? . 0) q string-locale=?)) q (43063 . 4)) ((c form c (c (? . 2) q for*/last)) q (15414 . 2)) ((c def c (c (? . 36) q list/c)) q (163633 . 3)) ((c def c (c (? . 76) q sequence-tail)) q (107800 . 4)) ((c def c (c (? . 114) q bytes-append*)) q (61860 . 4)) ((c def c (c (? . 0) q syntax-taint)) q (237212 . 3)) ((c def c (c (? . 0) q nack-guard-evt)) q (206801 . 3)) ((c def c (c (? . 2) q sequence-generate*)) q (107392 . 5)) ((c def c (c (? . 3) q extfl/)) q (35379 . 4)) ((c def c (c (? . 16) q list->mutable-seteq)) q (120544 . 4)) ((c form c (c (? . 10) q only)) q (155883 . 2)) ((c def c (c (? . 30) q place-message-allowed?)) q (214094 . 3)) ((c def c (c (? . 35) q checked-struct-info?)) q (137693 . 3)) ((c def c (c (? . 0) q length)) q (83412 . 3)) ((c form c (c (? . 26) q splicing-syntax-parameterize)) q (236159 . 2)) ((c form c (c (? . 2) q require)) q (2020 . 51)) ((c def c (c (? . 0) q syntax->list)) q (218419 . 3)) ((c def c (c (? . 42) q udp-multicast-set-loopback!)) q (359323 . 5)) ((c def c (c (? . 0) q exn:break-continuation)) c (? . 90)) ((c def c (c (? . 1) q unsafe-string-length)) q (383929 . 3)) ((c def c (c (? . 30) q place-wait)) q (213448 . 3)) ((c def c (c (? . 4) q subclass?)) q (152589 . 4)) ((c def c (c (? . 3) q extflceiling)) q (36226 . 3)) ((c form c (c (? . 2) q for*/or)) q (15157 . 2)) ((c def c (c (? . 0) q thread-receive-evt)) q (205885 . 2)) ((c def c (c (? . 3) q extfl-)) q (35213 . 4)) ((c def c (c (? . 0) q file-truncate)) q (241743 . 4)) ((c def c (c (? . 2) q srcloc)) c (? . 18)) ((c def c (c (? . 0) q dump-memory-stats)) q (377854 . 3)) ((c def c (c (? . 0) q file-or-directory-permissions)) q (339273 . 11)) ((c def c (c (? . 0) q free-transformer-identifier=?)) q (220995 . 4)) ((c def c (c (? . 0) q namespace-mapped-symbols)) q (294527 . 3)) ((c def c (c (? . 0) q error-print-source-location)) q (191057 . 4)) ((c def c (c (? . 0) q caaar)) q (86609 . 3)) ((c def c (c (? . 0) q struct:srcloc)) c (? . 18)) ((c def c (c (? . 58) q date->string)) q (370046 . 4)) ((c def c (c (? . 0) q eof-object?)) q (241087 . 3)) ((c def c (c (? . 2) q exn:fail:user)) c (? . 105)) ((c form c (c (? . 60) q redirect-generics)) q (136501 . 4)) ((c def c (c (? . 0) q delete-directory)) q (340599 . 3)) ((c form c (c (? . 92) q implies)) q (18256 . 2)) ((c form c (c (? . 72) q current-contract-region)) q (172179 . 2)) ((c def c (c (? . 4) q writable<%>)) q (151905 . 2)) ((c def c (c (? . 9) q take-right)) q (90294 . 4)) ((c def c (c (? . 0) q ceiling)) q (20949 . 3)) ((c def c (c (? . 9) q argmin)) q (92719 . 4)) ((c form c (c (? . 30) q place*)) q (213256 . 9)) ((c def c (c (? . 40) q unsupplied-arg?)) q (169966 . 3)) ((c def c (c (? . 0) q arity-at-least-value)) c (? . 73)) ((c def c (c (? . 0) q ephemeron-value)) q (377144 . 4)) ((c def c (c (? . 1) q unsafe-fx=)) q (379221 . 4)) ((c def c (c (? . 92) q true)) q (17949 . 2)) ((c form c (c (? . 2) q for/lists)) q (14320 . 2)) ((c form c (c (? . 38) q match-letrec)) q (185237 . 2)) ((c def c (c (? . 2) q with-output-to-file)) q (245610 . 11)) ((c def c (c (? . 2) q exn:fail:filesystem:missing-module)) c (? . 55)) ((c def c (c (? . 0) q make-immutable-hasheqv)) q (99836 . 4)) ((c def c (c (? . 1) q unsafe-extflfloor)) q (387081 . 3)) ((c def c (c (? . 0) q date*?)) c (? . 39)) ((c form c (c (? . 2) q lambda)) q (9869 . 2)) ((c def c (c (? . 42) q udp-connected?)) q (356865 . 3)) ((c def c (c (? . 0) q custom-print-quotable?)) q (290367 . 2)) ((c def c (c (? . 1) q unsafe-flexpt)) q (381490 . 4)) ((c def c (c (? . 0) q current-thread-initial-stack-size)) q (374070 . 4)) ((c def c (c (? . 76) q sequence-fold)) q (108370 . 5)) ((c form c (c (? . 15) q with-handlers)) q (190046 . 3)) ((c def c (c (? . 1) q unsafe-flvector-ref)) q (384653 . 4)) ((c def c (c (? . 0) q eq-hash-code)) q (103448 . 3)) ((c def c (c (? . 1) q unsafe-flmax)) q (380626 . 4)) ((c def c (c (? . 58) q find-seconds)) q (371042 . 15)) ((c def c (c (? . 0) q string-ci>=?)) q (42373 . 4)) ((c def c (c (? . 33) q get-error-output)) c (? . 108)) ((c def c (c (? . 0) q syntax-shift-phase-level)) q (219573 . 4)) ((c def c (c (? . 0) q struct:exn:fail:filesystem)) c (? . 109)) ((c def c (c (? . 45) q filename-extension)) q (336641 . 3)) ((c def c (c (? . 0) q write-string)) q (274921 . 7)) ((c def c (c (? . 0) q make-custodian-box)) q (321277 . 4)) ((c def c (c (? . 0) q get-output-string)) q (247122 . 3)) ((c def c (c (? . 3) q extfl->floating-point-bytes)) q (39265 . 10)) ((c def c (c (? . 2) q hash-set*)) q (100504 . 5)) ((c def c (c (? . 0) q port-file-unlock)) q (246225 . 3)) ((c def c (c (? . 0) q wrap-evt)) q (206528 . 4)) ((c def c (c (? . 8) q call/comp)) q (199995 . 5)) ((c def c (c (? . 35) q prop:struct-info)) q (137996 . 2)) ((c def c (c (? . 0) q procedure-arity-includes?)) q (127927 . 5)) ((c def c (c (? . 17) q curry)) q (130308 . 6)) ((c def c (c (? . 21) q pre-expand-export)) q (233513 . 4)) ((c def c (c (? . 41) q future?)) q (211458 . 3)) ((c def c (c (? . 0) q semaphore?)) q (207838 . 3)) ((c form c (c (? . 10) q unit/c)) q (159684 . 5)) ((c def c (c (? . 0) q shared-bytes)) q (56766 . 3)) ((c def c (c (? . 0) q current-prompt-read)) q (300312 . 4)) ((c form c (c (? . 0) q with-continuation-mark)) q (16604 . 2)) ((c def c (c (? . 0) q print-syntax-width)) q (282960 . 5)) ((c def c (c (? . 0) q print-mpair-curly-braces)) q (281970 . 4)) ((c def c (c (? . 2) q make-exn:fail:contract)) c (? . 103)) ((c def c (c (? . 0) q syntax-local-bind-syntaxes)) q (226789 . 7)) ((c def c (c (? . 0) q imag-part)) q (22653 . 3)) ((c def c (c (? . 0) q continuation-prompt-available?)) q (199099 . 5)) ((c def c (c (? . 0) q syntax-rearm)) q (237070 . 5)) ((c def c (c (? . 0) q call-with-continuation-prompt)) q (197267 . 10)) ((c def c (c (? . 3) q extflvector-length)) q (37583 . 3)) ((c def c (c (? . 0) q identifier-transformer-binding)) q (221975 . 12)) ((c def c (c (? . 67) q sequence->generator)) q (110846 . 3)) ((c def c (c (? . 2) q collection-path)) q (389143 . 8)) ((c def c (c (? . 29) q build-list)) q (83277 . 4)) ((c def c (c (? . 85) q for-each)) q (84123 . 4)) ((c def c (c (? . 1) q unsafe-s16vector-ref)) q (385059 . 4)) ((c def c (c (? . 33) q put-input)) q (331076 . 6)) ((c def c (c (? . 45) q path-element?)) q (337292 . 3)) ((c def c (c (? . 0) q current-memory-use)) q (377752 . 3)) ((c def c (c (? . 23) q special-filter-input-port)) q (263412 . 8)) ((c def c (c (? . 25) q make-import)) c (? . 84)) ((c def c (c (? . 96) q engine-result)) q (214523 . 3)) ((c def c (c (? . 2) q real->decimal-string)) q (25191 . 4)) ((c form c (c (? . 26) q splicing-let-values)) q (235923 . 2)) ((c def c (c (? . 0) q string-ref)) q (40106 . 4)) ((c def c (c (? . 0) q weak-box-value)) q (376891 . 4)) ((c def c (c (? . 1) q unsafe-car)) q (382143 . 3)) ((c form c (c (? . 10) q tag)) q (156131 . 3)) ((c def c (c (? . 9) q append-map)) q (92348 . 4)) ((c def c (c (? . 51) q tcp-close)) q (351620 . 3)) ((c def c (c (? . 16) q subset?)) q (124550 . 4)) ((c def c (c (? . 31) q dict-clear)) q (114074 . 3)) ((c def c (c (? . 40) q predicate/c)) q (169889 . 2)) ((c def c (c (? . 7) q user-execute-bit)) q (349990 . 2)) ((c form c (c (? . 10) q init-depend)) q (156176 . 2)) ((c def c (c (? . 2) q make-exn:fail:filesystem)) c (? . 109)) ((c form c (c (? . 2) q #%module-begin)) q (1803 . 2)) ((c def c (c (? . 36) q chaperone-contract?)) q (181795 . 3)) ((c def c (c (? . 28) q fxvector-set!)) q (33944 . 5)) ((c form c (c (? . 38) q match-let*)) q (185054 . 2)) ((c def c (c (? . 0) q read-accept-infix-dot)) q (279662 . 4)) ((c def c (c (? . 0) q impersonate-box)) q (310100 . 12)) ((c def c (c (? . 0) q will-execute)) q (377566 . 3)) ((c def c (c (? . 2) q in-hash)) q (105509 . 3)) ((c def c (c (? . 37) q pretty-print-size-hook)) q (287482 . 9)) ((c def c (c (? . 0) q eof)) q (241061 . 2)) ((c def c (c (? . 0) q current-code-inspector)) q (322830 . 4)) ((c def c (c (? . 0) q file-size)) q (339802 . 3)) ((c def c (c (? . 0) q struct:exn:fail:contract:divide-by-zero)) c (? . 99)) ((c def c (c (? . 0) q bytes-converter?)) q (61754 . 3)) ((c def c (c (? . 19) q blame-value)) q (175979 . 3)) ((c def c (c (? . 23) q peek-string-evt)) c (? . 66)) ((c form c (c (? . 92) q nor)) q (18232 . 2)) ((c def c (c (? . 0) q compile)) q (301024 . 3)) ((c def c (c (? . 0) q read-accept-reader)) q (279876 . 4)) ((c def c (c (? . 20) q vector-argmax)) q (97486 . 4)) ((c def c (c (? . 0) q bytes-set!)) q (55528 . 5)) ((c def c (c (? . 48) q stream-filter)) q (110238 . 4)) ((c def c (c (? . 27) q channel-get)) q (207487 . 3)) ((c def c (c (? . 37) q tentative-pretty-print-port-transfer)) q (288722 . 5)) ((c def c (c (? . 9) q last-pair)) q (89597 . 3)) ((c def c (c (? . 31) q dict-implements/c)) q (111138 . 3)) ((c def c (c (? . 0) q channel?)) q (207394 . 3)) ((c def c (c (? . 0) q boolean?)) q (17353 . 3)) ((c def c (c (? . 0) q syntax-local-value/immediate)) q (227796 . 8)) ((c def c (c (? . 23) q read-line-evt)) q (264559 . 4)) ((c def c (c (? . 3) q ->extfl)) q (36996 . 3)) ((c form c (c (? . 24) q letrec)) q (10650 . 2)) ((c def c (c (? . 44) q ~.a)) q (51535 . 23)) ((c def c (c (? . 30) q place?)) q (212147 . 3)) ((c def c (c (? . 0) q date-day)) c (? . 56)) ((c form c (c (? . 4) q class)) q (141154 . 2)) ((c def c (c (? . 76) q sequence-map)) q (107975 . 4)) ((c def c (c (? . 0) q date-month)) c (? . 56)) ((c def c (c (? . 1) q unsafe-fllog)) q (381312 . 3)) ((c def c (c (? . 0) q box)) q (97944 . 3)) ((c def c (c (? . 0) q hash)) q (98673 . 4)) ((c def c (c (? . 0) q asin)) q (22210 . 3)) ((c def c (c (? . 0) q real->double-flonum)) q (19680 . 3)) ((c def c (c (? . 0) q peek-bytes)) q (269520 . 5)) ((c def c (c (? . 1) q unsafe-fx<=)) q (379458 . 4)) ((c form c (c (? . 4) q field-bound?)) q (145640 . 2)) ((c form c (c (? . 4) q init)) q (141263 . 2)) ((c def c (c (? . 27) q string-environment-variable-name?)) q (373327 . 3)) ((c def c (c (? . 50) q process*)) q (364119 . 15)) ((c def c (c (? . 23) q port->string)) q (252660 . 3)) ((c def c (c (? . 0) q thread)) q (204428 . 3)) ((c form c (c (? . 16) q for*/seteq)) q (121150 . 2)) ((c def c (c (? . 48) q stream-andmap)) q (109721 . 4)) ((c def c (c (? . 2) q open-input-output-file)) q (243297 . 10)) ((c def c (c (? . 7) q display-lines-to-file)) q (343837 . 13)) ((c def c (c (? . 1) q unsafe-extflsin)) q (387296 . 3)) ((c def c (c (? . 0) q display)) q (281102 . 4)) ((c def c (c (? . 13) q flacos)) q (29574 . 3)) ((c def c (c (? . 0) q identifier-remove-from-definition-context)) q (227188 . 7)) ((c def c (c (? . 76) q sequence-ref)) q (107703 . 4)) ((c def c (c (? . 4) q interface-extension?)) q (152759 . 4)) ((c def c (c (? . 1) q unsafe-fxabs)) q (378697 . 3)) ((c form c (c (? . 0) q begin)) q (12861 . 3)) ((c def c (c (? . 67) q generator-state)) q (110781 . 3)) ((c def c (c (? . 104) q contract-random-generate)) q (183764 . 5)) ((c form c (c (? . 60) q chaperone-generics)) q (136378 . 4)) ((c def c (c (? . 25) q import-local-id)) c (? . 84)) ((c def c (c (? . 0) q real->floating-point-bytes)) q (26767 . 12)) ((c form c (c (? . 38) q match-lambda*)) q (184929 . 2)) ((c def c (c (? . 0) q use-compiled-file-paths)) q (299905 . 5)) ((c def c (c (? . 0) q exn?)) c (? . 98)) ((c def c (c (? . 44) q ~.v)) q (52685 . 23)) ((c def c (c (? . 4) q is-a?)) q (152492 . 4)) ((c form c (c (? . 6) q with-syntax)) q (216109 . 3)) ((c def c (c (? . 0) q handle-evt?)) q (207111 . 3)) ((c def c (c (? . 0) q semaphore-wait/enable-break)) q (208203 . 3)) ((c def c (c (? . 64) q current-trace-print-args)) q (391365 . 14)) ((c form c (c (? . 2) q for*/and)) q (15094 . 2)) ((c def c (c (? . 0) q error-display-handler)) q (190302 . 4)) ((c def c (c (? . 31) q dict-map)) q (113648 . 4)) ((c def c (c (? . 0) q output-port?)) q (240221 . 3)) ((c def c (c (? . 0) q prop:impersonator-of)) q (313363 . 2)) ((c def c (c (? . 9) q filter-map)) q (91899 . 4)) ((c def c (c (? . 0) q path->string)) q (332857 . 3)) ((c def c (c (? . 0) q thread-suspend-evt)) q (205545 . 3)) ((c def c (c (? . 0) q hash-iterate-next)) q (103000 . 5)) ((c def c (c (? . 33) q sandbox-coverage-enabled)) q (326415 . 4)) ((c def c (c (? . 101) q vectorof)) q (162328 . 7)) ((c def c (c (? . 0) q absolute-path?)) q (334407 . 3)) ((c def c (c (? . 25) q expand-import)) q (230959 . 3)) ((c def c (c (? . 23) q peek-string!-evt)) c (? . 66)) ((c def c (c (? . 0) q default-continuation-prompt-tag)) q (197986 . 2)) ((c def c (c (? . 50) q process*/ports)) q (365248 . 27)) ((c def c (c (? . 67) q generator?)) q (110493 . 3)) ((c form c (c (? . 4) q class*)) q (138629 . 57)) ((c def c (c (? . 0) q file-position*)) q (241647 . 3)) ((c form c (c (? . 28) q for/fxvector)) q (34506 . 2)) ((c form c (c (? . 2) q for/sum)) q (14192 . 2)) ((c def c (c (? . 0) q date-week-day)) c (? . 56)) ((c def c (c (? . 33) q sandbox-eval-limits)) q (328810 . 8)) ((c def c (c (? . 23) q call-with-output-string)) q (253620 . 3)) ((c def c (c (? . 0) q substring)) q (40360 . 5)) ((c def c (c (? . 0) q struct:exn:fail:contract:arity)) c (? . 88)) ((c def c (c (? . 16) q set-weak?)) q (119158 . 3)) ((c def c (c (? . 33) q sandbox-input)) q (325058 . 12)) ((c def c (c (? . 0) q char-ci>=?)) q (63297 . 4)) ((c form c (c (? . 4) q define/augment)) q (142914 . 3)) ((c def c (c (? . 0) q syntax-disarm)) q (236954 . 4)) ((c def c (c (? . 2) q make-exn:fail:unsupported)) c (? . 94)) ((c def c (c (? . 0) q >=)) q (21622 . 4)) ((c def c (c (? . 42) q udp-addresses)) q (358262 . 7)) ((c def c (c (? . 0) q list*)) q (83199 . 4)) ((c form c (c (? . 13) q for/flvector)) q (31457 . 2)) ((c def c (c (? . 0) q srcloc-source)) c (? . 18)) ((c def c (c (? . 23) q relocate-input-port)) q (259946 . 11)) ((c def c (c (? . 11) q degrees->radians)) q (27371 . 3)) ((c def c (c (? . 0) q exn:fail:user?)) c (? . 105)) ((c def c (c (? . 7) q find-files)) q (344992 . 7)) ((c def c (c (? . 21) q export-local-id)) c (? . 22)) ((c def c (c (? . 0) q exn:fail:out-of-memory?)) c (? . 89)) ((c def c (c (? . 16) q in-set)) q (125017 . 3)) ((c def c (c (? . 47) q make-chaperone-contract)) q (173168 . 18)) ((c def c (c (? . 0) q error-escape-handler)) q (190191 . 4)) ((c def c (c (? . 13) q flmax)) q (29071 . 4)) ((c def c (c (? . 0) q primitive-closure?)) q (129934 . 3)) ((c form c (c (? . 26) q splicing-letrec)) q (235900 . 2)) ((c def c (c (? . 0) q gensym)) q (65123 . 3)) ((c def c (c (? . 0) q syntax-transforming-module-expression?)) q (229681 . 2)) ((c def c (c (? . 31) q dict-set*!)) q (112593 . 5)) ((c def c (c (? . 30) q place-dead-evt)) q (213511 . 3)) ((c def c (c (? . 36) q </c)) q (161532 . 3)) ((c form c (c (? . 12) q define/subexpression-pos-prop)) q (181307 . 6)) ((c def c (c (? . 37) q pretty-print-abbreviate-read-macros)) q (285949 . 4)) ((c def c (c (? . 0) q peek-string!)) q (269740 . 12)) ((c def c (c (? . 33) q sandbox-reader)) q (324937 . 4)) ((c def c (c (? . 3) q extflmax)) q (36015 . 4)) ((c def c (c (? . 2) q hash-set*!)) q (100222 . 5)) ((c def c (c (? . 28) q fxmax)) q (33336 . 4)) ((c def c (c (? . 15) q current-parameterization)) q (210941 . 2)) ((c def c (c (? . 0) q fprintf)) q (281502 . 5)) ((c def c (c (? . 0) q list->string)) q (41291 . 3)) ((c form c (c (? . 0) q module*)) q (1697 . 3)) ((c def c (c (? . 28) q fxlshift)) q (32749 . 4)) ((c form c (c (? . 2) q submod)) q (4926 . 4)) ((c def c (c (? . 1) q unsafe-fl-)) q (379856 . 4)) ((c def c (c (? . 0) q error-print-width)) q (190455 . 4)) ((c def c (c (? . 1) q unsafe-box*-cas!)) q (383202 . 5)) ((c def c (c (? . 29) q remq)) q (84638 . 4)) ((c def c (c (? . 0) q module->exports)) q (307906 . 5)) ((c def c (c (? . 35) q prop:struct-auto-info)) q (138045 . 2)) ((c def c (c (? . 21) q make-provide-pre-transformer)) q (234105 . 5)) ((c def c (c (? . 0) q regexp-match-peek-positions)) q (72142 . 19)) ((c def c (c (? . 36) q not/c)) q (161355 . 3)) ((c form c (c (? . 2) q relative-in)) q (4448 . 2)) ((q form ((lib "racket/private/define.rkt") define-values-for-syntax)) q (12450 . 2)) ((c def c (c (? . 0) q namespace-require/constant)) q (294866 . 3)) ((c def c (c (? . 9) q third)) q (89144 . 3)) ((c def c (c (? . 0) q path->bytes)) q (332920 . 3)) ((c def c (c (? . 0) q string?)) q (39698 . 3)) ((c def c (c (? . 0) q continuation-mark-set->context)) q (203605 . 3)) ((c def c (c (? . 0) q string-locale>?)) q (43267 . 4)) ((c def c (c (? . 0) q thread-rewind-receive)) q (205926 . 3)) ((c def c (c (? . 23) q display-lines)) q (253352 . 7)) ((c def c (c (? . 0) q cdaar)) q (86937 . 3)) ((c form c (c (? . 110) q include-at/relative-to/reader)) q (237957 . 2)) ((c def c (c (? . 21) q syntax-local-provide-certifier)) q (234793 . 4)) ((c def c (c (? . 101) q vector-immutable/c)) q (162959 . 3)) ((c form c (c (? . 16) q for*/set)) q (121101 . 2)) ((c def c (c (? . 0) q bytes<?)) q (56923 . 4)) ((c form c (c (? . 31) q define-custom-hash-types)) q (114874 . 12)) ((c form c (c (? . 2) q for/hasheq)) q (13938 . 2)) ((c def c (c (? . 27) q channel-put)) q (207605 . 4)) ((q def ((lib "racket/private/stx.rkt") identifier?)) q (217633 . 3)) ((c def c (c (? . 0) q struct-type-make-constructor)) q (322568 . 4)) ((c def c (c (? . 19) q blame?)) q (175395 . 3)) ((c def c (c (? . 0) q variable-reference->resolved-module-path)) q (296826 . 4)) ((c def c (c (? . 2) q in-lines)) q (105127 . 5)) ((c def c (c (? . 41) q fsemaphore-wait)) q (211860 . 3)) ((c form c (c (? . 8) q %)) q (200236 . 4)) ((c def c (c (? . 0) q char-upper-case?)) q (63530 . 3)) ((c def c (c (? . 33) q make-module-evaluator)) c (? . 111)) ((c def c (c (? . 1) q unsafe-flfloor)) q (380767 . 3)) ((c def c (c (? . 33) q break-evaluator)) q (330393 . 3)) ((c def c (c (? . 2) q make-exn:fail:read)) c (? . 75)) ((c def c (c (? . 0) q srcloc?)) c (? . 18)) ((c def c (c (? . 0) q make-output-port)) q (249773 . 59)) ((c def c (c (? . 13) q flrandom)) q (30351 . 3)) ((c def c (c (? . 2) q exn:fail:unsupported)) c (? . 94)) ((c def c (c (? . 16) q set)) q (119213 . 3)) ((c form c (c (? . 4) q mixin)) q (146073 . 3)) ((c def c (c (? . 0) q input-port?)) q (240164 . 3)) ((c def c (c (? . 36) q syntax/c)) q (163727 . 3)) ((c def c (c (? . 0) q semaphore-peek-evt?)) q (208370 . 3)) ((c def c (c (? . 0) q exn:srclocs-accessor)) q (195736 . 4)) ((c def c (c (? . 0) q liberal-define-context?)) q (230890 . 3)) ((c def c (c (? . 0) q current-continuation-marks)) q (201665 . 5)) ((c form c (c (? . 2) q rename-in)) q (4351 . 2)) ((c def c (c (? . 36) q <=/c)) q (161642 . 3)) ((c def c (c (? . 0) q thread-cell-set!)) q (209888 . 4)) ((c def c (c (? . 36) q natural-number/c)) q (162011 . 2)) ((c def c (c (? . 0) q special-comment?)) q (289909 . 3)) ((c def c (c (? . 0) q placeholder?)) q (92993 . 3)) ((c def c (c (? . 37) q pretty-print-.-symbol-without-bars)) q (285691 . 4)) ((c def c (c (? . 27) q load/use-compiled)) q (299620 . 3)) ((c def c (c (? . 0) q char-blank?)) q (63999 . 3)) ((c def c (c (? . 0) q module-compiled-language-info)) q (306365 . 4)) ((c def c (c (? . 0) q read/recursive)) q (277815 . 6)) ((c def c (c (? . 2) q in-values-sequence)) q (106386 . 3)) ((c form c (c (? . 4) q define/override)) q (142656 . 3)) ((c form c (c (? . 4) q define-local-member-name)) q (143544 . 2)) ((c def c (c (? . 112) q box-immutable/c)) q (163283 . 3)) ((c form c (c (? . 8) q reset-at)) q (200659 . 2)) ((c form c (c (? . 2) q :do-in)) q (16077 . 9)) ((c def c (c (? . 16) q set->stream)) q (123211 . 3)) ((c def c (c (? . 33) q call-with-killing-threads)) c (? . 113)) ((c form c (c (? . 2) q for*/first)) q (15349 . 2)) ((c form c (c (? . 4) q send+)) q (145149 . 5)) ((c form c (c (? . 10) q import)) q (156022 . 2)) ((c def c (c (? . 16) q set-subtract!)) q (124116 . 4)) ((c def c (c (? . 38) q match-equality-test)) q (185667 . 4)) ((c def c (c (? . 3) q extflatan)) q (36664 . 3)) ((c def c (c (? . 3) q floating-point-bytes->extfl)) q (38855 . 9)) ((c form c (c (? . 110) q include)) q (237732 . 6)) ((c def c (c (? . 0) q bytes-convert)) q (60378 . 21)) ((c def c (c (? . 4) q generic?)) q (152099 . 3)) ((c def c (c (? . 25) q import-orig-mode)) c (? . 84)) ((c def c (c (? . 0) q date-second)) c (? . 56)) ((c form c (c (? . 10) q unit-from-context)) q (158439 . 2)) ((c form c (c (? . 10) q rename)) q (155951 . 2)) ((c def c (c (? . 0) q hash-eq?)) q (98551 . 3)) ((c def c (c (? . 0) q will-executor?)) q (377368 . 3)) ((c def c (c (? . 0) q local-transformer-expand/capture-lifts)) q (225983 . 11)) ((c def c (c (? . 0) q cadar)) q (86773 . 3)) ((c def c (c (? . 28) q fxxor)) q (32624 . 4)) ((c def c (c (? . 7) q display-to-file)) q (342919 . 11)) ((c def c (c (? . 0) q string=?)) q (41503 . 4)) ((c def c (c (? . 36) q promise/c)) q (165741 . 3)) ((c form c (c (? . 4) q ->*m)) q (148352 . 2)) ((c def c (c (? . 1) q unsafe-extfltruncate)) q (387223 . 3)) ((c def c (c (? . 28) q shared-fxvector)) q (34835 . 3)) ((c def c (c (? . 2) q date)) c (? . 56)) ((c def c (c (? . 13) q fl/)) q (28513 . 4)) ((c def c (c (? . 0) q semaphore-wait)) q (208059 . 3)) ((c def c (c (? . 0) q current-preserved-thread-cell-values)) q (209977 . 4)) ((c form c (c (? . 4) q rename-inner)) q (142003 . 2)) ((c def c (c (? . 0) q namespace-require)) q (294653 . 3)) ((c form c (c (? . 10) q prefix)) q (155992 . 2)) ((c def c (c (? . 0) q single-flonum?)) q (19047 . 3)) ((c def c (c (? . 12) q coerce-contract/f)) q (175319 . 3)) ((c def c (c (? . 0) q module-compiled-imports)) q (305899 . 5)) ((c def c (c (? . 16) q make-custom-set-types)) q (125566 . 25)) ((c form c (c (? . 93) q define/contract)) q (171688 . 3)) ((c def c (c (? . 114) q bytes-join)) q (61963 . 4)) ((c form c (c (? . 100) q define-serializable-struct)) q (291036 . 3)) ((c def c (c (? . 23) q read-bytes!-evt)) q (264024 . 5)) ((c def c (c (? . 42) q udp-receive!/enable-break)) q (356229 . 12)) ((c def c (c (? . 0) q continuation-prompt-tag?)) q (199370 . 3)) ((c def c (c (? . 0) q semaphore-peek-evt)) q (208284 . 3)) ((c def c (c (? . 0) q newline)) q (274832 . 3)) ((c def c (c (? . 0) q peek-byte-or-special)) q (273502 . 8)) ((c def c (c (? . 25) q make-import-source)) c (? . 54)) ((c def c (c (? . 0) q make-known-char-range-list)) q (64203 . 5)) ((c def c (c (? . 2) q apply)) q (126733 . 6)) ((c def c (c (? . 41) q make-fsemaphore)) q (211640 . 3)) ((c def c (c (? . 48) q prop:stream)) q (110449 . 2)) ((c def c (c (? . 0) q make-hash)) q (99027 . 3)) ((c form c (c (? . 2) q for/first)) q (14395 . 2)) ((c form c (c (? . 115) q command-line)) q (374422 . 43)) ((c def c (c (? . 16) q set-rest)) q (123114 . 3)) ((c def c (c (? . 2) q make-exn:fail:contract:non-fixnum-result)) c (? . 106)) ((c def c (c (? . 0) q path->complete-path)) q (334719 . 5)) ((c def c (c (? . 35) q make-struct-info)) q (137759 . 3)) ((c def c (c (? . 2) q regexp-replace*)) q (81136 . 15)) ((c def c (c (? . 0) q struct:exn:fail:read:eof)) c (? . 46)) ((c form c (c (? . 64) q untrace)) q (391073 . 2)) ((c def c (c (? . 0) q rename-file-or-directory)) q (338662 . 7)) ((c def c (c (? . 0) q exn:fail:filesystem?)) c (? . 109)) ((c def c (c (? . 0) q <=)) q (21477 . 4)) ((c def c (c (? . 0) q hasheqv)) q (98908 . 4)) ((c form c (c (? . 6) q syntax)) q (216173 . 23)) ((c def c (c (? . 9) q dropf)) q (90119 . 4)) ((c def c (c (? . 42) q udp-send-to*)) q (353747 . 13)) ((c form c (c (? . 32) q with-syntax*)) q (239948 . 5)) ((c form c (c (? . 110) q include/reader)) q (237909 . 2)) ((c def c (c (? . 0) q box?)) q (97894 . 3)) ((c def c (c (? . 1) q unsafe-extflabs)) q (386317 . 3)) ((c def c (c (? . 3) q extflsqrt)) q (36848 . 3)) ((c def c (c (? . 0) q subprocess-wait)) q (360975 . 3)) ((c form c (c (? . 0) q unquote)) q (16696 . 2)) ((c def c (c (? . 0) q primitive-result-arity)) q (129997 . 3)) ((c def c (c (? . 9) q rest)) q (89042 . 3)) ((c def c (c (? . 0) q char>?)) q (62725 . 4)) ((c def c (c (? . 0) q immutable?)) q (17814 . 3)) ((c def c (c (? . 92) q false?)) q (18155 . 3)) ((c def c (c (? . 16) q generic-set?)) q (121933 . 3)) ((c def c (c (? . 58) q current-date)) q (370009 . 2)) ((c def c (c (? . 28) q fx-)) q (32051 . 4)) ((c def c (c (? . 9) q second)) q (89093 . 3)) ((c def c (c (? . 0) q exn:fail:filesystem:errno?)) c (? . 69)) ((c def c (c (? . 31) q in-dict)) q (114370 . 3)) ((c def c (c (? . 116) q syntax-parameter-value)) q (235719 . 3)) ((c def c (c (? . 0) q bytes->string/locale)) q (57363 . 9)) ((c form c (c (? . 15) q time)) q (369983 . 2)) ((c def c (c (? . 2) q raise-arity-error)) q (189007 . 9)) ((c def c (c (? . 2) q in-value)) q (106055 . 3)) ((c def c (c (? . 0) q syntax-local-name)) q (228784 . 2)) ((c form c (c (? . 100) q define-serializable-struct/versions)) q (291546 . 4)) ((c form c (c (? . 24) q let*)) q (10601 . 2)) ((c def c (c (? . 0) q syntax-e)) q (218364 . 3)) ((c form c (c (? . 15) q parameterize)) q (210354 . 5)) ((c def c (c (? . 1) q unsafe-fxmodulo)) q (378614 . 4)) ((c def c (c (? . 0) q syntax-position)) q (217935 . 3)) ((c def c (c (? . 1) q unsafe-fl>)) q (380307 . 4)) ((c def c (c (? . 27) q rationalize)) q (21240 . 4)) ((c def c (c (? . 0) q write-special)) q (276671 . 4)) ((c def c (c (? . 3) q real->extfl)) q (37137 . 3)) ((c def c (c (? . 0) q thread/suspend-to-kill)) q (204583 . 3)) ((c def c (c (? . 7) q file->list)) q (341989 . 5)) ((c form c (c (? . 4) q pubment)) q (141475 . 2)) ((c def c (c (? . 48) q stream->list)) q (109248 . 3)) ((c def c (c (? . 1) q unsafe-fltan)) q (381073 . 3)) ((c form c (c (? . 8) q shift-at)) q (200706 . 2)) ((c def c (c (? . 0) q global-port-print-handler)) q (284339 . 6)) ((c def c (c (? . 0) q thread-group?)) q (321621 . 3)) ((c def c (c (? . 0) q struct:exn:fail:contract)) c (? . 103)) ((c def c (c (? . 0) q inexact-real?)) q (18822 . 3)) ((c def c (c (? . 0) q vector-fill!)) q (94898 . 4)) ((c def c (c (? . 104) q raise-contract-error)) q (183211 . 13)) ((c def c (c (? . 28) q fxvector-length)) q (33748 . 3)) ((c form c (c (? . 57) q trait)) q (146156 . 18)) ((c form c (c (? . 0) q module)) q (1653 . 2)) ((c def c (c (? . 0) q read-bytes-avail!)) q (268137 . 7)) ((c def c (c (? . 0) q current-eval)) q (297586 . 4)) ((c def c (c (? . 11) q radians->degrees)) q (27430 . 3)) ((c def c (c (? . 1) q unsafe-fx>=)) q (379538 . 4)) ((c def c (c (? . 1) q unsafe-fxnot)) q (378996 . 3)) ((c def c (c (? . 16) q set->list)) q (124741 . 3)) ((c def c (c (? . 0) q magnitude)) q (22707 . 3)) ((c def c (c (? . 0) q keyword<?)) q (82697 . 4)) ((c def c (c (? . 0) q write-bytes-avail)) q (275481 . 9)) ((c def c (c (? . 0) q security-guard?)) q (319376 . 3)) ((c def c (c (? . 1) q unsafe-extfl*)) q (386137 . 4)) ((c def c (c (? . 0) q path-element->bytes)) q (333309 . 3)) ((c form c (c (? . 24) q let)) q (10502 . 3)) ((c form c (c (? . 92) q nand)) q (18207 . 2)) ((c def c (c (? . 42) q udp-receive!-evt)) q (357897 . 9)) ((c form c (c (? . 4) q absent)) q (148290 . 2)) ((c def c (c (? . 36) q false/c)) q (162121 . 2)) ((c def c (c (? . 13) q fl<=)) q (28852 . 4)) ((c def c (c (? . 0) q variable-reference->module-path-index)) q (296962 . 4)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:exists)) c (? . 107)) ((c def c (c (? . 8) q new-prompt)) q (201327 . 2)) ((c form c (c (? . 4) q define/augment-final)) q (143074 . 3)) ((c def c (c (? . 92) q xor)) q (18287 . 4)) ((c def c (c (? . 0) q syntax-local-introduce)) q (229746 . 3)) ((c def c (c (? . 0) q make-struct-field-accessor)) q (133719 . 8)) ((c def c (c (? . 1) q unsafe-fx*)) q (378365 . 4)) ((c def c (c (? . 96) q engine-kill)) q (214589 . 3)) ((c def c (c (? . 0) q ephemeron?)) q (377261 . 3)) ((c def c (c (? . 2) q make-exn:fail:network:errno)) c (? . 117)) ((c def c (c (? . 36) q listof)) q (163349 . 3)) ((c def c (c (? . 0) q bytes->list)) q (56517 . 3)) ((c def c (c (? . 0) q struct-type-property-accessor-procedure?)) q (135061 . 3)) ((c def c (c (? . 31) q dict-has-key?)) q (112505 . 4)) ((c def c (c (? . 29) q assf)) q (86260 . 4)) ((c def c (c (? . 1) q unsafe-vector-set!)) q (383463 . 5)) ((c def c (c (? . 0) q module-compiled-exports)) q (306132 . 5)) ((c form c (c (? . 8) q reset)) q (200601 . 2)) ((c form c (c (? . 2) q for*/hash)) q (14897 . 2)) ((c def c (c (? . 23) q input-port-append)) q (254386 . 4)) ((c def c (c (? . 0) q prop:custom-write)) q (290079 . 2)) ((c form c (c (? . 4) q define-serializable-class)) q (151744 . 3)) ((c def c (c (? . 2) q exn:fail:contract:variable)) c (? . 68)) ((c def c (c (? . 0) q date-dst?)) c (? . 56)) ((c def c (c (? . 0) q floor)) q (20866 . 3)) ((c def c (c (? . 48) q stream-fold)) q (110017 . 5)) ((c def c (c (? . 20) q vector-set*!)) q (95783 . 5)) ((c def c (c (? . 0) q hash-clear!)) q (102052 . 3)) ((c def c (c (? . 16) q set-remove!)) q (122794 . 4)) ((c form c (c (? . 8) q set)) q (201359 . 2)) ((c def c (c (? . 0) q placeholder-set!)) q (93117 . 4)) ((c def c (c (? . 0) q eqv-hash-code)) q (103505 . 3)) ((c def c (c (? . 11) q conjugate)) q (27612 . 3)) ((c def c (c (? . 0) q rename-transformer-target)) q (224235 . 3)) ((c def c (c (? . 0) q locale-string-encoding)) q (61816 . 2)) ((c def c (c (? . 0) q break-thread)) q (205048 . 4)) ((c def c (c (? . 0) q choice-evt)) q (206468 . 3)) ((c def c (c (? . 0) q parameter?)) q (210789 . 3)) ((c def c (c (? . 33) q call-with-trusted-sandbox-configuration)) q (324738 . 3)) ((c def c (c (? . 0) q string-copy)) q (40539 . 3)) ((c def c (c (? . 0) q hash-ref)) q (100656 . 7)) ((c def c (c (? . 0) q namespace-require/copy)) q (294757 . 3)) ((c def c (c (? . 0) q never-evt)) q (206989 . 2)) ((c def c (c (? . 2) q stop-after)) q (106639 . 4)) ((c def c (c (? . 0) q close-input-port)) q (240330 . 3)) ((c def c (c (? . 0) q random-seed)) q (24017 . 3)) ((c def c (c (? . 104) q contract-proc)) q (183586 . 6)) ((c form c (c (? . 24) q or)) q (11760 . 2)) ((c def c (c (? . 0) q file-stream-port?)) q (240926 . 3)) ((c def c (c (? . 0) q regexp-match-peek-positions-immediate/end)) q (78667 . 22)) ((c def c (c (? . 2) q in-string)) q (104367 . 6)) ((c def c (c (? . 0) q struct:arity-at-least)) c (? . 73)) ((c form c (c (? . 8) q reset0-at)) q (200937 . 2)) ((c def c (c (? . 48) q empty-stream)) q (109217 . 2)) ((c form c (c (? . 2) q provide)) q (5104 . 20)) ((c def c (c (? . 48) q stream-map)) q (109640 . 4)) ((c def c (c (? . 13) q flceiling)) q (29252 . 3)) ((c def c (c (? . 2) q prop:procedure)) q (129148 . 2)) ((c def c (c (? . 2) q exn:fail:filesystem:exists)) c (? . 107)) ((c def c (c (? . 0) q system-idle-evt)) q (207014 . 2)) ((c form c (c (? . 118) q opt/c)) q (182428 . 5)) ((c def c (c (? . 7) q call-with-atomic-output-file)) q (346400 . 8)) ((c def c (c (? . 0) q string-normalize-nfkd)) q (42830 . 3)) ((c def c (c (? . 0) q port-provides-progress-evts?)) q (273980 . 3)) ((c def c (c (? . 0) q thread-resume)) q (204854 . 4)) ((c def c (c (? . 0) q exn:srclocs?)) q (195678 . 3)) ((c form c (c (? . 82) q quasisyntax/loc)) q (217207 . 2)) ((c def c (c (? . 29) q memf)) q (85740 . 4)) ((c def c (c (? . 2) q in-bytes)) q (104603 . 6)) ((c def c (c (? . 7) q fold-files)) q (345500 . 12)) ((c def c (c (? . 0) q port-write-handler)) q (283664 . 6)) ((c def c (c (? . 0) q thread-receive)) q (205805 . 2)) ((c def c (c (? . 0) q pseudo-random-generator->vector)) q (24416 . 4)) ((c form c (c (? . 4) q super-new)) q (144316 . 2)) ((c def c (c (? . 119) q s-exp->fasl)) q (292471 . 4)) ((c def c (c (? . 2) q procedure-reduce-keyword-arity)) q (128597 . 10)) ((c def c (c (? . 0) q subprocess?)) q (361411 . 3)) ((c def c (c (? . 0) q zero?)) q (19107 . 3)) ((c def c (c (? . 0) q eprintf)) q (281695 . 4)) ((c def c (c (? . 0) q struct:exn)) c (? . 98)) ((c def c (c (? . 0) q char?)) q (62058 . 3)) ((c def c (c (? . 15) q call-with-parameterization)) q (211001 . 5)) ((c def c (c (? . 0) q thread-cell-ref)) q (209819 . 3)) ((c def c (c (? . 16) q set-copy)) q (123276 . 3)) ((c def c (c (? . 0) q complete-path?)) q (334615 . 3)) ((c def c (c (? . 0) q make-pipe)) q (247195 . 6)) ((c form c (c (? . 8) q prompt0)) q (200765 . 2)) ((c def c (c (? . 64) q trace-call)) q (391236 . 5)) ((c def c (c (? . 42) q udp-receive-ready-evt)) q (357019 . 3)) ((c def c (c (? . 13) q flimag-part)) q (30257 . 3)) ((c def c (c (? . 0) q will-register)) q (377428 . 5)) ((c def c (c (? . 13) q fl>=)) q (28925 . 4)) ((c form c (c (? . 15) q log-error)) q (367627 . 3)) ((c def c (c (? . 0) q read-char)) q (266562 . 3)) ((c def c (c (? . 0) q make-will-executor)) q (377317 . 2)) ((c def c (c (? . 0) q lcm)) q (20724 . 3)) ((c def c (c (? . 23) q peek-bytes-evt)) c (? . 66)) ((c def c (c (? . 7) q make-directory*)) q (346001 . 3)) ((c def c (c (? . 0) q procedure-closure-contents-eq?)) q (127200 . 5)) ((c def c (c (? . 0) q hash-for-each)) q (102647 . 4)) ((c form c (c (? . 26) q splicing-let-syntaxes)) q (236037 . 2)) ((c def c (c (? . 0) q subbytes)) q (55677 . 5)) ((c form c (c (? . 10) q invoke-unit)) q (156232 . 3)) ((c def c (c (? . 0) q hash-equal?)) q (98427 . 3)) ((c def c (c (? . 0) q use-user-specific-search-paths)) q (390316 . 4)) ((c form c (c (? . 0) q #%require)) q (6542 . 33)) ((c form c (c (? . 120) q struct/dc)) q (163845 . 24)) ((c def c (c (? . 0) q exn:break:hang-up?)) c (? . 79)) ((c def c (c (? . 30) q place-location?)) q (214214 . 3)) ((c form c (c (? . 16) q for/mutable-set)) q (121253 . 2)) ((c def c (c (? . 28) q fx>=)) q (33190 . 4)) ((c def c (c (? . 96) q engine?)) q (214366 . 3)) ((c def c (c (? . 57) q trait-sum)) q (147068 . 3)) ((c def c (c (? . 42) q udp-multicast-ttl)) q (359675 . 3)) ((c def c (c (? . 27) q find-library-collection-paths)) q (388425 . 5)) ((c form c (c (? . 4) q ->m)) q (148322 . 2)) ((c def c (c (? . 0) q string->unreadable-symbol)) q (65047 . 3)) ((c def c (c (? . 2) q make-exn:fail:filesystem:version)) c (? . 53)) ((c def c (c (? . 0) q read-accept-compiled)) q (279150 . 4)) ((c def c (c (? . 1) q unsafe-fx->extfl)) q (388005 . 3)) ((c def c (c (? . 0) q expand-syntax-to-top-form)) q (237656 . 3)) ((c def c (c (? . 7) q delete-directory/files)) q (344807 . 5)) ((c def c (c (? . 60) q exn:fail:support)) c (? . 63)) ((c def c (c (? . 28) q make-shared-fxvector)) q (34904 . 4)) ((c def c (c (? . 3) q extflmin)) q (35930 . 4)) ((c def c (c (? . 37) q pretty-print-style-table?)) q (286091 . 3)) ((c def c (c (? . 0) q syntax-original?)) q (218122 . 3)) ((c def c (c (? . 48) q stream-ref)) q (109384 . 4)) ((c def c (c (? . 71) q make-deserialize-info)) q (291822 . 4)) ((c def c (c (? . 31) q dict-can-functional-set?)) q (111344 . 3)) ((c def c (c (? . 1) q unsafe-set-mcdr!)) q (382438 . 4)) ((c def c (c (? . 0) q exn:break?)) c (? . 90)) ((c def c (c (? . 0) q bytes-convert-end)) q (61220 . 13)) ((c def c (c (? . 71) q deserialize-module-guard)) q (290735 . 5)) ((c def c (c (? . 0) q call-with-semaphore)) q (208435 . 9)) ((c def c (c (? . 41) q fsemaphore?)) q (211731 . 3)) ((c def c (c (? . 0) q read-byte)) q (266670 . 3)) ((c def c (c (? . 0) q exn:fail:network:errno?)) c (? . 117)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:errno)) c (? . 69)) ((c def c (c (? . 0) q exn:fail:contract:arity?)) c (? . 88)) ((c def c (c (? . 0) q prop:exn:missing-module)) q (196286 . 2)) ((c def c (c (? . 0) q make-file-or-directory-link)) q (340029 . 4)) ((c def c (c (? . 1) q unsafe-fltruncate)) q (380891 . 3)) ((c def c (c (? . 121) q syntax-local-require-introduce)) q (12600 . 3)) ((c def c (c (? . 31) q dict-set)) q (111795 . 5)) ((q form ((lib "racket/surrogate.rkt") surrogate)) q (153831 . 10)) ((c def c (c (? . 9) q take)) q (89741 . 4)) ((c def c (c (? . 48) q stream-tail)) q (109477 . 4)) ((c def c (c (? . 0) q subprocess-group-enabled)) q (361646 . 4)) ((c def c (c (? . 0) q file-position)) q (241447 . 6)) ((c def c (c (? . 0) q struct-type-info)) q (322273 . 11)) ((c def c (c (? . 0) q log-receiver?)) q (367917 . 3)) ((c def c (c (? . 3) q extflexp)) q (36787 . 3)) ((c def c (c (? . 0) q custodian?)) q (320234 . 3)) ((c def c (c (? . 0) q compile-enforce-module-constants)) q (301259 . 4)) ((c def c (c (? . 2) q memv)) q (85576 . 4)) ((c def c (c (? . 2) q regexp-match-exact?)) q (71371 . 4)) ((c def c (c (? . 7) q other-write-bit)) q (350151 . 2)) ((c def c (c (? . 0) q hasheq)) q (98791 . 4)) ((c def c (c (? . 12) q coerce-chaperone-contract)) q (174877 . 4)) ((c def c (c (? . 7) q write-to-file)) q (343382 . 11)) ((c def c (c (? . 0) q path->directory-path)) q (334939 . 3)) ((c def c (c (? . 0) q print)) q (281218 . 5)) ((c def c (c (? . 36) q none/c)) q (161142 . 2)) ((c def c (c (? . 44) q ~r)) q (50324 . 25)) ((c form c (c (? . 8) q shift0-at)) q (201039 . 2)) ((c def c (c (? . 37) q pretty-display)) q (284887 . 4)) ((c def c (c (? . 0) q filesystem-change-evt?)) q (340877 . 3)) ((c form c (c (? . 15) q log-debug)) q (367845 . 3)) ((c def c (c (? . 13) q fl<)) q (28708 . 4)) ((c def c (c (? . 36) q between/c)) q (161754 . 4)) ((c def c (c (? . 0) q list?)) q (83096 . 3)) ((q form ((lib "racket/contract/private/provide.rkt") provide/contract)) q (171187 . 2)) ((c def c (c (? . 0) q string->path-element)) q (332997 . 3)) ((c def c (c (? . 3) q extflvector-copy)) q (37937 . 5)) ((c def c (c (? . 0) q custom-write?)) q (290129 . 3)) ((c form c (c (? . 122) q define-syntax-parameter)) q (235611 . 2)) ((c def c (c (? . 3) q make-shared-extflvector)) q (38721 . 4)) ((c def c (c (? . 27) q load/cd)) q (298668 . 3)) ((c def c (c (? . 29) q build-string)) q (41362 . 4)) ((c def c (c (? . 3) q extflvector?)) q (37327 . 3)) ((c form c (c (? . 15) q with-handlers*)) q (190118 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax)) c (? . 74)) ((c def c (c (? . 2) q regexp-replaces)) q (81883 . 8)) ((c def c (c (? . 0) q bitwise-bit-field)) q (23254 . 6)) ((c def c (c (? . 9) q argmax)) q (92826 . 4)) ((c form c (c (? . 4) q define/override-final)) q (142820 . 3)) ((c def c (c (? . 0) q module-path?)) q (302603 . 3)) ((c def c (c (? . 0) q equal-secondary-hash-code)) q (103623 . 3)) ((c def c (c (? . 0) q port-print-handler)) q (284102 . 7)) ((c def c (c (? . 0) q local-expand)) q (224399 . 13)) ((c form c (c (? . 123) q begin-encourage-inline)) q (16879 . 2)) ((c form c (c (? . 6) q _)) q (217501 . 2)) ((c def c (c (? . 9) q partition)) q (92101 . 4)) ((c form c (c (? . 2) q )) q (9909 . 11)) ((c def c (c (? . 0) q struct-type-property?)) q (134994 . 3)) ((c def c (c (? . 40) q the-unsupplied-arg)) q (169921 . 2)) ((c def c (c (? . 0) q struct:exn:break)) c (? . 90)) ((c def c (c (? . 2) q in-port)) q (104839 . 4)) ((c def c (c (? . 0) q list-ref)) q (83486 . 4)) ((c def c (c (? . 0) q read-bytes-avail!*)) q (268449 . 10)) ((c form c (c (? . 4) q init-field)) q (141293 . 2)) ((c def c (c (? . 27) q bytes-environment-variable-name?)) q (371983 . 3)) ((c def c (c (? . 124) q new-/c)) q (170128 . 3)) ((c def c (c (? . 1) q unsafe-extflcos)) q (387364 . 3)) ((c def c (c (? . 13) q flvector-ref)) q (30786 . 4)) ((c def c (c (? . 7) q file->string)) q (341564 . 4)) ((c form c (c (? . 0) q begin0)) q (12907 . 2)) ((c def c (c (? . 0) q custodian-box-value)) q (321437 . 3)) ((c def c (c (? . 1) q unsafe-vector-length)) q (383313 . 3)) ((c def c (c (? . 29) q findf)) q (85833 . 4)) ((c def c (c (? . 23) q port->lines)) q (252842 . 5)) ((c def c (c (? . 1) q unsafe-set-mcar!)) q (382359 . 4)) ((c def c (c (? . 0) q set-box!)) q (98116 . 4)) ((c def c (c (? . 0) q char-titlecase)) q (64525 . 3)) ((c def c (c (? . 0) q special-comment-value)) q (289971 . 3)) ((c def c (c (? . 16) q weak-seteq)) q (119965 . 3)) ((c def c (c (? . 0) q pregexp?)) q (65360 . 3)) ((c def c (c (? . 58) q date->seconds)) q (370812 . 4)) ((c def c (c (? . 1) q unsafe-u16vector-ref)) q (385309 . 4)) ((c def c (c (? . 0) q srcloc-column)) c (? . 18)) ((c def c (c (? . 0) q environment-variables-names)) q (372842 . 4)) ((c form c (c (? . 38) q match-let-values)) q (185106 . 2)) ((c def c (c (? . 0) q write-byte)) q (274715 . 4)) ((c def c (c (? . 0) q bytes-close-converter)) q (60288 . 3)) ((c def c (c (? . 0) q string-upcase)) q (42472 . 3)) ((c def c (c (? . 0) q string-normalize-nfd)) q (42753 . 3)) ((c form c (c (? . 4) q inherit)) q (141844 . 2)) ((c def c (c (? . 0) q chaperone?)) q (308278 . 3)) ((c def c (c (? . 51) q tcp-listener?)) q (351694 . 3)) ((c def c (c (? . 0) q raise-syntax-error)) q (189382 . 11)) ((c def c (c (? . 0) q keyword->string)) q (82555 . 3)) ((c def c (c (? . 0) q impersonate-hash)) q (310579 . 20)) ((c def c (c (? . 0) q char-general-category)) q (64131 . 3)) ((c form c (c (? . 15) q do)) q (16443 . 7)) ((c form c (c (? . 8) q reset0)) q (200794 . 2)) ((c def c (c (? . 27) q call-with-default-reading-parameterization)) q (280213 . 3)) ((c def c (c (? . 2) q member)) q (85424 . 5)) ((c def c (c (? . 36) q integer-in)) q (161912 . 4)) ((c def c (c (? . 1) q unsafe-extfl<)) q (386473 . 4)) ((c def c (c (? . 0) q read-accept-bar-quote)) q (279254 . 4)) ((c form c (c (? . 24) q letrec-syntax)) q (10948 . 2)) ((c def c (c (? . 13) q flfloor)) q (29198 . 3)) ((c form c (c (? . 10) q except)) q (155916 . 2)) ((c def c (c (? . 0) q module-path-index-join)) q (304565 . 5)) ((c def c (c (? . 0) q integer-sqrt)) q (21746 . 3)) ((c def c (c (? . 2) q make-exn:fail:contract:divide-by-zero)) c (? . 99)) ((c def c (c (? . 13) q flreal-part)) q (30163 . 3)) ((c def c (c (? . 0) q continuation-mark-set->list)) q (201844 . 8)) ((c def c (c (? . 0) q make-security-guard)) q (319437 . 16)) ((c def c (c (? . 2) q open-output-file)) q (242836 . 10)) ((c def c (c (? . 95) q is-a?/c)) q (151281 . 3)) ((c def c (c (? . 11) q exact-ceiling)) q (27955 . 3)) ((c form c (c (? . 4) q inner)) q (143448 . 3)) ((c def c (c (? . 0) q gcd)) q (20665 . 3)) ((c def c (c (? . 0) q identifier-prune-to-source-module)) q (220016 . 3)) ((c def c (c (? . 92) q false)) q (17973 . 2)) ((c def c (c (? . 2) q exn:fail:filesystem)) c (? . 109)) ((c def c (c (? . 21) q make-export)) c (? . 22)) ((c def c (c (? . 0) q string->bytes/latin-1)) q (58576 . 9)) ((c def c (c (? . 31) q prop:dict/contract)) q (114628 . 2)) ((c def c (c (? . 0) q positive?)) q (19160 . 3)) ((c form c (c (? . 2) q for/last)) q (14459 . 2)) ((c def c (c (? . 0) q date-time-zone-offset)) c (? . 56)) ((c def c (c (? . 16) q set-equal?)) q (118887 . 3)) ((c def c (c (? . 1) q unsafe-fl/)) q (380012 . 4)) ((c def c (c (? . 1) q unsafe-flasin)) q (381132 . 3)) ((c def c (c (? . 0) q log-level?)) q (367303 . 4)) ((c def c (c (? . 16) q set-implements/c)) q (122091 . 3)) ((c def c (c (? . 59) q promise-forced?)) q (196676 . 3)) ((c def c (c (? . 28) q fxquotient)) q (32193 . 4)) ((c def c (c (? . 0) q namespace-syntax-introduce)) q (296170 . 3)) ((c def c (c (? . 51) q tcp-connect)) q (350559 . 9)) ((c def c (c (? . 0) q char-iso-control?)) q (64062 . 3)) ((c form c (c (? . 2) q #%plain-module-begin)) q (1882 . 2)) ((c def c (c (? . 0) q set-mcar!)) q (93850 . 4)) ((c def c (c (? . 0) q string->uninterned-symbol)) q (64971 . 3)) ((c def c (c (? . 1) q unsafe-flceiling)) q (380828 . 3)) ((c def c (c (? . 0) q object-name)) q (322778 . 3)) ((c def c (c (? . 0) q set!-transformer?)) q (223567 . 3)) ((c def c (c (? . 37) q make-tentative-pretty-print-output-port)) q (288412 . 8)) ((c def c (c (? . 3) q extfl->inexact)) q (37268 . 3)) ((c def c (c (? . 0) q module-compiled-cross-phase-persistent?)) q (306545 . 4)) ((c def c (c (? . 0) q prop:output-port)) q (247546 . 2)) ((c def c (c (? . 0) q regexp-match-positions/end)) q (76804 . 16)) ((c def c (c (? . 0) q handle-evt)) q (206626 . 4)) ((c def c (c (? . 2) q exn:fail:contract:non-fixnum-result)) c (? . 106)) ((c def c (c (? . 0) q path-convention-type)) q (333482 . 3)) ((c def c (c (? . 0) q build-path/convention-type)) q (333959 . 9)) ((c form c (c (? . 2) q for*/fold)) q (15478 . 3)) ((c def c (c (? . 36) q contract-projection)) q (182176 . 3)) ((c def c (c (? . 0) q cdddar)) q (88665 . 3)) ((c def c (c (? . 0) q namespace-require/expansion-time)) q (294979 . 4)) ((c def c (c (? . 2) q in-cycle)) q (106247 . 3)) ((c def c (c (? . 0) q procedure-extract-target)) q (129276 . 3)) ((c form c (c (? . 4) q inherit/inner)) q (141924 . 2)) ((c def c (c (? . 71) q make-serialize-info)) q (291998 . 12)) ((c form c (c (? . 16) q for*/seteqv)) q (121201 . 2)) ((c def c (c (? . 1) q unsafe-f64vector-set!)) q (384944 . 5)) ((c def c (c (? . 42) q udp-send-to-evt)) q (357099 . 13)) ((c def c (c (? . 13) q flmin)) q (28998 . 4)) ((c def c (c (? . 0) q impersonate-channel)) q (311538 . 13)) ((c def c (c (? . 2) q exn)) c (? . 98)) ((c def c (c (? . 7) q copy-directory/files)) q (344419 . 9)) ((c def c (c (? . 2) q sequence->stream)) q (107235 . 3)) ((c def c (c (? . 33) q sandbox-gui-available)) q (327115 . 4)) ((c def c (c (? . 0) q vector->pseudo-random-generator!)) q (24674 . 5)) ((c def c (c (? . 0) q equal?)) q (17456 . 4)) ((c def c (c (? . 1) q unsafe-extflexpt)) q (387912 . 4)) ((c def c (c (? . 0) q expand)) q (237275 . 3)) ((c def c (c (? . 0) q continuation-mark-set?)) q (203537 . 3)) ((c def c (c (? . 31) q dict-iterate-key)) q (112331 . 4)) ((c def c (c (? . 23) q open-output-nowhere)) q (257791 . 4)) ((c def c (c (? . 20) q vector-split-at-right)) q (96766 . 4)) ((c def c (c (? . 0) q copy-file)) q (339888 . 5)) ((c form c (c (? . 10) q define-compound-unit)) q (157674 . 5)) ((c def c (c (? . 124) q new-/c)) q (170064 . 3)) ((c def c (c (? . 33) q sandbox-exit-handler)) q (328534 . 4)) ((c def c (c (? . 47) q build-flat-contract-property)) q (177368 . 22)) ((c def c (c (? . 33) q sandbox-error-output)) q (325915 . 14)) ((c def c (c (? . 0) q make-struct-type)) q (132419 . 31)) ((c form c (c (? . 10) q open)) q (155767 . 2)) ((c def c (c (? . 0) q phantom-bytes?)) q (377917 . 3)) ((c def c (c (? . 12) q impersonator-prop:contracted)) q (177306 . 2)) ((c def c (c (? . 2) q for-clause-syntax-protect)) q (16367 . 3)) ((c form c (c (? . 0) q #%provide)) q (8105 . 23)) ((c def c (c (? . 0) q variable-reference->module-base-phase)) q (297352 . 3)) ((c def c (c (? . 0) q struct:exn:fail:network:errno)) c (? . 117)) ((c form c (c (? . 17) q thunk)) q (130186 . 2)) ((c def c (c (? . 2) q exn:fail:network:errno)) c (? . 117)) ((c def c (c (? . 32) q current-syntax-context)) q (238769 . 4)) ((c def c (c (? . 1) q unsafe-flrandom)) q (382023 . 3)) ((c def c (c (? . 0) q raise-result-error)) q (187157 . 13)) ((c def c (c (? . 30) q dynamic-place*)) q (212599 . 14)) ((c def c (c (? . 0) q impersonator-ephemeron)) q (308501 . 3)) ((c form c (c (? . 2) q for-meta)) q (6374 . 2)) ((c def c (c (? . 50) q bytes-no-nuls?)) q (366516 . 3))))
syntax
(iftest-exprthen-exprelse-expr)
syntax
(lambdaformalsbody...+)

formals=id
      |(id...)
      |(id...+. rest-id)
syntax
(init-restid)
(init-rest)
syntax
(parameterize([parameter-exprvalue-expr]...)
body...+)

parameter-expr:parameter?
procedure
(char->integerchar)->exact-integer?
char:char?
procedure
(argmaxproclst)->any
proc:(->any/creal?)
lst:(and/cpair?list?)
procedure
(read[in])->any
in:input-port?=(current-input-port)
procedure
(sort lst                         
     less-than?                  
    [#:keyextract-key           
     #:cache-keys?cache-keys?])->list?
lst:list?
less-than?:(any/cany/c. -> .any/c)
extract-key:(any/c. -> .any/c)=(lambda(x)x)
cache-keys?:boolean?=#f
struct
(struct color (red green blue alpha))
red:(and/cnatural-number/c(<=/c255))
green:(and/cnatural-number/c(<=/c255))
blue:(and/cnatural-number/c(<=/c255))
alpha:(and/cnatural-number/c(<=/c255))
struct
(structdata-source(connector args extensions)
      #:mutable)
connector:(or/c'postgresql'mysql'sqlite3'odbc)
args:list?
extensions:(listof(list/csymbol?any/c))
parameter
(current-command-line-arguments)->(vectorofstring?)
(current-command-line-argumentsargv)->void?
argv:(vectorof(and/cstring?immutable?))
value
object%:class?

(somethingidthing-expr...)

thing-expr:number?
syntax
(moduleidmodule-pathform...)
syntax
(module*idmodule-pathform...)
(module*id#fform...)
syntax
(module+idform...)
syntax
(#%module-beginform...)
syntax
(#%printing-module-beginform...)
syntax
(#%plain-module-beginform...)
syntax
(#%declaredeclaration-keyword...)

declaration-keyword=#:cross-phase-persistent
syntax
(requirerequire-spec...)

require-spec       =module-path
                  |(only-inrequire-specid-maybe-renamed...)
                  |(except-inrequire-specid...)
                  |(prefix-inprefix-idrequire-spec)
                  |(rename-inrequire-spec[orig-idbind-id]...)
                  |(combine-inrequire-spec...)
                  |(relative-inmodule-pathrequire-spec...)
                  |(only-meta-inphase-levelrequire-spec...)
                  |(for-syntaxrequire-spec...)
                  |(for-templaterequire-spec...)
                  |(for-labelrequire-spec...)
                  |(for-metaphase-levelrequire-spec...)
                  |derived-require-spec
                  
module-path        =root-module-path
                  |(submodroot-module-pathsubmod-path-element...)
                  |(submod"."submod-path-element...)
                  |(submod".."submod-path-element...)
                  
root-module-path   =(quoteid)
                  |rel-string
                  |(librel-string...+)
                  |id
                  |(filestring)
                  |(planetid)
                  |(planetstring)
                  |(planetrel-string
                      (user-stringpkg-stringvers)
                      rel-string...)
                  
submod-path-element=id
                  |".."
                  
id-maybe-renamed   =id
                  |[orig-idbind-id]
                  
phase-level        =exact-integer
                  |#f
                  
vers               =
                  |nat
                  |natminor-vers
                  
minor-vers         =nat
                  |(natnat)
                  |(=nat)
                  |(+nat)
                  |(-nat)

module-path
syntax
(only-inrequire-specid-maybe-renamed...)
syntax
(except-inrequire-specid...)
syntax
(prefix-inprefix-idrequire-spec)
syntax
(rename-inrequire-spec[orig-idbind-id]...)
syntax
(combine-inrequire-spec...)
syntax
(relative-inmodule-pathrequire-spec...)
syntax
(only-meta-inphase-levelrequire-spec...)

(for-metaphase-levelrequire-spec...)

(for-syntaxrequire-spec...)

(for-templaterequire-spec...)

(for-labelrequire-spec...)

derived-require-spec

(quoteid)

rel-string
syntax
(librel-string...+)

id
syntax
(filestring)
syntax
(planetid)
(planetstring)
(planetrel-string(user-stringpkg-stringvers)
rel-string...)
syntax
(submodroot-modulesubmod-path-element...)
(submod"."submod-path-element...)
(submod".."submod-path-element...)
syntax
(local-requirerequire-spec...)
syntax
(provideprovide-spec...)

provide-spec=id
           |(all-defined-out)
           |(all-from-outmodule-path...)
           |(rename-out[orig-idexport-id]...)
           |(except-outprovide-specprovide-spec...)
           |(prefix-outprefix-idprovide-spec)
           |(struct-outid)
           |(combine-outprovide-spec...)
           |(protect-outprovide-spec...)
           |(for-metaphase-levelprovide-spec...)
           |(for-syntaxprovide-spec...)
           |(for-templateprovide-spec...)
           |(for-labelprovide-spec...)
           |derived-provide-spec
           
phase-level =exact-integer
           |#f

id
syntax
(all-defined-out)
syntax
(all-from-outmodule-path...)
syntax
(rename-out[orig-idexport-id]...)
syntax
(except-outprovide-specprovide-spec...)
syntax
(prefix-outprefix-idprovide-spec)
syntax
(struct-outid)
syntax
(combine-outprovide-spec...)
syntax
(protect-outprovide-spec...)

(for-metaphase-levelprovide-spec...)

(for-syntaxprovide-spec...)

(for-templateprovide-spec...)

(for-labelprovide-spec...)

derived-provide-spec
syntax
(for-metaphase-levelrequire-spec...)
syntax
(for-syntaxrequire-spec...)
syntax
(for-templaterequire-spec...)
syntax
(for-labelrequire-spec...)
syntax
(#%requireraw-require-spec...)

raw-require-spec    =phaseless-spec
                   |(for-metaphase-levelphaseless-spec...)
                   |(for-syntaxphaseless-spec...)
                   |(for-templatephaseless-spec...)
                   |(for-labelphaseless-spec...)
                   |(just-metaphase-levelraw-require-spec...)
                   
phase-level         =exact-integer
                   |#f
                   
phaseless-spec      =raw-module-path
                   |(onlyraw-module-pathid...)
                   |(prefixprefix-idraw-module-path)
                   |(all-exceptraw-module-pathid...)
                   |(prefix-all-exceptprefix-id
                       raw-module-pathid...)
                   |(renameraw-module-pathlocal-idexported-id)
                   
raw-module-path     =raw-root-module-path
                   |(submodraw-root-module-pathid...+)
                   |(submod"."id...+)
                   
raw-root-module-path=(quoteid)
                   |rel-string
                   |(librel-string...)
                   |id
                   |(filestring)
                   |(planetrel-string
                       (user-stringpkg-stringvers...))
                   |literal-path
syntax
(#%provideraw-provide-spec...)

raw-provide-spec=phaseless-spec
               |(for-metaphase-levelphaseless-spec)
               |(for-syntaxphaseless-spec)
               |(for-labelphaseless-spec)
               |(protectraw-provide-spec)
               
phase-level     =exact-integer
               |#f
               
phaseless-spec  =id
               |(renamelocal-idexport-id)
               |(structstruct-id(field-id...))
               |(all-fromraw-module-path)
               |(all-from-exceptraw-module-pathid...)
               |(all-defined)
               |(all-defined-exceptid...)
               |(prefix-all-definedprefix-id)
               |(prefix-all-defined-exceptprefix-idid...)
               |(protectphaseless-spec...)
               |(expand(id. datum))
syntax
(matching-identifiers-inregexprequire-spec)
syntax
(subtract-inrequire-specsubtracted-spec...)
syntax
(filtered-inproc-exprrequire-spec)
syntax
(path-uprel-string...)
syntax
(multi-insubs...+)

subs    =sub-path
       |(sub-path...)
       
sub-path=rel-string
       |id
syntax
(matching-identifiers-outregexpprovide-spec)
syntax
(filtered-outproc-exprprovide-spec)
syntax
(quotedatum)
syntax
(#%datum. datum)
syntax
(#%expressionexpr)
syntax
id
syntax
(#%top. id)
syntax
(#%variable-referenceid)
(#%variable-reference(#%top. id))
(#%variable-reference)
syntax
(proc-exprarg...)
syntax
(#%appproc-exprarg...)

arg-expr

keywordarg-expr
syntax
(#%plain-appproc-exprarg-expr...)
(#%plain-app)
syntax
(lambdakw-formalsbody...+)
syntax
(kw-formalsbody...+)

kw-formals=(arg...)
         |(arg...+. rest-id)
         |rest-id
         
arg       =id
         |[iddefault-expr]
         |keywordid
         |keyword[iddefault-expr]

(id...)

(id...+. rest-id)

rest-id

(arg...)

id

[iddefault-expr]

keywordid

keyword[iddefault-expr]

(arg...+. rest-id)
syntax
(case-lambda[formalsbody...+]...)

formals=(id...)
      |(id...+. rest-id)
      |rest-id
syntax
(#%plain-lambdaformalsbody...+)
syntax
(let([idval-expr]...)body...+)
(letproc-id([idinit-expr]...)body...+)
syntax
(let*([idval-expr]...)body...+)
syntax
(letrec([idval-expr]...)body...+)
syntax
(let-values([(id...)val-expr]...)body...+)
syntax
(let*-values([(id...)val-expr]...)body...+)
syntax
(letrec-values([(id...)val-expr]...)body...+)
syntax
(let-syntax([idtrans-expr]...)body...+)
syntax
(letrec-syntax([idtrans-expr]...)body...+)
syntax
(let-syntaxes([(id...)trans-expr]...)body...+)
syntax
(letrec-syntaxes([(id...)trans-expr]...)body...+)
syntax
(letrec-syntaxes+values([(trans-id...)trans-expr]...)
([(val-id...)val-expr]...)
body...+)
syntax
(local[definition...]body...+)
syntax
(shared([idexpr]...)body...+)
syntax
(iftest-exprthen-exprelse-expr)
syntax
(condcond-clause...)

cond-clause=[test-exprthen-body...+]
          |[elsethen-body...+]
          |[test-expr=>proc-expr]
          |[test-expr]

[test-exprthen-body...+]

[test-expr=>proc-expr]

[test-expr]
syntax
else
syntax
=>
syntax
(andexpr...)
syntax
(orexpr...)
syntax
(caseval-exprcase-clause...)

case-clause=[(datum...)then-body...+]
          |[elsethen-body...+]
syntax
(defineidexpr)
(define(headargs)body...+)

head=id
   |(headargs)
   
args=arg...
   |arg....rest-id
   
arg =arg-id
   |[arg-iddefault-expr]
   |keywordarg-id
   |keyword[arg-iddefault-expr]
syntax
(define-values(id...)expr)
syntax
(define-syntaxidexpr)
(define-syntax(headargs)body...+)
syntax
(define-syntaxes(id...)expr)
syntax
(define-for-syntaxidexpr)
(define-for-syntax(headargs)body...+)
syntax
(define-values-for-syntax(id...)expr)
syntax
(define-require-syntaxidproc-expr)
(define-require-syntax(idargs...)body...+)
procedure
(syntax-local-require-introducestx)->syntax?
stx:syntax?
syntax
(define-provide-syntaxidproc-expr)
(define-provide-syntax(idargs...)body...+)
procedure
(syntax-local-provide-introducestx)->syntax?
stx:syntax?
syntax
(beginform...)
(beginexpr...+)
syntax
(begin0expr...+)
syntax
(begin-for-syntaxform...)
syntax
(whentest-exprbody...+)
syntax
(unlesstest-exprbody...+)
syntax
(set!idexpr)
syntax
(set!-values(id...)expr)
syntax
(for(for-clause...)body-or-break...body)

for-clause   =[idseq-expr]
            |[(id...)seq-expr]
            |#:whenguard-expr
            |#:unlessguard-expr
            |break-clause
            
break-clause =#:breakguard-expr
            |#:finalguard-expr
            
body-or-break=body
            |break-clause

seq-expr:sequence?
syntax
(for/list(for-clause...)body-or-break...body)
syntax
(for/vectormaybe-length(for-clause...)body-or-break...body)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
syntax
(for/hash(for-clause...)body-or-break...body)
syntax
(for/hasheq(for-clause...)body-or-break...body)
syntax
(for/hasheqv(for-clause...)body-or-break...body)
syntax
(for/and(for-clause...)body-or-break...body)
syntax
(for/or(for-clause...)body-or-break...body)
syntax
(for/sum(for-clause...)body-or-break...body)
syntax
(for/product(for-clause...)body-or-break...body)
syntax
(for/lists(id...)(for-clause...)body-or-break...body)
syntax
(for/first(for-clause...)body-or-break...body)
syntax
(for/last(for-clause...)body-or-break...body)
syntax
(for/fold([accum-idinit-expr]...)(for-clause...)
body-or-break...body)
syntax
(for*(for-clause...)body-or-break...body)
syntax
(for*/list(for-clause...)body-or-break...body)
syntax
(for*/lists(id...)(for-clause...)body-or-break...body)
syntax
(for*/vectormaybe-length(for-clause...)body-or-break...body)
syntax
(for*/hash(for-clause...)body-or-break...body)
syntax
(for*/hasheq(for-clause...)body-or-break...body)
syntax
(for*/hasheqv(for-clause...)body-or-break...body)
syntax
(for*/and(for-clause...)body-or-break...body)
syntax
(for*/or(for-clause...)body-or-break...body)
syntax
(for*/sum(for-clause...)body-or-break...body)
syntax
(for*/product(for-clause...)body-or-break...body)
syntax
(for*/first(for-clause...)body-or-break...body)
syntax
(for*/last(for-clause...)body-or-break...body)
syntax
(for*/fold([accum-idinit-expr]...)(for-clause...)
body-or-break...body)
syntax
(for/fold/derivedorig-datum
([accum-idinit-expr]...)(for-clause...)
body-or-break...body)
syntax
(for*/fold/derivedorig-datum
([accum-idinit-expr]...)(for-clause...)
body-or-break...body)
syntax
(define-sequence-syntaxid
expr-transform-expr
clause-transform-expr)

expr-transform-expr:(or/c(->identifier?)
                        (syntax?. -> .syntax?))
clause-transform-expr:(syntax?. -> .syntax?)
syntax
(:do-in([(outer-id...)outer-expr]...)
outer-check
([loop-idloop-expr]...)
pos-guard
([(inner-id...)inner-expr]...)
pre-guard
post-guard
(loop-arg...))
procedure
(for-clause-syntax-protectstx)->syntax?
stx:syntax?
syntax
(do([idinit-exprstep-expr-maybe]...)
(stop?-exprfinish-expr...)
expr...)

step-expr-maybe=
              |step-expr
syntax
(with-continuation-markkey-exprval-exprresult-expr)
syntax
(quasiquotedatum)
syntax
unquote
syntax
unquote-splicing
syntax
(quote-syntaxdatum)
syntax
(#%top-interaction. form)
syntax
(blockdefn-or-expr...)
syntax
(#%stratified-bodydefn-or-expr...)
syntax
(begin-encourage-inlineform...)
syntax
(define-inlineidexpr)
(define-inline(headargs)body...+)

head=id
   |(headargs)
   
args=arg...
   |arg....rest-id
   
arg =arg-id
   |[arg-iddefault-expr]
   |keywordarg-id
   |keyword[arg-iddefault-expr]
syntax
(lazy-require[module-path(fun-import...)]...)

fun-import=fun-id
         |(orig-fun-idfun-id)
procedure
(boolean?v)->boolean?
v:any/c
procedure
(notv)->boolean?
v:any/c
procedure
(equal?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(eqv?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(eq?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(equal?/recurv1v2recur-proc)->boolean?
v1:any/c
v2:any/c
recur-proc:(any/cany/c->any/c)
procedure
(immutable?v)->boolean?
v:any/c
value
gen:equal+hash:any/c
value
prop:equal+hash:struct-type-property?
value
true:boolean?
value
false:boolean?
procedure
(symbol=?ab)->boolean?
a:symbol?
b:symbol?
procedure
(boolean=?ab)->boolean?
a:boolean?
b:boolean?
procedure
(false?v)->boolean?
v:any/c
syntax
(nandexpr...)
syntax
(norexpr...)
syntax
(impliesexpr1expr2)
procedure
(xorb1b2)->any
b1:any/c
b2:any/c
procedure
(number?v)->boolean?
v:any/c
procedure
(complex?v)->boolean?
v:any/c
procedure
(real?v)->boolean?
v:any/c
procedure
(rational?v)->boolean?
v:any/c
procedure
(integer?v)->boolean?
v:any/c
procedure
(exact-integer?v)->boolean?
v:any/c
procedure
(exact-nonnegative-integer?v)->boolean?
v:any/c
procedure
(exact-positive-integer?v)->boolean?
v:any/c
procedure
(inexact-real?v)->boolean?
v:any/c
procedure
(fixnum?v)->boolean?
v:any/c
procedure
(flonum?v)->boolean?
v:any/c
procedure
(double-flonum?v)->boolean?
v:any/c
procedure
(single-flonum?v)->boolean?
v:any/c
procedure
(zero?z)->boolean?
z:number?
procedure
(positive?x)->boolean?
x:real?
procedure
(negative?x)->boolean?
x:real?
procedure
(even?n)->boolean?
n:integer?
procedure
(odd?n)->boolean?
n:integer?
procedure
(exact?z)->boolean?
z:number?
procedure
(inexact?z)->boolean?
z:number?
procedure
(inexact->exactz)->exact?
z:number?
procedure
(exact->inexactz)->inexact?
z:number?
procedure
(real->single-flonumx)->single-flonum?
x:real?
procedure
(real->double-flonumx)->flonum?
x:real?
procedure
(+z...)->number?
z:number?
procedure
(-z)->number?
z:number?
(-zw...+)->number?
z:number?
w:number?
procedure
(*z...)->number?
z:number?
procedure
(/z)->number?
z:number?
(/zw...+)->number?
z:number?
w:number?
procedure
(quotientnm)->integer?
n:integer?
m:integer?
procedure
(remaindernm)->integer?
n:integer?
m:integer?
procedure
(quotient/remaindernm)->integer?integer?
n:integer?
m:integer?
procedure
(modulonm)->integer?
n:integer?
m:integer?
procedure
(add1z)->number?
z:number?
procedure
(sub1z)->number?
z:number?
procedure
(absx)->number?
x:real?
procedure
(maxx...+)->real?
x:real?
procedure
(minx...+)->real?
x:real?
procedure
(gcdn...)->rational?
n:rational?
procedure
(lcmn...)->rational?
n:rational?
procedure
(roundx)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(floorx)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(ceilingx)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(truncatex)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(numeratorq)->integer?
q:rational?
procedure
(denominatorq)->integer?
q:rational?
procedure
(rationalizextolerance)->real?
x:real?
tolerance:real?
procedure
(=zw...+)->boolean?
z:number?
w:number?
procedure
(<xy...+)->boolean?
x:real?
y:real?
procedure
(<=xy...+)->boolean?
x:real?
y:real?
procedure
(>xy...+)->boolean?
x:real?
y:real?
procedure
(>=xy...+)->boolean?
x:real?
y:real?
procedure
(sqrtz)->number?
z:number?
procedure
(integer-sqrtn)->complex?
n:integer?
procedure
(integer-sqrt/remaindern)->complex?integer?
n:integer?
procedure
(exptzw)->number?
z:number?
w:number?
procedure
(expz)->number?
z:number?
procedure
(logz)->number?
z:number?
procedure
(sinz)->number?
z:number?
procedure
(cosz)->number?
z:number?
procedure
(tanz)->number?
z:number?
procedure
(asinz)->number?
z:number?
procedure
(acosz)->number?
z:number?
procedure
(atanz)->number?
z:number?
(atanyx)->number?
y:real?
x:real?
procedure
(make-rectangularxy)->number?
x:real?
y:real?
procedure
(make-polarmagnitudeangle)->number?
magnitude:real?
angle:real?
procedure
(real-partz)->real?
z:number?
procedure
(imag-partz)->real?
z:number?
procedure
(magnitudez)->(and/creal?(not/cnegative?))
z:number?
procedure
(anglez)->real?
z:number?
procedure
(bitwise-iorn...)->exact-integer?
n:exact-integer?
procedure
(bitwise-andn...)->exact-integer?
n:exact-integer?
procedure
(bitwise-xorn...)->exact-integer?
n:exact-integer?
procedure
(bitwise-notn)->exact-integer?
n:exact-integer?
procedure
(bitwise-bit-set?nm)->boolean?
n:exact-integer?
m:exact-nonnegative-integer?
procedure
(bitwise-bit-fieldnstartend)->exact-integer?
n:exact-integer?
start:exact-nonnegative-integer?
end:(and/cexact-nonnegative-integer?
        (start. <= .end))
procedure
(arithmetic-shiftnm)->exact-integer?
n:exact-integer?
m:exact-integer?
procedure
(integer-lengthn)->exact-integer?
n:exact-integer?
procedure
(randomk[rand-gen])->exact-nonnegative-integer?
k:(integer-in14294967087)
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
(random[rand-gen])->(and/creal?inexact?(>/c0)(</c1))
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
procedure
(random-seedk)->void?
k:(integer-in1(sub1(expt231)))
procedure
(make-pseudo-random-generator)->pseudo-random-generator?
procedure
(pseudo-random-generator?v)->boolean?
v:any/c
parameter
(current-pseudo-random-generator)->pseudo-random-generator?
(current-pseudo-random-generatorrand-gen)->void?
rand-gen:pseudo-random-generator?
procedure
(pseudo-random-generator->vectorrand-gen)
->pseudo-random-generator-vector?
rand-gen:pseudo-random-generator?
procedure
(vector->pseudo-random-generatorvec)
->pseudo-random-generator?
vec:pseudo-random-generator-vector?
procedure
(vector->pseudo-random-generator!rand-gen 
                                vec)    ->void?
rand-gen:pseudo-random-generator?
vec:pseudo-random-generator-vector?
procedure
(pseudo-random-generator-vector?v)->boolean?
v:any/c
procedure
(number->stringz[radix])->string?
z:number?
radix:(or/c281016)=10
procedure
(string->numbers[radix])->(or/cnumber?#f)
s:string?
radix:(integer-in216)=10
procedure
(real->decimal-stringn[decimal-digits])->string?
n:real?
decimal-digits:exact-nonnegative-integer?=2
procedure
(integer-bytes->integer bstr        
                       signed?     
                      [big-endian? 
                       start       
                       end])      ->exact-integer?
bstr:bytes?
signed?:any/c
big-endian?:any/c=(system-big-endian?)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(integer->integer-bytes n           
                       size-n      
                       signed?     
                      [big-endian? 
                       dest-bstr   
                       start])    ->bytes?
n:exact-integer?
size-n:(or/c248)
signed?:any/c
big-endian?:any/c=(system-big-endian?)
dest-bstr:(and/cbytes?(not/cimmutable?))
         =(make-bytessize-n)
start:exact-nonnegative-integer?=0
procedure
(floating-point-bytes->real bstr        
                          [big-endian? 
                           start       
                           end])      ->flonum?
bstr:bytes?
big-endian?:any/c=(system-big-endian?)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(real->floating-point-bytes x           
                           size-n      
                          [big-endian? 
                           dest-bstr   
                           start])    ->bytes?
x:real?
size-n:(or/c48)
big-endian?:any/c=(system-big-endian?)
dest-bstr:(and/cbytes?(not/cimmutable?))
         =(make-bytessize-n)
start:exact-nonnegative-integer?=0
procedure
(system-big-endian?)->boolean?
value
pi:flonum?
value
pi.f:single-flonum?
procedure
(degrees->radiansx)->real?
x:real?
procedure
(radians->degreesx)->real?
x:real?
procedure
(sqrz)->number?
z:number?
procedure
(sgnx)->(or/c10-11.00.0-1.0)
x:real?
procedure
(conjugatez)->number?
z:number?
procedure
(sinhz)->number?
z:number?
procedure
(coshz)->number?
z:number?
procedure
(tanhz)->number?
z:number?
procedure
(exact-roundx)->exact-integer?
x:rational?
procedure
(exact-floorx)->exact-integer?
x:rational?
procedure
(exact-ceilingx)->exact-integer?
x:rational?
procedure
(exact-truncatex)->exact-integer?
x:rational?
procedure
(order-of-magnituder)->(and/cexact?integer?)
r:(and/creal?positive?)
procedure
(nan?x)->boolean?
x:real?
procedure
(infinite?x)->boolean?
x:real?
procedure
(fl+ab)->flonum?
a:flonum?
b:flonum?
procedure
(fl-ab)->flonum?
a:flonum?
b:flonum?
procedure
(fl*ab)->flonum?
a:flonum?
b:flonum?
procedure
(fl/ab)->flonum?
a:flonum?
b:flonum?
procedure
(flabsa)->flonum?
a:flonum?
procedure
(fl=ab)->boolean?
a:flonum?
b:flonum?
procedure
(fl<ab)->boolean?
a:flonum?
b:flonum?
procedure
(fl>ab)->boolean?
a:flonum?
b:flonum?
procedure
(fl<=ab)->boolean?
a:flonum?
b:flonum?
procedure
(fl>=ab)->boolean?
a:flonum?
b:flonum?
procedure
(flminab)->flonum?
a:flonum?
b:flonum?
procedure
(flmaxab)->flonum?
a:flonum?
b:flonum?
procedure
(flrounda)->flonum?
a:flonum?
procedure
(flfloora)->flonum?
a:flonum?
procedure
(flceilinga)->flonum?
a:flonum?
procedure
(fltruncatea)->flonum?
a:flonum?
procedure
(flsina)->flonum?
a:flonum?
procedure
(flcosa)->flonum?
a:flonum?
procedure
(fltana)->flonum?
a:flonum?
procedure
(flasina)->flonum?
a:flonum?
procedure
(flacosa)->flonum?
a:flonum?
procedure
(flatana)->flonum?
a:flonum?
procedure
(flloga)->flonum?
a:flonum?
procedure
(flexpa)->flonum?
a:flonum?
procedure
(flsqrta)->flonum?
a:flonum?
procedure
(flexptab)->flonum?
a:flonum?
b:flonum?
procedure
(->fla)->flonum?
a:exact-integer?
procedure
(fl->exact-integera)->exact-integer?
a:flonum?
procedure
(make-flrectangularab)
->(and/ccomplex?inexact?(not/creal?))
a:flonum?
b:flonum?
procedure
(flreal-parta)->flonum?
a:(and/ccomplex?inexact?(not/creal?))
procedure
(flimag-parta)->flonum?
a:(and/ccomplex?inexact?(not/creal?))
procedure
(flrandomrand-gen)->(andflonum?(>/c0)(</c1))
rand-gen:pseudo-random-generator?
procedure
(flvector?v)->boolean?
v:any/c
procedure
(flvectorx...)->flvector?
x:flonum?
procedure
(make-flvectorsize[x])->flvector?
size:exact-nonnegative-integer?
x:flonum?=0.0
procedure
(flvector-lengthvec)->exact-nonnegative-integer?
vec:flvector?
procedure
(flvector-refvecpos)->flonum?
vec:flvector?
pos:exact-nonnegative-integer?
procedure
(flvector-set!vecposx)->flonum?
vec:flvector?
pos:exact-nonnegative-integer?
x:flonum?
procedure
(flvector-copyvec[startend])->flvector?
vec:flvector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(in-flvectorvec[startstopstep])->sequence?
vec:flvector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
syntax
(for/flvectormaybe-length(for-clause...)body...)
syntax
(for*/flvectormaybe-length(for-clause...)body...)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
fill-expr:flonum?
procedure
(shared-flvectorx...)->flvector?
x:flonum?
procedure
(make-shared-flvectorsize[x])->flvector?
size:exact-nonnegative-integer?
x:flonum?=0.0
procedure
(fx+ab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx-ab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx*ab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxquotientab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxremainderab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxmoduloab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxabsa)->fixnum?
a:fixnum?
procedure
(fxandab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxiorab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxxorab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxnota)->fixnum?
a:fixnum?
procedure
(fxlshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxrshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx=ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx<ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx>ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx<=ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx>=ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(fxminab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxmaxab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx->fla)->flonum?
a:fixnum?
procedure
(fl->fxa)->fixnum?
a:flonum?
procedure
(fxvector?v)->boolean?
v:any/c
procedure
(fxvectorx...)->fxvector?
x:fixnum?
procedure
(make-fxvectorsize[x])->fxvector?
size:exact-nonnegative-integer?
x:fixnum?=0
procedure
(fxvector-lengthvec)->exact-nonnegative-integer?
vec:fxvector?
procedure
(fxvector-refvecpos)->fixnum?
vec:fxvector?
pos:exact-nonnegative-integer?
procedure
(fxvector-set!vecposx)->fixnum?
vec:fxvector?
pos:exact-nonnegative-integer?
x:fixnum?
procedure
(fxvector-copyvec[startend])->fxvector?
vec:fxvector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(in-fxvectorvec[startstopstep])->sequence?
vec:fxvector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
syntax
(for/fxvectormaybe-length(for-clause...)body...)
syntax
(for*/fxvectormaybe-length(for-clause...)body...)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
fill-expr:fixnum?
procedure
(shared-fxvectorx...)->fxvector?
x:fixnum?
procedure
(make-shared-fxvectorsize[x])->fxvector?
size:exact-nonnegative-integer?
x:fixnum?=0
procedure
(extflonum?v)->boolean?
v:any/c
procedure
(extflonum-available?)->boolean?
procedure
(extfl+ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extfl-ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extfl*ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extfl/ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extflabsa)->extflonum?
a:extflonum?
procedure
(extfl=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl<ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl>ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl<=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl>=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extflminab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extflmaxab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extflrounda)->extflonum?
a:extflonum?
procedure
(extflfloora)->extflonum?
a:extflonum?
procedure
(extflceilinga)->extflonum?
a:extflonum?
procedure
(extfltruncatea)->extflonum?
a:extflonum?
procedure
(extflsina)->extflonum?
a:extflonum?
procedure
(extflcosa)->extflonum?
a:extflonum?
procedure
(extfltana)->extflonum?
a:extflonum?
procedure
(extflasina)->extflonum?
a:extflonum?
procedure
(extflacosa)->extflonum?
a:extflonum?
procedure
(extflatana)->extflonum?
a:extflonum?
procedure
(extflloga)->extflonum?
a:extflonum?
procedure
(extflexpa)->extflonum?
a:extflonum?
procedure
(extflsqrta)->extflonum?
a:extflonum?
procedure
(extflexptab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(->extfla)->extflonum?
a:exact-integer?
procedure
(extfl->exact-integera)->exact-integer?
a:extflonum?
procedure
(real->extfla)->extflonum?
a:real?
procedure
(extfl->exacta)->(and/creal?exact?)
a:real?
procedure
(extfl->inexacta)->flonum?
a:real?
procedure
(extflvector?v)->boolean?
v:any/c
procedure
(extflvectorx...)->extflvector?
x:extflonum?
procedure
(make-extflvectorsize[x])->extflvector?
size:exact-nonnegative-integer?
x:extflonum?=0.0
procedure
(extflvector-lengthvec)->exact-nonnegative-integer?
vec:extflvector?
procedure
(extflvector-refvecpos)->extflonum?
vec:extflvector?
pos:exact-nonnegative-integer?
procedure
(extflvector-set!vecposx)->extflonum?
vec:extflvector?
pos:exact-nonnegative-integer?
x:extflonum?
procedure
(extflvector-copyvec[startend])->extflvector?
vec:extflvector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(in-extflvectorvec[startstopstep])->sequence?
vec:extflvector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
syntax
(for/extflvectormaybe-length(for-clause...)body...)
syntax
(for*/extflvectormaybe-length(for-clause...)body...)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
fill-expr:extflonum?
procedure
(make-shared-extflvectorsize[x])->extflvector?
size:exact-nonnegative-integer?
x:extflonum?=0.0
procedure
(floating-point-bytes->extfl bstr        
                           [big-endian? 
                            start       
                            end])      ->extflonum?
bstr:bytes?
big-endian?:any/c=(system-big-endian?)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(extfl->floating-point-bytes x           
                           [big-endian? 
                            dest-bstr   
                            start])    ->bytes?
x:extflonum?
big-endian?:any/c=(system-big-endian?)
dest-bstr:(and/cbytes?(not/cimmutable?))
         =(make-bytes10)
start:exact-nonnegative-integer?=0
procedure
(string?v)->boolean?
v:any/c
procedure
(make-stringk[char])->string?
k:exact-nonnegative-integer?
char:char?=#\nul
procedure
(stringchar...)->string?
char:char?
procedure
(string->immutable-stringstr)->(and/cstring?immutable?)
str:string?
procedure
(string-lengthstr)->exact-nonnegative-integer?
str:string?
procedure
(string-refstrk)->char?
str:string?
k:exact-nonnegative-integer?
procedure
(string-set!strkchar)->void?
str:(and/cstring?(not/cimmutable?))
k:exact-nonnegative-integer?
char:char?
procedure
(substringstrstart[end])->string?
str:string?
start:exact-nonnegative-integer?
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string-copystr)->string?
str:string?
procedure
(string-copy! dest       
             dest-start 
             src        
            [src-start  
             src-end]) ->void?
dest:(and/cstring?(not/cimmutable?))
dest-start:exact-nonnegative-integer?
src:string?
src-start:exact-nonnegative-integer?=0
src-end:exact-nonnegative-integer?=(string-lengthsrc)
procedure
(string-fill!destchar)->void?
dest:(and/cstring?(not/cimmutable?))
char:char?
procedure
(string-appendstr...)->string?
str:string?
procedure
(string->liststr)->(listofchar?)
str:string?
procedure
(list->stringlst)->string?
lst:(listofchar?)
procedure
(build-stringnproc)->string?
n:exact-nonnegative-integer?
proc:(exact-nonnegative-integer?. -> .char?)
procedure
(string=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string<?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string<=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string>?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string>=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-ci=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-ci<?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-ci<=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-ci>?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-ci>=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-upcasestr)->string?
str:string?
procedure
(string-downcasestring)->string?
string:string?
procedure
(string-titlecasestring)->string?
string:string?
procedure
(string-foldcasestring)->string?
string:string?
procedure
(string-normalize-nfdstring)->string?
string:string?
procedure
(string-normalize-nfkdstring)->string?
string:string?
procedure
(string-normalize-nfcstring)->string?
string:string?
procedure
(string-normalize-nfkcstring)->string?
string:string?
procedure
(string-locale=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale<?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale>?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale-ci=?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale-ci<?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale-ci>?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale-upcasestring)->string?
string:string?
procedure
(string-locale-downcasestring)->string?
string:string?
procedure
(string-append*str...strs)->string?
str:string?
strs:(listofstring?)
procedure
(string-join strs                        
           [sep                         
            #:before-firstbefore-first 
            #:before-lastbefore-last   
            #:after-lastafter-last])  ->string?
strs:(listofstring?)
sep:string?=" "
before-first:string?=""
before-last:string?=sep
after-last:string?=""
procedure
(string-normalize-spaces str                 
                       [sep                 
                        space               
                        #:trim?trim?       
                        #:repeat?repeat?])->string?
str:string?
sep:(or/cstring?regexp?)=#px"\\s+"
space:string?=" "
trim?:any/c=#t
repeat?:any/c=#f
procedure
(string-replacestrfromto[#:all?all?])->string?
str:string?
from:(or/cstring?regexp?)
to:string?
all?:any/c=#t
procedure
(string-split str                 
            [sep                 
             #:trim?trim?       
             #:repeat?repeat?])->(listofstring?)
str:string?
sep:(or/cstring?regexp?)=#px"\\s+"
trim?:any/c=#t
repeat?:any/c=#f
procedure
(string-trim str                 
           [sep                 
            #:left?left?       
            #:right?right?     
            #:repeat?repeat?])->string?
str:string?
sep:(or/cstring?regexp?)=#px"\\s+"
left?:any/c=#t
right?:any/c=#t
repeat?:any/c=#f
procedure
(~a v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=""
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?=""
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~v v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~s v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~e v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~r x                                 
  [#:signsign                       
   #:basebase                       
   #:precisionprecision             
   #:notationnotation               
   #:format-exponentformat-exponent 
   #:min-widthmin-width             
   #:pad-stringpad-string])        ->string?
x:rational?
sign:(or/c#f'+'++'parens
         (let([ind(or/cstring?(list/cstring?string?))])
         (list/cindindind)))
    =#f
base:(or/c(integer-in236)(list/c'up(integer-in236)))
    =10
precision:(or/cexact-nonnegative-integer?             =6
              (list/c'=exact-nonnegative-integer?))
notation:(or/c'positional'exponential
             (->rational?(or/c'positional'exponential)))
        ='positional
format-exponent:(or/c#fstring?(->exact-integer?string?))
               =#f
min-width:exact-positive-integer?=1
pad-string:non-empty-string?=" "
procedure
(~.a v                                     
    ...                                   
   [#:separatorseparator                 
    #:widthwidth                         
    #:max-widthmax-width                 
    #:min-widthmin-width                 
    #:limit-markerlimit-marker           
    #:alignalign                         
    #:pad-stringpad-string               
    #:left-pad-stringleft-pad-string     
    #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=""
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?=""
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~.v v                                     
    ...                                   
   [#:separatorseparator                 
    #:widthwidth                         
    #:max-widthmax-width                 
    #:min-widthmin-width                 
    #:limit-markerlimit-marker           
    #:alignalign                         
    #:pad-stringpad-string               
    #:left-pad-stringleft-pad-string     
    #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~.s v                                     
    ...                                   
   [#:separatorseparator                 
    #:widthwidth                         
    #:max-widthmax-width                 
    #:min-widthmin-width                 
    #:limit-markerlimit-marker           
    #:alignalign                         
    #:pad-stringpad-string               
    #:left-pad-stringleft-pad-string     
    #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(bytes?v)->boolean?
v:any/c
procedure
(make-bytesk[b])->bytes?
k:exact-nonnegative-integer?
b:byte?=0
procedure
(bytesb...)->bytes?
b:byte?
procedure
(bytes->immutable-bytesbstr)->(and/cbytes?immutable?)
bstr:bytes?
procedure
(byte?v)->boolean?
v:any/c
procedure
(bytes-lengthbstr)->exact-nonnegative-integer?
bstr:bytes?
procedure
(bytes-refbstrk)->byte?
bstr:bytes?
k:exact-nonnegative-integer?
procedure
(bytes-set!bstrkb)->void?
bstr:(and/cbytes?(not/cimmutable?))
k:exact-nonnegative-integer?
b:byte?
procedure
(subbytesbstrstart[end])->bytes?
bstr:bytes?
start:exact-nonnegative-integer?
end:exact-nonnegative-integer?=(bytes-lengthstr)
procedure
(bytes-copybstr)->bytes?
bstr:bytes?
procedure
(bytes-copy! dest       
            dest-start 
            src        
           [src-start  
            src-end]) ->void?
dest:(and/cbytes?(not/cimmutable?))
dest-start:exact-nonnegative-integer?
src:bytes?
src-start:exact-nonnegative-integer?=0
src-end:exact-nonnegative-integer?=(bytes-lengthsrc)
procedure
(bytes-fill!destb)->void?
dest:(and/cbytes?(not/cimmutable?))
b:byte?
procedure
(bytes-appendbstr...)->bytes?
bstr:bytes?
procedure
(bytes->listbstr)->(listofbyte?)
bstr:bytes?
procedure
(list->byteslst)->bytes?
lst:(listofbyte?)
procedure
(make-shared-bytesk[b])->bytes?
k:exact-nonnegative-integer?
b:byte?=0
procedure
(shared-bytesb...)->bytes?
b:byte?
procedure
(bytes=?bstr1bstr2...+)->boolean?
bstr1:bytes?
bstr2:bytes?
procedure
(bytes<?bstr1bstr2...+)->boolean?
bstr1:bytes?
bstr2:bytes?
procedure
(bytes>?bstr1bstr2...+)->boolean?
bstr1:bytes?
bstr2:bytes?
procedure
(bytes->string/utf-8bstr[err-charstartend])->string?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes->string/locale bstr     
                    [err-char 
                     start    
                     end])   ->string?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes->string/latin-1 bstr     
                     [err-char 
                      start    
                      end])   ->string?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(string->bytes/utf-8str[err-bytestartend])->bytes?
str:string?
err-byte:(or/c#fbyte?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string->bytes/localestr[err-bytestartend])->bytes?
str:string?
err-byte:(or/c#fbyte?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string->bytes/latin-1 str      
                     [err-byte 
                      start    
                      end])   ->bytes?
str:string?
err-byte:(or/c#fbyte?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string-utf-8-lengthstr[startend])->exact-nonnegative-integer?
str:string?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(bytes-utf-8-lengthbstr[err-charstartend])
->exact-nonnegative-integer?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes-utf-8-refbstr[skiperr-charstartend])->char?
bstr:bytes?
skip:exact-nonnegative-integer?=0
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes-utf-8-index bstr     
                 [skip     
                  err-char 
                  start    
                  end])   ->exact-nonnegative-integer?
bstr:bytes?
skip:exact-nonnegative-integer?=0
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes-open-converterfrom-nameto-name)->bytes-converter?
from-name:string?
to-name:string?
procedure
(bytes-close-converterconverter)->void
converter:bytes-converter?
procedure
(bytes-convert converter     
              src-bstr      
             [src-start-pos 
              src-end-pos   
              dest-bstr     
              dest-start-pos
              dest-end-pos])
->(or/cbytes?exact-nonnegative-integer?)
    exact-nonnegative-integer?
    (or/c'complete'continues'aborts'error)
converter:bytes-converter?
src-bstr:bytes?
src-start-pos:exact-nonnegative-integer?=0
src-end-pos:exact-nonnegative-integer?
           =(bytes-lengthsrc-bstr)
dest-bstr:(or/cbytes?#f)=#f
dest-start-pos:exact-nonnegative-integer?=0
dest-end-pos:(or/cexact-nonnegative-integer?#f)
            =(anddest-bstr
                 (bytes-lengthdest-bstr))
procedure
(bytes-convert-end converter     
                 [dest-bstr     
                  dest-start-pos
                  dest-end-pos])
->(or/cbytes?exact-nonnegative-integer?)
    (or/c'complete'continues)
converter:bytes-converter?
dest-bstr:(or/cbytes?#f)=#f
dest-start-pos:exact-nonnegative-integer?=0
dest-end-pos:(or/cexact-nonnegative-integer?#f)
            =(anddest-bstr
                 (bytes-lengthdest-bstr))
procedure
(bytes-converter?v)->boolean?
v:any/c
procedure
(locale-string-encoding)->any
procedure
(bytes-append*str...strs)->bytes?
str:bytes?
strs:(listofbytes?)
procedure
(bytes-joinstrssep)->bytes?
strs:(listofbytes?)
sep:bytes?
procedure
(char?v)->boolean?
v:any/c
procedure
(char->integerchar)->exact-integer?
char:char?
procedure
(integer->chark)->char?
k:(and/cexact-integer?
      (or/c(integer-in055295)
      (integer-in573441114111)))
procedure
(char-utf-8-lengthchar)->(integer-in16)
char:char?
procedure
(char=?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char<?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char<=?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char>?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char>=?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char-ci=?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char-ci<?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char-ci<=?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char-ci>?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char-ci>=?char1char2...+)->boolean?
char1:char?
char2:char?
procedure
(char-alphabetic?char)->boolean?
char:char?
procedure
(char-lower-case?char)->boolean?
char:char?
procedure
(char-upper-case?char)->boolean?
char:char?
procedure
(char-title-case?char)->boolean?
char:char?
procedure
(char-numeric?char)->boolean?
char:char?
procedure
(char-symbolic?char)->boolean?
char:char?
procedure
(char-punctuation?char)->boolean?
char:char?
procedure
(char-graphic?char)->boolean?
char:char?
procedure
(char-whitespace?char)->boolean?
char:char?
procedure
(char-blank?char)->boolean?
char:char?
procedure
(char-iso-control?char)->boolean?
char:char?
procedure
(char-general-categorychar)->symbol?
char:char?
procedure
(make-known-char-range-list)
->(listof(list/cexact-nonnegative-integer?
    exact-nonnegative-integer?
    boolean?))
procedure
(char-upcasechar)->char?
char:char?
procedure
(char-downcasechar)->char?
char:char?
procedure
(char-titlecasechar)->char?
char:char?
procedure
(char-foldcasechar)->char?
char:char?
procedure
(symbol?v)->boolean?
v:any/c
procedure
(symbol-interned?sym)->boolean?
sym:symbol?
procedure
(symbol-unreadable?sym)->boolean?
sym:symbol?
procedure
(symbol->stringsym)->string?
sym:symbol?
procedure
(string->symbolstr)->symbol?
str:string?
procedure
(string->uninterned-symbolstr)->symbol?
str:string?
procedure
(string->unreadable-symbolstr)->symbol?
str:string?
procedure
(gensym[base])->symbol?
base:(or/cstring?symbol?)="g"
procedure
(symbol<?a-symb-sym...)->boolean?
a-sym:symbol?
b-sym:symbol?
procedure
(regexp?v)->boolean?
v:any/c
procedure
(pregexp?v)->boolean?
v:any/c
procedure
(byte-regexp?v)->boolean?
v:any/c
procedure
(byte-pregexp?v)->boolean?
v:any/c
procedure
(regexpstr)->regexp?
str:string?
procedure
(pregexpstring)->pregexp?
string:string?
procedure
(byte-regexpbstr)->byte-regexp?
bstr:bytes?
procedure
(byte-pregexpbstr)->byte-pregexp?
bstr:bytes?
procedure
(regexp-quotestr[case-sensitive?])->string?
str:string?
case-sensitive?:any/c=#t
(regexp-quotebstr[case-sensitive?])->bytes?
bstr:bytes?
case-sensitive?:any/c=#t
procedure
(regexp-max-lookbehindpattern)->exact-nonnegative-integer?
pattern:(or/cregexp?byte-regexp?)
procedure
(regexp-match pattern       
             input         
            [start-pos     
             end-pos       
             output-port   
             input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (or(string?input)(path?input)))
    (or/c#f(cons/cstring?(listof(or/cstring?#f))))
    (or/c#f(cons/cbytes?(listof(or/cbytes?#f)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match* pattern                    
              input                      
             [start-pos                  
              end-pos                    
              input-prefix               
              #:match-selectmatch-select
              #:gap-select?gap-select]) 
->(if(and(or(string?pattern)(regexp?pattern))
    (or(string?input)(path?input)))
    (listof(or/cstring?(listof(or/c#fstring?))))
    (listof(or/cbytes?(listof(or/c#fbytes?)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
match-select:(or/c(list?. -> .(or/cany/clist?))=car
                 #f)
gap-select:any/c=#f
procedure
(regexp-try-match pattern       
                 input         
                [start-pos     
                 end-pos       
                 output-port   
                 input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (string?input))
    (or/c#f(cons/cstring?(listof(or/cstring?#f))))
    (or/c#f(cons/cbytes?(listof(or/cbytes?#f)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-positions pattern       
                       input         
                      [start-pos     
                       end-pos       
                       output-port   
                       input-prefix])
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-positions* pattern                      
                        input                        
                       [start-pos                    
                        end-pos                      
                        input-prefix                 
                        #:match-selectmatch-select])
->(or/c(listof(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?))
    (listof(listof(or/c#f(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
match-select:(list?. -> .(or/cany/clist?))=car
procedure
(regexp-match? pattern        
              input          
             [start-pos      
              end-pos        
              output-port    
              input-prefix])->boolean?
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-exact?patterninput)->boolean?
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?)
procedure
(regexp-match-peek pattern       
                  input         
                 [start-pos     
                  end-pos       
                  progress      
                  input-prefix])
->(or/c(cons/cbytes?(listof(or/cbytes?#f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-positions pattern       
                            input         
                           [start-pos     
                            end-pos       
                            progress      
                            input-prefix])
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-immediate pattern       
                            input         
                           [start-pos     
                            end-pos       
                            progress      
                            input-prefix])
->(or/c(cons/cbytes?(listof(or/cbytes?#f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-positions-immediate pattern       
                                      input         
                                     [start-pos     
                                      end-pos       
                                      progress      
                                      input-prefix])
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-positions* pattern                      
                             input                        
                            [start-pos                    
                             end-pos                      
                             input-prefix                 
                             #:match-selectmatch-select])
->(or/c(listof(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?))
    (listof(listof(or/c#f(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
match-select:(list?. -> .(or/cany/clist?))=car
procedure
(regexp-match/end pattern     
                 input       
                [start-pos   
                 end-pos     
                 output-port 
                 input-prefix
                 count])     
->(if(and(or(string?pattern)(regexp?pattern))
    (or/c(string?input)(path?input)))
    (or/c#f(cons/cstring?(listof(or/cstring?#f))))
    (or/c#f(cons/cbytes?(listof(or/cbytes?#f)))))
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
count:nonnegative-exact-integer?=1
procedure
(regexp-match-positions/end pattern     
                           input       
                          [start-pos   
                           end-pos     
                           input-prefix
                           count])     
->(listof(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?))
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-match-peek-positions/end pattern     
                                input       
                               [start-pos   
                                end-pos     
                                progress    
                                input-prefix
                                count])     
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-match-peek-positions-immediate/end pattern     
                                          input       
                                         [start-pos   
                                          end-pos     
                                          progress    
                                          input-prefix
                                          count])     
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-split pattern       
             input         
            [start-pos     
             end-pos       
             input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (string?input))
    (cons/cstring?(listofstring?))
    (cons/cbytes?(listofbytes?)))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-replace pattern       
               input         
               insert        
              [input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (string?input))
    string?
    bytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?)
insert:(or/cstring?bytes?
           ((string?)()#:rest(listofstring?). ->* .string?)
           ((bytes?)()#:rest(listofbytes?). ->* .bytes?))
input-prefix:bytes?=#""
procedure
(regexp-replace* pattern        
                input          
                insert         
               [start-pos      
                end-pos        
                input-prefix])->(or/cstring?bytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?)
insert:(or/cstring?bytes?
           ((string?)()#:rest(listofstring?). ->* .string?)
           ((bytes?)()#:rest(listofbytes?). ->* .bytes?))
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-replacesinputreplacements)->(or/cstring?bytes?)
input:(or/cstring?bytes?)
replacements:(listof
                 (list/c(or/cstring?bytes?regexp?byte-regexp?)
                 (or/cstring?bytes?
                 ((string?)()#:rest(listofstring?). ->* .string?)
                 ((bytes?)()#:rest(listofbytes?). ->* .bytes?))))
procedure
(regexp-replace-quotestr)->string?
str:string?
(regexp-replace-quotebstr)->bytes?
bstr:bytes?
procedure
(keyword?v)->boolean?
v:any/c
procedure
(keyword->stringkeyword)->string?
keyword:keyword?
procedure
(string->keywordstr)->keyword?
str:string?
procedure
(keyword<?a-keywordb-keyword...+)->boolean?
a-keyword:keyword?
b-keyword:keyword?
procedure
(pair?v)->boolean?
v:any/c
procedure
(null?v)->boolean?
v:any/c
procedure
(consad)->pair?
a:any/c
d:any/c
procedure
(carp)->any/c
p:pair?
procedure
(cdrp)->any/c
p:pair?
value
null:null?
procedure
(list?v)->boolean?
v:any/c
procedure
(listv...)->list?
v:any/c
procedure
(list*v...tail)->any/c
v:any/c
tail:any/c
procedure
(build-listnproc)->list?
n:exact-nonnegative-integer?
proc:(exact-nonnegative-integer?. -> .any)
procedure
(lengthlst)->exact-nonnegative-integer?
lst:list?
procedure
(list-reflstpos)->any/c
lst:pair?
pos:exact-nonnegative-integer?
procedure
(list-taillstpos)->any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(appendlst...)->list?
lst:list?
(appendlst...v)->any/c
lst:list?
v:any/c
procedure
(reverselst)->list?
lst:list?
procedure
(mapproclst...+)->list?
proc:procedure?
lst:list?
procedure
(andmapproclst...+)->any
proc:procedure?
lst:list?
procedure
(ormapproclst...+)->any
proc:procedure?
lst:list?
procedure
(for-eachproclst...+)->void?
proc:procedure?
lst:list?
procedure
(foldlprocinitlst...+)->any/c
proc:procedure?
init:any/c
lst:list?
procedure
(foldrprocinitlst...+)->any/c
proc:procedure?
init:any/c
lst:list?
procedure
(filterpredlst)->list?
pred:procedure?
lst:list?
procedure
(removevlst[proc])->list?
v:any/c
lst:list?
proc:procedure?=equal?
procedure
(remqvlst)->list?
v:any/c
lst:list?
procedure
(remvvlst)->list?
v:any/c
lst:list?
procedure
(remove*v-lstlst[proc])->list?
v-lst:list?
lst:list?
proc:procedure?=equal?
procedure
(remq*v-lstlst)->list?
v-lst:list?
lst:list?
procedure
(remv*v-lstlst)->list?
v-lst:list?
lst:list?
procedure
(sort lst                         
     less-than?                  
    [#:keyextract-key           
     #:cache-keys?cache-keys?])->list?
lst:list?
less-than?:(any/cany/c. -> .any/c)
extract-key:(any/c. -> .any/c)=(lambda(x)x)
cache-keys?:boolean?=#f
procedure
(membervlst[is-equal?])->(or/clist?#f)
v:any/c
lst:list?
is-equal?:(any/cany/c->any/c)=equal?
procedure
(memvvlst)->(or/clist?#f)
v:any/c
lst:list?
procedure
(memqvlst)->(or/clist?#f)
v:any/c
lst:list?
procedure
(memfproclst)->(or/clist?#f)
proc:procedure?
lst:list?
procedure
(findfproclst)->any/c
proc:procedure?
lst:list?
procedure
(assocvlst[is-equal?])->(or/cpair?#f)
v:any/c
lst:(listofpair?)
is-equal?:(any/cany/c->any/c)=equal?
procedure
(assvvlst)->(or/cpair?#f)
v:any/c
lst:(listofpair?)
procedure
(assqvlst)->(or/cpair?#f)
v:any/c
lst:(listofpair?)
procedure
(assfproclst)->(or/clist?#f)
proc:procedure?
lst:list?
procedure
(caarv)->any/c
v:(cons/cpair?any/c)
procedure
(cadrv)->any/c
v:(cons/cany/cpair?)
procedure
(cdarv)->any/c
v:(cons/cpair?any/c)
procedure
(cddrv)->any/c
v:(cons/cany/cpair?)
procedure
(caaarv)->any/c
v:(cons/c(cons/cpair?any/c)any/c)
procedure
(caadrv)->any/c
v:(cons/cany/c(cons/cpair?any/c))
procedure
(cadarv)->any/c
v:(cons/c(cons/cany/cpair?)any/c)
procedure
(caddrv)->any/c
v:(cons/cany/c(cons/cany/cpair?))
procedure
(cdaarv)->any/c
v:(cons/c(cons/cpair?any/c)any/c)
procedure
(cdadrv)->any/c
v:(cons/cany/c(cons/cpair?any/c))
procedure
(cddarv)->any/c
v:(cons/c(cons/cany/cpair?)any/c)
procedure
(cdddrv)->any/c
v:(cons/cany/c(cons/cany/cpair?))
procedure
(caaaarv)->any/c
v:(cons/c(cons/c(cons/cpair?any/c)any/c)any/c)
procedure
(caaadrv)->any/c
v:(cons/cany/c(cons/c(cons/cpair?any/c)any/c))
procedure
(caadarv)->any/c
v:(cons/c(cons/cany/c(cons/cpair?any/c))any/c)
procedure
(caaddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cpair?any/c)))
procedure
(cadaarv)->any/c
v:(cons/c(cons/c(cons/cany/cpair?)any/c)any/c)
procedure
(cadadrv)->any/c
v:(cons/cany/c(cons/c(cons/cany/cpair?)any/c))
procedure
(caddarv)->any/c
v:(cons/c(cons/cany/c(cons/cany/cpair?))any/c)
procedure
(cadddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cany/cpair?)))
procedure
(cdaaarv)->any/c
v:(cons/c(cons/c(cons/cpair?any/c)any/c)any/c)
procedure
(cdaadrv)->any/c
v:(cons/cany/c(cons/c(cons/cpair?any/c)any/c))
procedure
(cdadarv)->any/c
v:(cons/c(cons/cany/c(cons/cpair?any/c))any/c)
procedure
(cdaddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cpair?any/c)))
procedure
(cddaarv)->any/c
v:(cons/c(cons/c(cons/cany/cpair?)any/c)any/c)
procedure
(cddadrv)->any/c
v:(cons/cany/c(cons/c(cons/cany/cpair?)any/c))
procedure
(cdddarv)->any/c
v:(cons/c(cons/cany/c(cons/cany/cpair?))any/c)
procedure
(cddddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cany/cpair?)))
value
empty:null?
procedure
(cons?v)->boolean?
v:any/c
procedure
(empty?v)->boolean?
v:any/c
procedure
(firstlst)->any/c
lst:list?
procedure
(restlst)->list?
lst:list?
procedure
(secondlst)->any
lst:list?
procedure
(thirdlst)->any
lst:list?
procedure
(fourthlst)->any
lst:list?
procedure
(fifthlst)->any
lst:list?
procedure
(sixthlst)->any
lst:list?
procedure
(seventhlst)->any
lst:list?
procedure
(eighthlst)->any
lst:list?
procedure
(ninthlst)->any
lst:list?
procedure
(tenthlst)->any
lst:list?
procedure
(lastlst)->any
lst:list?
procedure
(last-pairp)->pair?
p:pair?
procedure
(make-listkv)->list?
k:exact-nonnegative-integer?
v:any/c
procedure
(takelstpos)->list?
lst:any/c
pos:exact-nonnegative-integer?
procedure
(droplstpos)->any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(split-atlstpos)->list?any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(takeflstpred)->list?
lst:any/c
pred:procedure?
procedure
(dropflstpred)->any/c
lst:any/c
pred:procedure?
procedure
(splitf-atlstpred)->list?any/c
lst:any/c
pred:procedure?
procedure
(take-rightlstpos)->any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(drop-rightlstpos)->list?
lst:any/c
pos:exact-nonnegative-integer?
procedure
(split-at-rightlstpos)->list?any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(takef-rightlstpred)->list?
lst:any/c
pred:procedure?
procedure
(dropf-rightlstpred)->any/c
lst:any/c
pred:procedure?
procedure
(splitf-at-rightlstpred)->list?any/c
lst:any/c
pred:procedure?
procedure
(add-between lst                         
            v                           
           [#:before-firstbefore-first 
            #:before-lastbefore-last   
            #:after-lastafter-last     
            #:splice?splice?])        ->list?
lst:list?
v:any/c
before-first:list?='()
before-last:any/c=v
after-last:list?='()
splice?:any/c=#f
procedure
(append*lst...lsts)->list?
lst:list?
lsts:(listoflist?)
(append*lst...lsts)->any/c
lst:list?
lsts:list?
procedure
(flattenv)->list?
v:any/c
procedure
(remove-duplicates lst                 
                 [same?               
                  #:keyextract-key])->list?
lst:list?
same?:(any/cany/c. -> .any/c)=equal?
extract-key:(any/c. -> .any/c)=(lambda(x)x)
procedure
(filter-mapproclst...+)->list?
proc:procedure?
lst:list?
procedure
(countproclst...+)->exact-nonnegative-integer?
proc:procedure?
lst:list?
procedure
(partitionpredlst)->list?list?
pred:procedure?
lst:list?
procedure
(rangeend)->list?
end:real?
(rangestartend[step])->list?
start:real?
end:real?
step:real?=1
procedure
(append-mapproclst...+)->list?
proc:procedure?
lst:list?
procedure
(filter-notpredlst)->list?
pred:(any/c. -> .any/c)
lst:list?
procedure
(shufflelst)->list?
lst:list?
procedure
(permutationslst)->list?
lst:list?
procedure
(in-permutationslst)->sequence?
lst:list?
procedure
(argminproclst)->any/c
proc:(->any/creal?)
lst:(and/cpair?list?)
procedure
(argmaxproclst)->any/c
proc:(->any/creal?)
lst:(and/cpair?list?)
procedure
(make-reader-graphv)->any/c
v:any/c
procedure
(placeholder?v)->boolean?
v:any/c
procedure
(make-placeholderv)->placeholder?
v:any/c
procedure
(placeholder-set!phdatum)->void?
ph:placeholder?
datum:any/c
procedure
(placeholder-getph)->any/c
ph:placeholder?
procedure
(hash-placeholder?v)->boolean?
v:any/c
procedure
(make-hash-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(make-hasheq-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(make-hasheqv-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(mpair?v)->boolean?
v:any/c
procedure
(mconsad)->pair?
a:any/c
d:any/c
procedure
(mcarp)->any/c
p:mpair?
procedure
(mcdrp)->any/c
p:mpair?
procedure
(set-mcar!pv)->void?
p:mpair?
v:any/v
procedure
(set-mcdr!pv)->void?
p:mpair?
v:any/v
procedure
(vector?v)->boolean?
v:any/c
procedure
(make-vectorsize[v])->vector?
size:exact-nonnegative-integer?
v:any/c=0
procedure
(vectorv...)->vector?
v:any/c
procedure
(vector-immutablev...)->(and/cvector?
                            immutable?)
v:any/c
procedure
(vector-lengthvec)->exact-nonnegative-integer?
vec:vector?
procedure
(vector-refvecpos)->any/c
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-set!vecposv)->void?
vec:(and/cvector?(not/cimmutable?))
pos:exact-nonnegative-integer?
v:any/c
procedure
(vector->listvec)->list?
vec:vector?
procedure
(list->vectorlst)->vector?
lst:list?
procedure
(vector->immutable-vectorvec)->(and/cvector?immutable?)
vec:vector?
procedure
(vector-fill!vecv)->void?
vec:(and/cvector?(not/cimmutable?))
v:any/c
procedure
(vector-copy! dest       
             dest-start 
             src        
            [src-start  
             src-end]) ->void?
dest:(and/cvector?(not/cimmutable?))
dest-start:exact-nonnegative-integer?
src:vector?
src-start:exact-nonnegative-integer?=0
src-end:exact-nonnegative-integer?=(vector-lengthsrc)
procedure
(vector->valuesvec[start-posend-pos])->any
vec:vector?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(vector-lengthvec)
procedure
(build-vectornproc)->vector?
n:exact-nonnegative-integer?
proc:(exact-nonnegative-integer?. -> .any/c)
procedure
(vector-set*!vecposv......)->void?
vec:(and/cvector?(not/cimmutable?))
pos:exact-nonnegative-integer?
v:any/c
procedure
(vector-mapprocvec...+)->vector?
proc:procedure?
vec:vector?
procedure
(vector-map!procvec...+)->vector?
proc:procedure?
vec:vector?
procedure
(vector-appendvec...)->vector?
vec:vector?
procedure
(vector-takevecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-take-rightvecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-dropvecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-drop-rightvecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-split-atvecpos)->vector?vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-split-at-rightvecpos)->vector?vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-copyvec[startend])->vector?
vec:vector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(vector-filterpredvec)->vector?
pred:procedure?
vec:vector?
procedure
(vector-filter-notpredvec)->vector?
pred:procedure?
vec:vector?
procedure
(vector-countprocvec...+)->exact-nonnegative-integer?
proc:procedure?
vec:vector?
procedure
(vector-argminprocvec)->any/c
proc:(->any/creal?)
vec:vector?
procedure
(vector-argmaxprocvec)->any/c
proc:(->any/creal?)
vec:vector?
procedure
(vector-membervlst)->(or/cnatural-number/c#f)
v:any/c
lst:vector?
procedure
(vector-memvvvec)->(or/cnatural-number/c#f)
v:any/c
vec:vector?
procedure
(vector-memqvvec)->(or/cnatural-number/c#f)
v:any/c
vec:vector?
procedure
(box?v)->boolean?
v:any/c
procedure
(boxv)->box?
v:any/c
procedure
(box-immutablev)->(and/cbox?immutable?)
v:any/c
procedure
(unboxbox)->any/c
box:box?
procedure
(set-box!boxv)->void?
box:(and/cbox?(not/cimmutable?))
v:any/c
procedure
(box-cas!boxoldnew)->boolean?
box:(and/cbox?(not/cimmutable?)(not/cimpersonator?))
old:any/c
new:any/c
procedure
(hash?v)->boolean?
v:any/c
procedure
(hash-equal?hash)->boolean?
hash:hash?
procedure
(hash-eqv?hash)->boolean?
hash:hash?
procedure
(hash-eq?hash)->boolean?
hash:hash?
procedure
(hash-weak?hash)->boolean?
hash:hash?
procedure
(hashkeyval......)->(and/chash?hash-equal?immutable?)
key:any/c
val:any/c
procedure
(hasheqkeyval......)->(and/chash?hash-eq?immutable?)
key:any/c
val:any/c
procedure
(hasheqvkeyval......)->(and/chash?hash-eqv?immutable?)
key:any/c
val:any/c
procedure
(make-hash[assocs])->(and/chash?hash-equal?)
assocs:(listofpair?)=null
procedure
(make-hasheqv[assocs])->(and/chash?hash-eqv?)
assocs:(listofpair?)=null
procedure
(make-hasheq[assocs])->(and/chash?hash-eq?)
assocs:(listofpair?)=null
procedure
(make-weak-hash[assocs])->(and/chash?hash-equal?hash-weak?)
assocs:(listofpair?)=null
procedure
(make-weak-hasheqv[assocs])->(and/chash?hash-eqv?hash-weak?)
assocs:(listofpair?)=null
procedure
(make-weak-hasheq[assocs])->(and/chash?hash-eq?hash-weak?)
assocs:(listofpair?)=null
procedure
(make-immutable-hash[assocs])
->(and/chash?hash-equal?immutable?)
assocs:(listofpair?)=null
procedure
(make-immutable-hasheqv[assocs])
->(and/chash?hash-eqv?immutable?)
assocs:(listofpair?)=null
procedure
(make-immutable-hasheq[assocs])
->(and/chash?hash-eq?immutable?)
assocs:(listofpair?)=null
procedure
(hash-set!hashkeyv)->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
v:any/c
procedure
(hash-set*!hashkeyv......)->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
v:any/c
procedure
(hash-sethashkeyv)->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
v:any/c
procedure
(hash-set*hashkeyv......)->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
v:any/c
procedure
(hash-refhashkey[failure-result])->any
hash:hash?
key:any/c
failure-result:any/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-ref!hashkeyto-set)->any
hash:hash?
key:any/c
to-set:any/c
procedure
(hash-has-key?hashkey)->boolean?
hash:hash?
key:any/c
procedure
(hash-update! hash             
             key              
             updater          
            [failure-result])->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
updater:(any/c. -> .any/c)
failure-result:any/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-updatehashkeyupdater[failure-result])
->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
updater:(any/c. -> .any/c)
failure-result:any/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-remove!hashkey)->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
procedure
(hash-removehashkey)->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
procedure
(hash-clear!hash)->void?
hash:(and/chash?(not/cimmutable?))
procedure
(hash-clearhash)->(and/chash?immutable?)
hash:(and/chash?immutable?)
procedure
(hash-copy-clearhash)->hash?
hash:hash?
procedure
(hash-maphashproc)->(listofany/c)
hash:hash?
proc:(any/cany/c. -> .any/c)
procedure
(hash-keyshash)->(listofany/c)
hash:hash?
procedure
(hash-valueshash)->(listofany/c)
hash:hash?
procedure
(hash->listhash)->(listof(cons/cany/cany/c))
hash:hash?
procedure
(hash-for-eachhashproc)->void?
hash:hash?
proc:(any/cany/c. -> .any)
procedure
(hash-counthash)->exact-nonnegative-integer?
hash:hash?
procedure
(hash-empty?hash)->boolean?
hash:hash?
procedure
(hash-iterate-firsthash)
->(or/c#fexact-nonnegative-integer?)
hash:hash?
procedure
(hash-iterate-nexthashpos)
->(or/c#fexact-nonnegative-integer?)
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-keyhashpos)->any
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-valuehashpos)->any
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-copyhash)->(and/chash?(not/cimmutable?))
hash:hash?
procedure
(eq-hash-codev)->fixnum?
v:any/c
procedure
(eqv-hash-codev)->fixnum?
v:any/c
procedure
(equal-hash-codev)->fixnum?
v:any/c
procedure
(equal-secondary-hash-codev)->fixnum?
v:any/c
procedure
(sequence?v)->boolean?
v:any/c
procedure
(in-rangeend)->stream?
end:number?
(in-rangestartend[step])->stream?
start:number?
end:number?
step:number?=1
procedure
(in-naturals[start])->stream?
start:exact-nonnegative-integer?=0
procedure
(in-listlst)->stream?
lst:list?
procedure
(in-mlistmlst)->sequence?
mlst:mlist?
procedure
(in-vectorvec[startstopstep])->sequence?
vec:vector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
procedure
(in-stringstr[startstopstep])->sequence?
str:string?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
procedure
(in-bytesbstr[startstopstep])->sequence?
bstr:bytes?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
procedure
(in-port[rin])->sequence?
r:(input-port?. -> .any/c)=read
in:input-port?=(current-input-port)
procedure
(in-input-port-bytesin)->sequence?
in:input-port?
procedure
(in-input-port-charsin)->sequence?
in:input-port?
procedure
(in-lines[inmode])->sequence?
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='any
procedure
(in-bytes-lines[inmode])->sequence?
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='any
procedure
(in-hashhash)->sequence?
hash:hash?
procedure
(in-hash-keyshash)->sequence?
hash:hash?
procedure
(in-hash-valueshash)->sequence?
hash:hash?
procedure
(in-hash-pairshash)->sequence?
hash:hash?
procedure
(in-directory[dir])->sequence?
dir:(or/c#fpath-string?)=#f
procedure
(in-producerproducer)->sequence?
producer:procedure?
(in-producerproducerstoparg...)->sequence?
producer:procedure?
stop:any/c
arg:any/c
procedure
(in-valuev)->sequence?
v:any/c
procedure
(in-indexedseq)->sequence?
seq:sequence?
procedure
(in-sequencesseq...)->sequence?
seq:sequence?
procedure
(in-cycleseq...)->sequence?
seq:sequence?
procedure
(in-parallelseq...)->sequence?
seq:sequence?
procedure
(in-values-sequenceseq)->sequence?
seq:sequence?
procedure
(in-values*-sequenceseq)->sequence?
seq:sequence?
procedure
(stop-beforeseqpred)->sequence?
seq:sequence?
pred:(any/c. -> .any)
procedure
(stop-afterseqpred)->sequence?
seq:sequence?
pred:(any/c. -> .any)
procedure
(make-do-sequencethunk)->sequence?
thunk:(->(values(any/c. -> .any)
          (any/c. -> .any/c)
          any/c
          (or/c(any/c. -> .any/c)#f)
          (or/c(()()#:restlist?. ->* .any/c)#f)
          (or/c((any/c)()#:restlist?. ->* .any/c)#f)))
value
prop:sequence:struct-type-property?
procedure
(sequence->streamseq)->stream?
seq:sequence?
procedure
(sequence-generateseq)->(->boolean?)(->any)
seq:sequence?
procedure
(sequence-generate*seq)
->(or/clist?#f)
    (->(values(or/clist?#f)procedure?))
seq:sequence?
value
empty-sequence:sequence?
procedure
(sequence->lists)->list?
s:sequence?
procedure
(sequence-lengths)->exact-nonnegative-integer?
s:sequence?
procedure
(sequence-refsi)->any
s:sequence?
i:exact-nonnegative-integer?
procedure
(sequence-tailsi)->sequence?
s:sequence?
i:exact-nonnegative-integer?
procedure
(sequence-appends...)->sequence?
s:sequence?
procedure
(sequence-mapfs)->sequence?
f:procedure?
s:sequence?
procedure
(sequence-andmapfs)->boolean?
f:(->any/c...boolean?)
s:sequence?
procedure
(sequence-ormapfs)->boolean?
f:(->any/c...boolean?)
s:sequence?
procedure
(sequence-for-eachfs)->void?
f:(->any/c...any)
s:sequence?
procedure
(sequence-foldfis)->any/c
f:(->any/cany/c...any/c)
i:any/c
s:sequence?
procedure
(sequence-countfs)->exact-nonnegative-integer?
f:procedure?
s:sequence?
procedure
(sequence-filterfs)->sequence?
f:(->any/c...boolean?)
s:sequence?
procedure
(sequence-add-betweense)->sequence?
s:sequence?
e:any/c
procedure
(stream?v)->boolean?
v:any/c
procedure
(stream-empty?s)->boolean?
s:stream?
procedure
(stream-firsts)->any
s:(and/cstream?(not/cstream-empty?))
procedure
(stream-rests)->stream?
s:(and/cstream?(not/cstream-empty?))
syntax
(stream-consfirst-exprrest-expr)
syntax
(streamexpr...)
procedure
(in-streams)->sequence?
s:stream?
value
empty-stream:stream?
procedure
(stream->lists)->list?
s:stream?
procedure
(stream-lengths)->exact-nonnegative-integer?
s:stream?
procedure
(stream-refsi)->any
s:stream?
i:exact-nonnegative-integer?
procedure
(stream-tailsi)->stream?
s:stream?
i:exact-nonnegative-integer?
procedure
(stream-appends...)->stream?
s:stream?
procedure
(stream-mapfs)->stream?
f:procedure?
s:stream?
procedure
(stream-andmapfs)->boolean?
f:(->any/c...boolean?)
s:stream?
procedure
(stream-ormapfs)->boolean?
f:(->any/c...boolean?)
s:stream?
procedure
(stream-for-eachfs)->void?
f:(->any/c...any)
s:stream?
procedure
(stream-foldfis)->any/c
f:(->any/cany/c...any/c)
i:any/c
s:stream?
procedure
(stream-countfs)->exact-nonnegative-integer?
f:procedure?
s:stream?
procedure
(stream-filterfs)->stream?
f:(->any/c...boolean?)
s:stream?
procedure
(stream-add-betweense)->stream?
s:stream?
e:any/c
value
gen:stream:any/c
value
prop:stream:struct-type-property?
procedure
(generator?v)->boolean?
v:any/c
syntax
(generatorformalsbody...+)
procedure
(yieldv...)->any
v:any/c
syntax
(infinite-generatorbody...+)
syntax
(in-generatormaybe-aritybody...+)

maybe-arity=
          |#:arityarity-k
procedure
(generator-stateg)->symbol?
g:generator?
procedure
(sequence->generators)->(->any)
s:sequence?
procedure
(sequence->repeated-generators)->(->any)
s:sequence?
procedure
(dict?v)->boolean?
v:any/c
procedure
(dict-implements?dsym...)->boolean?
d:dict?
sym:symbol?
procedure
(dict-implements/csym...)->flat-contract?
sym:symbol?
procedure
(dict-mutable?d)->boolean?
d:dict?
procedure
(dict-can-remove-keys?d)->boolean?
d:dict?
procedure
(dict-can-functional-set?d)->boolean?
d:dict?
syntax
gen:dict
value
prop:dict:struct-type-property?
procedure
(dict-refdictkey[failure-result])->any
dict:dict?
key:any/c
failure-result:any/c
              =(lambda()(raise(make-exn:fail....)))
procedure
(dict-set!dictkeyv)->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
v:any/c
procedure
(dict-setdictkeyv)->(and/cdict?immutable?)
dict:(and/cdict?immutable?)
key:any/c
v:any/c
procedure
(dict-remove!dictkey)->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
procedure
(dict-removedictkey)->(and/cdict?immutable?)
dict:(and/cdict?immutable?)
key:any/c
procedure
(dict-iterate-firstdict)->any/c
dict:dict?
procedure
(dict-iterate-nextdictpos)->any/c
dict:dict?
pos:any/c
procedure
(dict-iterate-keydictpos)->any
dict:dict?
pos:any/c
procedure
(dict-iterate-valuedictpos)->any
dict:dict?
pos:any/c
procedure
(dict-has-key?dictkey)->boolean?
dict:dict?
key:any/c
procedure
(dict-set*!dictkeyv......)->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
v:any/c
procedure
(dict-set*dictkeyv......)->(and/cdict?immutable?)
dict:(and/cdict?immutable?)
key:any/c
v:any/c
procedure
(dict-ref!dictkeyto-set)->any
dict:dict?
key:any/c
to-set:any/c
procedure
(dict-update! dict             
             key              
             updater          
            [failure-result])->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
updater:(any/c. -> .any/c)
failure-result:any/c
              =(lambda()(raise(make-exn:fail....)))
procedure
(dict-updatedictkeyupdater[failure-result])
->(and/cdict?immutable?)
dict:dict?
key:any/c
updater:(any/c. -> .any/c)
failure-result:any/c
              =(lambda()(raise(make-exn:fail....)))
procedure
(dict-mapdictproc)->(listofany/c)
dict:dict?
proc:(any/cany/c. -> .any/c)
procedure
(dict-for-eachdictproc)->void?
dict:dict?
proc:(any/cany/c. -> .any)
procedure
(dict-empty?dict)->boolean?
dict:dict?
procedure
(dict-countdict)->exact-nonnegative-integer?
dict:dict?
procedure
(dict-copydict)->dict?
dict:dict?
procedure
(dict-cleardict)->dict?
dict:dict?
procedure
(dict-clear!dict)->dict?
dict:dict?
procedure
(dict-keysdict)->list?
dict:dict?
procedure
(dict-valuesdict)->list?
dict:dict?
procedure
(dict->listdict)->list?
dict:dict?
procedure
(in-dictdict)->sequence?
dict:dict?
procedure
(in-dict-keysdict)->sequence?
dict:dict?
procedure
(in-dict-valuesdict)->sequence?
dict:dict?
procedure
(in-dict-pairsdict)->sequence?
dict:dict?
value
prop:dict/contract:struct-type-property?
procedure
(dict-key-contractd)->contract?
d:dict?
procedure
(dict-value-contractd)->contract?
d:dict?
procedure
(dict-iter-contractd)->contract?
d:dict?
syntax
(define-custom-hash-typesname
optional-predicate
comparison-expr
optional-hash-functions)

optional-predicate     =
                      |#:key?predicate-expr
                      
optional-hash-functions=
                      |hash1-expr
                      |hash1-exprhash2-expr
procedure
(make-custom-hash-types eql?        
                      [hash1       
                       hash2       
                       #:key?key? 
                       #:namename 
                       #:forwho])->(any/c. -> .boolean?)
                                        (any/c. -> .boolean?)
                                        (any/c. -> .boolean?)
                                        (any/c. -> .boolean?)
                                        (->*[][dict?]dict?)
                                        (->*[][dict?]dict?)
                                        (->*[][dict?]dict?)
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=(const#true)
name:symbol?='custom-hash
who:symbol?='make-custom-hash-types
procedure
(make-custom-hash eql?          
                [hash1         
                 hash2         
                 #:key?key?])->dict?
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=(const#true)
procedure
(make-weak-custom-hash eql?          
                     [hash1         
                      hash2         
                      #:key?key?])->dict?
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=(const#true)
procedure
(make-immutable-custom-hash eql?          
                          [hash1         
                           hash2         
                           #:key?key?])->dict?
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=(const#true)
procedure
(set-equal?x)->boolean?
x:any/c
procedure
(set-eqv?x)->boolean?
x:any/c
procedure
(set-eq?x)->boolean?
x:any/c
procedure
(set?x)->boolean?
x:any/c
procedure
(set-mutable?x)->boolean?
x:any/c
procedure
(set-weak?x)->boolean?
x:any/c
procedure
(setv...)->(and/cgeneric-set?set-equal?set?)
v:any/c
procedure
(seteqvv...)->(and/cgeneric-set?set-eqv?set?)
v:any/c
procedure
(seteqv...)->(and/cgeneric-set?set-eq?set?)
v:any/c
procedure
(mutable-setv...)
->(and/cgeneric-set?set-equal?set-mutable?)
v:any/c
procedure
(mutable-seteqvv...)
->(and/cgeneric-set?set-eqv?set-mutable?)
v:any/c
procedure
(mutable-seteqv...)
->(and/cgeneric-set?set-eq?set-mutable?)
v:any/c
procedure
(weak-setv...)->(and/cgeneric-set?set-equal?set-weak?)
v:any/c
procedure
(weak-seteqvv...)->(and/cgeneric-set?set-eqv?set-weak?)
v:any/c
procedure
(weak-seteqv...)->(and/cgeneric-set?set-eq?set-weak?)
v:any/c
procedure
(list->setlst)->(and/cgeneric-set?set-equal?set?)
lst:list?
procedure
(list->seteqvlst)->(and/cgeneric-set?set-eqv?set?)
lst:list?
procedure
(list->seteqlst)->(and/cgeneric-set?set-eq?set?)
lst:list?
procedure
(list->mutable-setlst)
->(and/cgeneric-set?set-equal?set-mutable?)
lst:list?
procedure
(list->mutable-seteqvlst)
->(and/cgeneric-set?set-eqv?set-mutable?)
lst:list?
procedure
(list->mutable-seteqlst)
->(and/cgeneric-set?set-eq?set-mutable?)
lst:list?
procedure
(list->weak-setlst)
->(and/cgeneric-set?set-equal?set-weak?)
lst:list?
procedure
(list->weak-seteqvlst)
->(and/cgeneric-set?set-eqv?set-weak?)
lst:list?
procedure
(list->weak-seteqlst)->(and/cgeneric-set?set-eq?set-weak?)
lst:list?
syntax
(for/set(for-clause...)body...+)
syntax
(for/seteq(for-clause...)body...+)
syntax
(for/seteqv(for-clause...)body...+)
syntax
(for*/set(for-clause...)body...+)
syntax
(for*/seteq(for-clause...)body...+)
syntax
(for*/seteqv(for-clause...)body...+)
syntax
(for/mutable-set(for-clause...)body...+)
syntax
(for/mutable-seteq(for-clause...)body...+)
syntax
(for/mutable-seteqv(for-clause...)body...+)
syntax
(for*/mutable-set(for-clause...)body...+)
syntax
(for*/mutable-seteq(for-clause...)body...+)
syntax
(for*/mutable-seteqv(for-clause...)body...+)
syntax
(for/weak-set(for-clause...)body...+)
syntax
(for/weak-seteq(for-clause...)body...+)
syntax
(for/weak-seteqv(for-clause...)body...+)
syntax
(for*/weak-set(for-clause...)body...+)
syntax
(for*/weak-seteq(for-clause...)body...+)
syntax
(for*/weak-seteqv(for-clause...)body...+)
procedure
(generic-set?v)->boolean?
v:any/c
procedure
(set-implements?stsym...)->boolean?
st:generic-set?
sym:symbol?
procedure
(set-implements/csym...)->flat-contract?
sym:symbol?
procedure
(set/celem/c[#:cmpcmp#:kindkind])->contract?
elem/c:chaperone-contract?
cmp:(or/c'dont-care'equal'eqv'eq)='dont-care
kind:(or/c'dont-care'immutable'mutable'weak'mutable-or-weak)
    ='dont-care
syntax
gen:set
procedure
(set-member?stv)->boolean?
st:generic-set?
v:any/c
procedure
(set-addstv)->generic-set?
st:generic-set?
v:any/c
procedure
(set-add!stv)->void?
st:generic-set?
v:any/c
procedure
(set-removestv)->generic-set?
st:generic-set?
v:any/c
procedure
(set-remove!stv)->void?
st:generic-set?
v:any/c
procedure
(set-empty?st)->boolean?
st:generic-set?
procedure
(set-countst)->exact-nonnegative-integer?
st:generic-set?
procedure
(set-firstst)->any/c
st:(and/cgeneric-set?(not/cset-empty?))
procedure
(set-restst)->generic-set?
st:(and/cgeneric-set?(not/cset-empty?))
procedure
(set->streamst)->stream?
st:generic-set?
procedure
(set-copyst)->generic-set?
st:generic-set?
procedure
(set-copy-clearst)->(and/cgeneric-set?set-empty?)
st:generic-set?
procedure
(set-clearst)->(and/cgeneric-set?set-empty?)
st:generic-set?
procedure
(set-clear!st)->void?
st:generic-set?
procedure
(set-unionst0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-union!st0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-intersectst0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-intersect!st0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-subtractst0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-subtract!st0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-symmetric-differencest0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-symmetric-difference!st0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set=?stst2)->boolean?
st:generic-set?
st2:generic-set?
procedure
(subset?stst2)->boolean?
st:generic-set?
st2:generic-set?
procedure
(proper-subset?stst2)->boolean?
st:generic-set?
st2:generic-set?
procedure
(set->listst)->list?
st:generic-set?
procedure
(set-mapstproc)->(listofany/c)
st:generic-set?
proc:(any/c. -> .any/c)
procedure
(set-for-eachstproc)->void?
st:generic-set?
proc:(any/c. -> .any)
procedure
(in-setst)->sequence?
st:generic-set?
syntax
(define-custom-set-typesname
optional-predicate
comparison-expr
optional-hash-functions)

optional-predicate     =
                      |#:elem?predicate-expr
                      
optional-hash-functions=
                      |hash1-expr
                      |hash1-exprhash2-expr
procedure
(make-custom-set-types eql?         
                     [hash1        
                      hash2        
                      #:elem?elem?
                      #:namename  
                      #:forwho])  
->(any/c. -> .boolean?)
    (any/c. -> .boolean?)
    (any/c. -> .boolean?)
    (any/c. -> .boolean?)
    (->*[][stream?]generic-set?)
    (->*[][stream?]generic-set?)
    (->*[][stream?]generic-set?)
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
elem?:(any/c. -> .boolean?)=(const#true)
name:symbol?='custom-set
who:symbol?='make-custom-set-types
procedure
(procedure?v)->boolean?
v:any/c
procedure
(applyprocv...lst#:<kw>kw-arg...)->any
proc:procedure?
v:any/c
lst:list?
kw-arg:any/c
procedure
(composeproc...)->procedure?
proc:procedure?
procedure
(compose1proc...)->procedure?
proc:procedure?
procedure
(procedure-renameprocname)->procedure?
proc:procedure?
name:symbol?
procedure
(procedure->methodproc)->procedure?
proc:procedure?
procedure
(procedure-closure-contents-eq?proc1  
                              proc2)->boolean?
proc1:procedure?
proc2:procedure?
procedure
(keyword-applyproc               
             kw-lst             
             kw-val-lst         
             v...              
             lst                
             #:<kw>kw-arg...)->any
proc:procedure?
kw-lst:(listofkeyword?)
kw-val-lst:list?
v:any/c
lst:list?
kw-arg:any/c
procedure
(procedure-arityproc)->normalized-arity?
proc:procedure?
procedure
(procedure-arity?v)->boolean?
v:any/c
procedure
(procedure-arity-includes?prock[kws-ok?])->boolean?
proc:procedure?
k:exact-nonnegative-integer?
kws-ok?:any/c=#f
procedure
(procedure-reduce-arityprocarity)->procedure?
proc:procedure?
arity:procedure-arity?
procedure
(procedure-keywordsproc)->(listofkeyword?)
                             (or/c(listofkeyword?)#f)
proc:procedure?
procedure
(make-keyword-procedureproc[plain-proc])->procedure?
proc:(((listofkeyword?)list?)()#:restlist?. ->* .any)
plain-proc:procedure?
          =(lambdaargs(applyprocnullnullargs))
procedure
(procedure-reduce-keyword-arityproc         
                              arity        
                              required-kws 
                              allowed-kws)->procedure?
proc:procedure?
arity:procedure-arity?
required-kws:(listofkeyword?)
allowed-kws:(or/c(listofkeyword?)
                #f)
struct
(structarity-at-least(value)
      #:extra-constructor-namemake-arity-at-least)
value:exact-nonnegative-integer?
value
prop:procedure:struct-type-property?
procedure
(procedure-struct-type?type)->boolean?
type:struct-type?
procedure
(procedure-extract-targetproc)->(or/c#fprocedure?)
proc:procedure?
value
prop:arity-string:struct-type-property?
value
prop:checked-procedure:struct-type-property?
procedure
(checked-procedure-check-and-extracttype 
                                   v    
                                   proc 
                                   v1   
                                   v2) ->any/c
type:struct-type?
v:any/c
proc:(any/cany/cany/c. -> .any/c)
v1:any/c
v2:any/c
procedure
(primitive?v)->boolean?
v:any/c
procedure
(primitive-closure?v)->boolean
v:any/c
procedure
(primitive-result-arityprim)->procedure-arity?
prim:primitive?
procedure
(identityv)->any/c
v:any/c
procedure
(constv)->procedure?
v:any
syntax
(thunkbody...+)
syntax
(thunk*body...+)
procedure
(negateproc)->procedure?
proc:procedure?
procedure
(curryproc)->procedure?
proc:procedure?
(curryprocv...+)->any/c
proc:procedure?
v:any/c
procedure
(curryrproc)->procedure?
proc:procedure?
(curryrprocv...+)->any/c
proc:procedure?
v:any/c
procedure
(normalized-arity?arity)->boolean?
arity:any/c
procedure
(normalize-arityarity)
->(and/cnormalized-arity?(lambda(x)(arity=?xarity)))
arity:procedure-arity?
procedure
(arity=?ab)->boolean?
a:procedure-arity?
b:procedure-arity?
procedure
(arity-includes?ab)->boolean?
a:procedure-arity?
b:procedure-arity?
procedure
(void?v)->void?
v:any/c
procedure
(voidv...)->void?
v:any/c
syntax
(structidmaybe-super(field...)
struct-option...)

maybe-super  =
            |super-id
            
field        =field-id
            |[field-idfield-option...]
            
struct-option=#:mutable
            |#:supersuper-expr
            |#:inspectorinspector-expr
            |#:auto-valueauto-expr
            |#:guardguard-expr
            |#:propertyprop-exprval-expr
            |#:transparent
            |#:prefab
            |#:constructor-nameconstructor-id
            |#:extra-constructor-nameconstructor-id
            |#:reflection-namesymbol-expr
            |#:methodsgen:namemethod-defs
            |#:omit-define-syntaxes
            |#:omit-define-values
            
field-option =#:mutable
            |#:auto
            
method-defs  =(definition...)

gen:name:identifier?
syntax
(struct-field-indexfield-id)
syntax
(define-structid-maybe-super(field...)
struct-option...)

id-maybe-super=id
             |(idsuper-id)
syntax
(define-struct/derived(id. rest-form)
id-maybe-super(field...)struct-option...)
procedure
(make-struct-type name              
                 super-type        
                 init-field-cnt    
                 auto-field-cnt    
                [auto-v            
                 props             
                 inspector         
                 proc-spec         
                 immutables        
                 guard             
                 constructor-name])
->struct-type?
    struct-constructor-procedure?
    struct-predicate-procedure?
    struct-accessor-procedure?
    struct-mutator-procedure?
name:symbol?
super-type:(or/cstruct-type?#f)
init-field-cnt:exact-nonnegative-integer?
auto-field-cnt:exact-nonnegative-integer?
auto-v:any/c=#f
props:(listof(cons/cstruct-type-property?=null
          any/c))
inspector:(or/cinspector?#f'prefab)=(current-inspector)
proc-spec:(or/cprocedure?                =#f
              exact-nonnegative-integer?
              #f)
immutables:(listofexact-nonnegative-integer?)=null
guard:(or/cprocedure?#f)=#f
constructor-name:(or/csymbol?#f)=#f
procedure
(make-struct-field-accessor accessor-proc 
                           field-pos     
                          [field-name]) ->procedure?
accessor-proc:struct-accessor-procedure?
field-pos:exact-nonnegative-integer?
field-name:(or/csymbol?#f)
          =(symbol->string(format"field~a"field-pos))
procedure
(make-struct-field-mutator mutator-proc 
                          field-pos    
                         [field-name])->procedure?
mutator-proc:struct-mutator-procedure?
field-pos:exact-nonnegative-integer?
field-name:(or/csymbol?#f)
          =(symbol->string(format"field~a"field-pos))
procedure
(make-struct-type-property name              
                         [guard             
                          supers            
                          can-impersonate?])
->struct-type-property?
    procedure?
    procedure?
name:symbol?
guard:(or/cprocedure?#f'can-impersonate)=#f
supers:(listof(cons/cstruct-type-property? =null
           (any/c. -> .any/c)))
can-impersonate?:any/c=#f
procedure
(struct-type-property?v)->boolean?
v:any/c
procedure
(struct-type-property-accessor-procedure?v)->boolean?
v:any/c
syntax
(define-genericsid
generics-opt...
[method-id. kw-formals*]...
generics-opt...)

generics-opt=#:defaults([default-pred?default-impl...]...)
           |#:fast-defaults([fast-pred?fast-impl...]...)
           |#:fallbacks[fallback-impl...]
           |#:defined-predicatedefined-pred-id
           |#:defined-tabledefined-table-id
           |#:derive-propertyprop-exprprop-value-expr
           
kw-formals* =(arg*...)
           |(arg*...+. rest-id)
           |rest-id
           
arg*        =arg-id
           |[arg-id]
           |keywordarg-id
           |keyword[arg-id]
procedure
(raise-support-errornamev)->none/c
name:symbol?
v:any/c
struct
(structexn:fail:supportexn:fail()
      #:transparent)
syntax
(define/genericlocal-idmethod-id)

local-id:identifier?
method-id:identifier?
syntax
(generic-instance/cgen-id[method-idmethod-ctc]...)

method-ctc:contract?
syntax
(impersonate-genericsgen-idval-expr[method-idmethod-proc]...)

method-proc:(any/c. -> .any/c)
syntax
(chaperone-genericsgen-idval-expr[method-idmethod-proc]...)

method-proc:(any/c. -> .any/c)
syntax
(redirect-genericsmodegen-idval-expr[method-idmethod-proc]...)

method-proc:(any/c. -> .any/c)
syntax
(struct-copyidstruct-exprfld-id...)

fld-id=[field-idexpr]
     |[field-id#:parentparent-idexpr]
procedure
(struct->vectorv[opaque-v])->vector?
v:any/c
opaque-v:any/c='...
procedure
(struct?v)->any
v:any/c
procedure
(struct-type?v)->boolean?
v:any/c
procedure
(struct-constructor-procedure?v)->boolean?
v:any/c
procedure
(struct-predicate-procedure?v)->boolean?
v:any/c
procedure
(struct-accessor-procedure?v)->boolean?
v:any/c
procedure
(struct-mutator-procedure?v)->boolean?
v:any/c
procedure
(prefab-struct-keyv)->(or/c#fsymbol?list?)
v:any/c
procedure
(make-prefab-structkeyv...)->struct?
key:prefab-key?
v:any/c
procedure
(prefab-key->struct-typekeyfield-count)->struct-type?
key:prefab-key?
field-count:(integer-in032768)
procedure
(prefab-key?v)->boolean?
v:any/c
procedure
(struct-info?v)->boolean?
v:any/c
procedure
(checked-struct-info?v)->boolean?
v:any/c
procedure
(make-struct-infothunk)->struct-info?
thunk:(->(and/cstruct-info?list?))
procedure
(extract-struct-infov)->(and/cstruct-info?list?)
v:struct-info?
value
struct:struct-info:struct-type?
value
prop:struct-info:struct-type-property?
value
prop:struct-auto-info:struct-type-property?
procedure
(struct-auto-info?v)->boolean?
v:any/c
procedure
(struct-auto-info-listssai)
->(list/c(listofidentifier?)(listofidentifier?))
sai:struct-auto-info?
syntax
(interface(super-interface-expr...)name-clause...)

name-clause=id
          |(idcontract-expr)
syntax
(interface*(super-interface-expr...)
([property-exprval-expr]...)
name-clause...)

name-clause=id
          |(idcontract-expr)
value
object%:class?
syntax
(class*superclass-expr(interface-expr...)
class-clause
...)

class-clause     =(inspectinspector-expr)
                |(initinit-decl...)
                |(init-fieldinit-decl...)
                |(fieldfield-decl...)
                |(inherit-fieldmaybe-renamed...)
                |(init-restid)
                |(init-rest)
                |(publicmaybe-renamed...)
                |(pubmentmaybe-renamed...)
                |(public-finalmaybe-renamed...)
                |(overridemaybe-renamed...)
                |(overmentmaybe-renamed...)
                |(override-finalmaybe-renamed...)
                |(augmentmaybe-renamed...)
                |(augridemaybe-renamed...)
                |(augment-finalmaybe-renamed...)
                |(privateid...)
                |(abstractid...)
                |(inheritmaybe-renamed...)
                |(inherit/supermaybe-renamed...)
                |(inherit/innermaybe-renamed...)
                |(rename-superrenamed...)
                |(rename-innerrenamed...)
                |method-definition
                |definition
                |expr
                |(beginclass-clause...)
                
init-decl        =id
                |(renamed)
                |(maybe-renameddefault-value-expr)
                
field-decl       =(maybe-renameddefault-value-expr)
                
maybe-renamed    =id
                |renamed
                
renamed          =(internal-idexternal-id)
                
method-definition=(define-values(id)method-procedure)
                
method-procedure =(lambdakw-formalsexpr...+)
                |(case-lambda(formalsexpr...+)...)
                |(#%plain-lambdaformalsexpr...+)
                |(let-values([(id)method-procedure]...)
                    method-procedure)
                |(letrec-values([(id)method-procedure]...)
                    method-procedure)
                |(let-values([(id)method-procedure]...+)
                    id)
                |(letrec-values([(id)method-procedure]...+)
                    id)
syntax
(classsuperclass-exprclass-clause...)
syntax
this
syntax
this%
syntax
(inspectinspector-expr)
syntax
(initinit-decl...)
syntax
(init-fieldinit-decl...)
syntax
(fieldfield-decl...)
syntax
(inherit-fieldmaybe-renamed...)
syntax
(init-restid)
(init-rest)
syntax
(publicmaybe-renamed...)
syntax
(pubmentmaybe-renamed...)
syntax
(public-finalmaybe-renamed...)
syntax
(overridemaybe-renamed...)
syntax
(overmentmaybe-renamed...)
syntax
(override-finalmaybe-renamed...)
syntax
(augmentmaybe-renamed...)
syntax
(augridemaybe-renamed...)
syntax
(augment-finalmaybe-renamed...)
syntax
(privateid...)
syntax
(abstractid...)
syntax
(inheritmaybe-renamed...)
syntax
(inherit/supermaybe-renamed...)
syntax
(inherit/innermaybe-renamed...)
syntax
(rename-superrenamed...)
syntax
(rename-innerrenamed...)
syntax
(public*(idexpr)...)
syntax
(pubment*(idexpr)...)
syntax
(public-final*(idexpr)...)
syntax
(override*(idexpr)...)
syntax
(overment*(idexpr)...)
syntax
(override-final*(idexpr)...)
syntax
(augment*(idexpr)...)
syntax
(augride*(idexpr)...)
syntax
(augment-final*(idexpr)...)
syntax
(private*(idexpr)...)
syntax
(define/publicidexpr)
(define/public(id. formals)body...+)
syntax
(define/pubmentidexpr)
(define/pubment(id. formals)body...+)
syntax
(define/public-finalidexpr)
(define/public-final(id. formals)body...+)
syntax
(define/overrideidexpr)
(define/override(id. formals)body...+)
syntax
(define/overmentidexpr)
(define/overment(id. formals)body...+)
syntax
(define/override-finalidexpr)
(define/override-final(id. formals)body...+)
syntax
(define/augmentidexpr)
(define/augment(id. formals)body...+)
syntax
(define/augrideidexpr)
(define/augride(id. formals)body...+)
syntax
(define/augment-finalidexpr)
(define/augment-final(id. formals)body...+)
syntax
(define/privateidexpr)
(define/private(id. formals)body...+)
syntax
(class/derivedoriginal-datum
(name-idsuper-expr(interface-expr...)deserialize-id-expr)
class-clause
...)
syntax
(superidarg...)
(superidarg.... arg-list-expr)
syntax
(innerdefault-expridarg...)
(innerdefault-expridarg.... arg-list-expr)
syntax
(define-local-member-nameid...)
syntax
(define-member-nameidkey-expr)
syntax
(member-name-keyidentifier)
procedure
(generate-member-key)->member-name-key?
procedure
(member-name-key?v)->boolean?
v:any/c
procedure
(member-name-key=?a-keyb-key)->boolean?
a-key:member-name-key?
b-key:member-name-key?
procedure
(member-name-key-hash-codea-key)->integer?
a-key:member-name-key?
procedure
(make-objectclassinit-v...)->object?
class:class?
init-v:any/c
syntax
(newclass-expr(idby-name-expr)...)
syntax
(instantiateclass-expr(by-pos-expr...)(idby-name-expr)...)
syntax
super-make-object
syntax
(super-instantiate(by-pos-expr...)(idby-expr...)...)
syntax
(super-new(idby-name-expr...)...)

(method-idarg.... arg-list-expr)
syntax
(sendobj-exprmethod-idarg...)
(sendobj-exprmethod-idarg.... arg-list-expr)
syntax
(send/applyobj-exprmethod-idarg...arg-list-expr)
syntax
(send/keyword-applyobj-exprmethod-id
keyword-list-exprvalue-list-expr
arg...arg-list-expr)
procedure
(dynamic-sendobj                
            method-name        
            v...              
            #:<kw>kw-arg...)->any
obj:object?
method-name:symbol?
v:any/c
kw-arg:any/c
syntax
(send*obj-exprmsg...+)

msg=(method-idarg...)
  |(method-idarg.... arg-list-expr)
syntax
(send+obj-exprmsg...)

msg=(method-idarg...)
  |(method-idarg.... arg-list-expr)
syntax
(with-method((id(obj-exprmethod-id))...)
body...+)
syntax
(get-fieldidobj-expr)
procedure
(dynamic-get-fieldfield-nameobj)->any/c
field-name:symbol?
obj:object?
syntax
(set-field!idobj-exprexpr)
procedure
(dynamic-set-field!field-nameobjv)->void?
field-name:symbol?
obj:object?
v:any/c
syntax
(field-bound?idobj-expr)
syntax
(class-field-accessorclass-exprfield-id)
syntax
(class-field-mutatorclass-exprfield-id)
syntax
(genericclass-or-interface-exprid)
syntax
(send-genericobj-exprgeneric-exprarg...)
(send-genericobj-exprgeneric-exprarg.... arg-list-expr)
procedure
(make-generictypemethod-name)->generic?
type:(or/cclass?interface?)
method-name:symbol?
syntax
(mixin(interface-expr...)(interface-expr...)
class-clause...)
syntax
(traittrait-clause...)

trait-clause=(publicmaybe-renamed...)
           |(pubmentmaybe-renamed...)
           |(public-finalmaybe-renamed...)
           |(overridemaybe-renamed...)
           |(overmentmaybe-renamed...)
           |(override-finalmaybe-renamed...)
           |(augmentmaybe-renamed...)
           |(augridemaybe-renamed...)
           |(augment-finalmaybe-renamed...)
           |(inheritmaybe-renamed...)
           |(inherit/supermaybe-renamed...)
           |(inherit/innermaybe-renamed...)
           |method-definition
           |(fieldfield-declaration...)
           |(inherit-fieldmaybe-renamed...)
procedure
(trait?v)->boolean?
v:any/c
procedure
(trait->mixintr)->(class?. -> .class?)
tr:trait?
procedure
(trait-sumtr...+)->trait?
tr:trait?
syntax
(trait-excludetrait-exprid)
syntax
(trait-exclude-fieldtrait-exprid)
syntax
(trait-aliastrait-expridnew-id)
syntax
(trait-renametrait-expridnew-id)
syntax
(trait-rename-fieldtrait-expridnew-id)
syntax
(class/cmaybe-opaquemember-spec...)

maybe-opaque=
           |#:opaque
           
member-spec =method-spec
           |(fieldfield-spec...)
           |(initfield-spec...)
           |(init-fieldfield-spec...)
           |(inheritmethod-spec...)
           |(inherit-fieldfield-spec...)
           |(supermethod-spec...)
           |(innermethod-spec...)
           |(overridemethod-spec...)
           |(augmentmethod-spec...)
           |(augridemethod-spec...)
           |(absentabsent-spec...)
           
method-spec =method-id
           |(method-idmethod-contract-expr)
           
field-spec  =field-id
           |(field-idcontract-expr)
           
absent-spec =method-id
           |(fieldfield-id...)
syntax
(absentmethod-id...)
syntax
(->mdom...range)
syntax
(->*m(mandatory-dom...)(optional-dom...)restrange)
syntax
(case->m(->dom...restrange)...)
syntax
(->dm(mandatory-dependent-dom...)
(optional-dependent-dom...)
dependent-rest
pre-cond
dep-range)
syntax
(object/cmember-spec...)

member-spec=method-spec
          |(fieldfield-spec...)
          
method-spec=method-id
          |(method-idmethod-contract)
          
field-spec =field-id
          |(field-idcontract-expr)
procedure
(instanceof/cclass-contract)->contract?
class-contract:contract?
syntax
(object-contractmember-spec...)

member-spec            =(method-idmethod-contract)
                      |(fieldfield-idcontract-expr)
                      
method-contract        =(->dom...range)
                      |(->*(mandatory-dom...)
                          (optional-dom...)
                          rest
                          range)
                      |(->d(mandatory-dependent-dom...)
                          (optional-dependent-dom...)
                          dependent-rest
                          pre-cond
                          dep-range)
                      
dom                    =dom-expr
                      |keyworddom-expr
                      
range                  =range-expr
                      |(valuesrange-expr...)
                      |any
                      
mandatory-dom          =dom-expr
                      |keyworddom-expr
                      
optional-dom           =dom-expr
                      |keyworddom-expr
                      
rest                   =
                      |#:restrest-expr
                      
mandatory-dependent-dom=[iddom-expr]
                      |keyword[iddom-expr]
                      
optional-dependent-dom =[iddom-expr]
                      |keyword[iddom-expr]
                      
dependent-rest         =
                      |#:restidrest-expr
                      
pre-cond               =
                      |#:pre-condboolean-expr
                      
dep-range              =any
                      |[idrange-expr]post-cond
                      |(values[idrange-expr]...)post-cond
                      
post-cond              =
                      |#:post-condboolean-expr
value
mixin-contract:contract?
procedure
(make-mixin-contracttype...)->contract?
type:(or/cclass?interface?)
procedure
(is-a?/ctype)->flat-contract?
type:(or/cclass?interface?)
procedure
(implementation?/cinterface)->flat-contract?
interface:interface?
procedure
(subclass?/cclass)->flat-contract?
class:class?
interface
equal<%>:interface?
syntax
(define-serializable-class*class-idsuperclass-expr
(interface-expr...)
class-clause...)
syntax
(define-serializable-classclass-idsuperclass-expr
class-clause...)
interface
externalizable<%>:interface?
value
printable<%>:interface?
value
writable<%>:interface?
procedure
(object?v)->boolean?
v:any/c
procedure
(class?v)->boolean?
v:any/c
procedure
(interface?v)->boolean?
v:any/c
procedure
(generic?v)->boolean?
v:any/c
procedure
(object=?ab)->boolean?
a:object?
b:object?
procedure
(object->vectorobject[opaque-v])->vector?
object:object?
opaque-v:any/c=#f
procedure
(class->interfaceclass)->interface?
class:class?
procedure
(object-interfaceobject)->interface?
object:object?
procedure
(is-a?vtype)->boolean?
v:any/c
type:(or/cinterface?class?)
procedure
(subclass?vcls)->boolean?
v:any/c
cls:class?
procedure
(implementation?vintf)->boolean?
v:any/c
intf:interface?
procedure
(interface-extension?vintf)->boolean?
v:any/c
intf:interface?
procedure
(method-in-interface?symintf)->boolean?
sym:symbol?
intf:interface?
procedure
(interface->method-namesintf)->(listofsymbol?)
intf:interface?
procedure
(object-method-arity-includes?object 
                             sym    
                             cnt)  ->boolean?
object:object?
sym:symbol?
cnt:exact-nonnegative-integer?
procedure
(field-namesobject)->(listofsymbol?)
object:object?
procedure
(object-infoobject)->(or/cclass?#f)boolean?
object:object?
procedure
(class-infoclass)
->symbol?
    exact-nonnegative-integer?
    (listofsymbol?)
    (any/cexact-nonnegative-integer?. -> .any/c)
    (any/cexact-nonnegative-integer?any/c. -> .any/c)
    (or/cclass?#f)
    boolean?
class:class?
struct
(structexn:fail:objectexn:fail()
      #:extra-constructor-namemake-exn:fail:object)
syntax
(surrogatemethod-spec...)

method-spec=(method-idarg-spec...)
          |(overridemethod-idarg-spec...)
          |(override-finalmethod-id(lambda()default-expr)
              arg-spec...)
          
arg-spec   =(id...)
          |id
syntax
(unit
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-body-expr-or-defn
...)

tagged-sig-spec  =sig-spec
                |(tagidsig-spec)
                
sig-spec         =sig-id
                |(prefixidsig-spec)
                |(renamesig-spec(idid)...)
                |(onlysig-specid...)
                |(exceptsig-specid...)
                
init-depends-decl=
                |(init-dependtagged-sig-id...)
                
tagged-sig-id    =sig-id
                |(tagidsig-id)
syntax
(define-signatureidextension-decl
(sig-elem...))

extension-decl=
             |extendssig-id
             
sig-elem      =id
             |(define-syntaxes(id...)expr)
             |(define-values(id...)expr)
             |(define-values-for-export(id...)expr)
             |(contracted[idcontract]...)
             |(opensig-spec)
             |(structid(field...)struct-option...)
             |(sig-form-id. datum)
             
field         =id
             |[id#:mutable]
             
struct-option =#:mutable
             |#:constructor-nameconstructor-id
             |#:extra-constructor-nameconstructor-id
             |#:omit-constructor
             |#:omit-define-syntaxes
             |#:omit-define-values
syntax
(opensig-spec)
syntax
(define-values-for-export(id...)expr)
syntax
(contracted[idcontract]...)
syntax
(onlysig-specid...)
syntax
(exceptsig-specid...)
syntax
(renamesig-spec(idid)...)
syntax
(prefixidsig-spec)
syntax
(importtagged-sig-spec...)
syntax
(exporttagged-sig-spec...)
syntax
(linklinkage-decl...)
syntax
(tagidsig-spec)
(tagidsig-id)
syntax
(init-dependtagged-sig-id...)
syntax
extends
syntax
(invoke-unitunit-expr)
(invoke-unitunit-expr(importtagged-sig-spec...))
syntax
(define-values/invoke-unitunit-expr
(importtagged-sig-spec...)
(exporttagged-sig-spec...))
syntax
(compound-unit
(importlink-binding...)
(exporttagged-link-id...)
(linklinkage-decl...))

link-binding  =(link-id:tagged-sig-id)
             
tagged-link-id=(tagidlink-id)
             |link-id
             
linkage-decl  =((link-binding...)unit-exprtagged-link-id...)
syntax
(define-unitunit-id
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-body-expr-or-defn
...)
syntax
(compound-unit/infer
(importtagged-infer-link-import...)
(exporttagged-infer-link-export...)
(linkinfer-linkage-decl...))

tagged-infer-link-import=tagged-sig-id
                       |(link-id:tagged-sig-id)
                       
tagged-infer-link-export=(tagidinfer-link-export)
                       |infer-link-export
                       
infer-link-export       =link-id
                       |sig-id
                       
infer-linkage-decl      =((link-binding...)unit-id
                           tagged-link-id...)
                       |unit-id
syntax
(define-compound-unitid
(importlink-binding...)
(exporttagged-link-id...)
(linklinkage-decl...))
syntax
(define-compound-unit/inferid
(importlink-binding...)
(exporttagged-infer-link-export...)
(linkinfer-linkage-decl...))
syntax
(define-unit-bindingunit-id
unit-expr
(importtagged-sig-spec...+)
(exporttagged-sig-spec...+)
init-depends-decl)
syntax
(invoke-unit/inferunit-spec)

unit-spec=unit-id
        |(linklink-unit-id...)
syntax
(define-values/invoke-unit/infermaybe-exportsunit-spec)

maybe-exports=
            |(exporttagged-sig-spec...)
            
unit-spec    =unit-id
            |(linklink-unit-id...)
syntax
(unit-from-contexttagged-sig-spec)
syntax
(define-unit-from-contextidtagged-sig-spec)
syntax
(unit/new-import-export
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
((tagged-sig-spec...)unit-exprtagged-sig-spec))
syntax
(define-unit/new-import-exportunit-id
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
((tagged-sig-spec...)unit-exprtagged-sig-spec))
syntax
(unit/s
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-id)
syntax
(define-unit/sname-id
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-id)
syntax
(define-signature-formsig-form-idexpr)
(define-signature-form(sig-form-idid)body...+)
syntax
(struct/ctcid([fieldcontract-expr]...)struct-option...)

field        =id
            |[id#:mutable]
            
struct-option=#:mutable
            |#:omit-constructor
            |#:omit-define-syntaxes
            |#:omit-define-values
procedure
(unit?v)->boolean?
v:any/c
syntax
(provide-signature-elementssig-spec...)
syntax
(unit/c(importsig-block...)(exportsig-block...))

sig-block=(tagged-sig-id[idcontract]...)
        |tagged-sig-id
syntax
(define-unit/contractunit-id
(importsig-spec-block...)
(exportsig-spec-block...)
init-depends-decl
unit-body-expr-or-defn
...)

sig-spec-block=(tagged-sig-spec[idcontract]...)
             |tagged-sig-spec
procedure
(unit-static-signaturesunit-identifier
                      err-syntax)    
->(list/c(cons/c(or/csymbol?#f)
    identifier?))
    (list/c(cons/c(or/csymbol?#f)
    identifier?))
unit-identifier:identifier?
err-syntax:syntax?
procedure
(signature-memberssig-identifier 
                 err-syntax)   ->(or/cidentifier?#f)
                                     (listofidentifier?)
                                     (listofidentifier?)
                                     (listofidentifier?)
sig-identifier:identifier?
err-syntax:syntax?
procedure
(flat-named-contract type-name   
                    predicate   
                   [generator])->flat-contract?
type-name:any/c
predicate:(or/cflat-contract?(any/c. -> .any))
generator:(or/c#f(->contract(->int?any)))=#f
value
any/c:flat-contract?
value
none/c:flat-contract?
procedure
(or/ccontract...)->contract?
contract:contract?
procedure
(and/ccontract...)->contract?
contract:(or/ccontract?(any/c. -> .any/c))
procedure
(not/cflat-contract)->flat-contract?
flat-contract:(or/cflat-contract?(any/c. -> .any/c))
procedure
(=/cz)->flat-contract?
z:real?
procedure
(</cn)->flat-contract?
n:real?
procedure
(>/cn)->flat-contract?
n:real?
procedure
(<=/cn)->flat-contract?
n:real?
procedure
(>=/cn)->flat-contract?
n:real?
procedure
(between/cnm)->flat-contract?
n:real?
m:real?
procedure
(real-innm)->flat-contract?
n:real?
m:real?
procedure
(integer-injk)->flat-contract?
j:exact-integer?
k:exact-integer?
value
natural-number/c:flat-contract?
procedure
(string-len/clen)->flat-contract?
len:real?
value
false/c:flat-contract?
value
printable/c:flat-contract?
procedure
(one-of/cv...+)->flat-contract?
v:any/c
procedure
(symbolssym...+)->flat-contract?
sym:symbol?
procedure
(vectorof c                     
        [#:immutableimmutable 
         #:flat?flat?])      ->contract?
c:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
procedure
(vector-immutableofc)->contract?
c:contract?
procedure
(vector/c c                     
         ...                   
        [#:immutableimmutable 
         #:flat?flat?])      ->contract?
c:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
procedure
(vector-immutable/cc...)->contract?
c:contract?
procedure
(box/c c                     
     [#:immutableimmutable 
      #:flat?flat?])      ->contract?
c:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
procedure
(box-immutable/cc)->contract?
c:contract?
procedure
(listofc)->contract?
c:(or/ccontract?(any/c. -> .any/c))
procedure
(non-empty-listofc)->contract?
c:(or/ccontract?(any/c. -> .any/c))
procedure
(cons/ccar-ccdr-c)->contract?
car-c:contract?
cdr-c:contract?
procedure
(list/cc...)->contract?
c:(or/ccontract?(any/c. -> .any/c))
procedure
(syntax/cc)->flat-contract?
c:flat-contract?
syntax
(struct/cstruct-idcontract-expr...)
syntax
(struct/dcstruct-idfield-spec...)

field-spec         =[field-namemaybe-lazycontract-expr]
                  |[field-name(dep-field-name...)
                      maybe-lazy
                      maybe-contract-type
                      maybe-dep-state
                      contract-expr]
                  
field-name         =field-id
                  |(#:selectorselector-id)
                  |(field-id#:parentstruct-id)
                  
maybe-lazy         =
                  |#:lazy
                  
maybe-contract-type=
                  |#:flat
                  |#:chaperone
                  |#:impersonator
                  
maybe-dep-state    =
                  |#:depends-on-state
procedure
(parameter/cin[out])->contract?
in:contract?
out:contract?=in
procedure
(procedure-arity-includes/cn)->flat-contract?
n:exact-nonnegative-integer?
procedure
(hash/c key                   
       val                   
      [#:immutableimmutable 
       #:flat?flat?])      ->contract?
key:chaperone-contract?
val:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
syntax
(prompt-tag/ccontract...maybe-call/cc)

maybe-call/cc=
            |#:call/cccontract
            |#:call/cc(valuescontract...)

contract:contract?
procedure
(continuation-mark-key/ccontract)->contract?
contract:contract?
syntax
(flat-rec-contractidflat-contract-expr...)
syntax
(flat-murec-contract([idflat-contract-expr...]...)body...+)
syntax
any
procedure
(promise/cc)->contract?
c:contract?
procedure
(flat-contractpredicate)->flat-contract?
predicate:(any/c. -> .any/c)
procedure
(flat-contract-predicatev)->(any/c. -> .any/c)
v:flat-contract?
syntax
(->dom...range)

dom  =dom-expr
    |keyworddom-expr
    
range=range-expr
    |(valuesrange-expr...)
    |any
syntax
(->*(mandatory-dom...)optional-domsrestprerangepost)

mandatory-dom=dom-expr
            |keyworddom-expr
            
optional-doms=
            |(optional-dom...)
            
optional-dom =dom-expr
            |keyworddom-expr
            
rest         =
            |#:restrest-expr
            
pre          =
            |#:prepre-cond-expr
            
range        =range-expr
            |(valuesrange-expr...)
            |any
            
post         =
            |#:postpost-cond-expr
syntax
(->i(mandatory-dependent-dom...)
dependent-rest
pre-condition
dependent-range
post-condition)
(->i(mandatory-dependent-dom...)
(optional-dependent-dom...)
dependent-rest
pre-condition
dependent-range
post-condition)

mandatory-dependent-dom=id+ctc
                      |keywordid+ctc
                      
optional-dependent-dom =id+ctc
                      |keywordid+ctc
                      
dependent-rest         =
                      |#:restid+ctc
                      
pre-condition          =
                      |#:pre(id...)boolean-exprpre-condition
                      |#:pre/name(id...)stringboolean-exprpre-condition
                      
dependent-range        =any
                      |id+ctc
                      |un+ctc
                      |(valuesid+ctc...)
                      |(valuesun+ctc...)
                      
post-condition         =
                      |#:post(id...)boolean-exprpost-condition
                      |#:post/name(id...)stringboolean-exprpost-condition
                      
id+ctc                 =[idcontract-expr]
                      |[id(id...)contract-expr]
                      
un+ctc                 =[_contract-expr]
                      |[_(id...)contract-expr]
syntax
(->d(mandatory-dependent-dom...)
dependent-rest
pre-condition
dependent-range
post-condition)
(->d(mandatory-dependent-dom...)
(optional-dependent-dom...)
dependent-rest
pre-condition
dependent-range
post-condition)

mandatory-dependent-dom=[iddom-expr]
                      |keyword[iddom-expr]
                      
optional-dependent-dom =[iddom-expr]
                      |keyword[iddom-expr]
                      
dependent-rest         =
                      |#:restidrest-expr
                      
pre-condition          =
                      |#:preboolean-expr
                      |#:pre-condboolean-expr
                      
dependent-range        =any
                      |[_range-expr]
                      |(values[_range-expr]...)
                      |[idrange-expr]
                      |(values[idrange-expr]...)
                      
post-condition         =
                      |#:post-condboolean-expr
syntax
(case->(->dom-expr...restrange)...)

rest =
    |#:restrest-expr
    
range=range-expr
    |(valuesrange-expr...)
    |any
syntax
(unconstrained-domain->range-expr...)
value
predicate/c:contract?
value
the-unsupplied-arg:unsupplied-arg?
procedure
(unsupplied-arg?v)->boolean?
v:any/c
syntax
(parametric->/c(x...)c)
procedure
(new-/cname)->contract?
name:symbol?
procedure
(new-/cname)->contract?
name:symbol?
syntax
(contract-structid(field-id...))

(id/dcfield-spec...)

field-spec=[field-idcontract-expr]
         |[field-id(field-id...)contract-expr]
syntax
(define-contract-structid(field-id...))
procedure
(struct-type-property/cvalue-contract)->contract?
value-contract:contract?
syntax
(contract-outp/c-item...)

p/c-item      =(structid/super((idcontract-expr)...)
                 struct-option)
             |(renameorig-ididcontract-expr)
             |(idcontract-expr)
             |#:poly-variables
             |#:existspoly-variables
             |#:poly-variables
             |#:forallpoly-variables
             
poly-variables=identifier
             |(identifier...)
             
id/super      =id
             |(idsuper-id)
             
struct-option =
             |#:omit-constructor
syntax
(provide/contractp/c-item...)
syntax
(with-contractblame-id(wc-export...)free-var-list...body...+)
(with-contractblame-idresults-specfree-var-list...body...+)

wc-export    =(idcontract-expr)
            
result-spec  =#:resultcontract-expr
            |#:results(contract-expr...)
            
free-var-list=
            |#:freevaridcontract-expr
            |#:freevars([idcontract-expr]...)
syntax
(define/contractidcontract-exprfree-var-listinit-value-expr)
(define/contract(headargs)contract-exprfree-var-listbody...+)
syntax
(define-struct/contractstruct-id([fieldcontract-expr]...)
struct-option...)
(define-struct/contract(struct-idsuper-struct-id)
([fieldcontract-expr]...)
struct-option...)
syntax
current-contract-region
syntax
(contractcontract-exprto-protect-expr
positive-blame-exprnegative-blame-expr)
(contractcontract-exprto-protect-expr
positive-blame-exprnegative-blame-expr
value-name-exprsource-location-expr)
procedure
(make-contract[#:namename           
              #:first-ordertest    
              #:projectionproj     
              #:strongerstronger])->contract?
name:any/c='anonymous-contract
test:(->any/cany/c)=((x)#t)
proj:(->blame?(->any/cany/c))
    =((b)
         ((x)
         (if(testx)
         x
         (raise-blame-error
         bx
         '(expected:"~a"given:"~e")
         namex))))
stronger:(or/c#f(->contract?contract?boolean?))=#f
procedure
(make-chaperone-contract[#:namename          
                        #:first-ordertest   
                        #:projectionproj    
                        #:strongerstronger])
->chaperone-contract?
name:any/c='anonymous-chaperone-contract
test:(->any/cany/c)=((x)#t)
proj:(->blame?(->any/cany/c))
    =((b)
         ((x)
         (if(testx)
         x
         (raise-blame-error
         bx
         '(expected:"~a"given:"~e")
         namex))))
stronger:(or/c#f(->contract?contract?boolean?))=#f
procedure
(make-flat-contract[#:namename           
                   #:first-ordertest    
                   #:projectionproj     
                   #:strongerstronger])->flat-contract?
name:any/c='anonymous-flat-contract
test:(->any/cany/c)=((x)#t)
proj:(->blame?(->any/cany/c))
    =((b)
         ((x)
         (if(testx)
         x
         (raise-blame-error
         bx
         '(expected:"~a"given:"~e")
         namex))))
stronger:(or/c#f(->contract?contract?boolean?))=#f
procedure
(build-compound-type-namec/s...)->any
c/s:any/c
procedure
(coerce-contractidx)->contract?
id:symbol?
x:any/c
procedure
(coerce-contractsidxs)->(listofcontract?)
id:symbol?
xs:(listofany/c)
procedure
(coerce-chaperone-contractidx)->chaperone-contract?
id:symbol?
x:any/c
procedure
(coerce-chaperone-contractsidx)->(listofchaperone-contract?)
id:symbol?
x:(listofany/c)
procedure
(coerce-flat-contractidx)->flat-contract?
id:symbol?
x:any/c
procedure
(coerce-flat-contractsidx)->(listofflat-contract?)
id:symbol?
x:(listofany/c)
procedure
(coerce-contract/fx)->(or/ccontract?#f)
x:any/c
procedure
(blame?x)->boolean?
x:any/c
procedure
(blame-add-context blame                 
                  context               
                 [#:importantimportant 
                  #:swap?swap?])      ->blame?
blame:blame?
context:(or/cstring?#f)
important:(or/cstring?#f)=#f
swap?:boolean?=#f
procedure
(blame-positiveb)->any/c
b:blame?
procedure
(blame-negativeb)->any/c
b:blame?
procedure
(blame-contractb)->any/c
b:blame?
procedure
(blame-valueb)->any/c
b:blame?
procedure
(blame-sourceb)->srcloc?
b:blame?
procedure
(blame-swapb)->blame?
b:blame?
procedure
(blame-original?b)->boolean?
b:blame?
procedure
(blame-swapped?b)->boolean?
b:blame?
procedure
(blame-replace-negativebneg)->blame?
b:blame?
neg:any/c
procedure
(blame-updatebposneg)->blame?
b:blame?
pos:any/c
neg:any/c
procedure
(raise-blame-errorbxfmtv...)->none/c
b:blame?
x:any/c
fmt:(or/cstring?
        (listof(or/cstring?
        'given'given:
        'expected'expected:)))
v:any/c
struct
(structexn:fail:contract:blameexn:fail:contract(object)
      #:extra-constructor-namemake-exn:fail:contract:blame)
object:blame?
parameter
(current-blame-format)->(->blame?any/cstring?string?)
(current-blame-formatproc)->void?
proc:(->blame?any/cstring?string?)
value
prop:contract:struct-type-property?
value
prop:chaperone-contract:struct-type-property?
value
prop:flat-contract:struct-type-property?
value
prop:contracted:struct-type-property?
value
impersonator-prop:contracted:impersonator-property?
procedure
(build-flat-contract-property[#:nameget-name              
                             #:first-orderget-first-order
                             #:projectionget-projection  
                             #:strongerstronger          
                             #:generatorgenerator])      
->flat-contract-property?
get-name:(->contract?any/c)
        =((c)'anonymous-flat-contract)
get-first-order:(->contract?(->any/cboolean?))
               =((c)((x)#t))
get-projection:(->contract?(->blame?(->any/cany/c)))
              =((c)
                   ((b)
                   ((x)
                   (if((get-first-orderc)x)
                   x
                   (raise-blame-error
                   bx'(expected:"~a"given:"~e")(get-namec)x)))))
stronger:(or/c(->contract?contract?boolean?)#f)=#f
generator:(or/c(->number?(listof(listany/ccontract?))any/c)#f)
         =#f
procedure
(build-chaperone-contract-property                               
                                 [#:nameget-name              
                                  #:first-orderget-first-order
                                  #:projectionget-projection  
                                  #:strongerstronger          
                                  #:generatorgenerator])      
->chaperone-contract-property?
get-name:(->contract?any/c)
        =((c)'anonymous-chaperone-contract)
get-first-order:(->contract?(->any/cboolean?))
               =((c)((x)#t))
get-projection:(->contract?(->blame?(->any/cany/c)))
              =((c)
                   ((b)
                   ((x)
                   (if((get-first-orderc)x)
                   x
                   (raise-blame-error
                   bx'(expected:"~a"given:"~e")(get-namec)x)))))
stronger:(or/c(->contract?contract?boolean?)#f)=#f
generator:(or/c(->number?(listof(listany/ccontract?))any/c)#f)
         =#f
procedure
(build-contract-property[#:nameget-name              
                        #:first-orderget-first-order
                        #:projectionget-projection  
                        #:strongerstronger          
                        #:generatorgenerator])      
->contract-property?
get-name:(->contract?any/c)=((c)'anonymous-contract)
get-first-order:(->contract?(->any/cboolean?))
               =((c)((x)#t))
get-projection:(->contract?(->blame?(->any/cany/c)))
              =((c)
                   ((b)
                   ((x)
                   (if((get-first-orderc)x)
                   x
                   (raise-blame-error
                   bx'(expected:"~a"given:"~e")(get-namec)x)))))
stronger:(or/c(->contract?contract?boolean?)#f)=#f
generator:(or/c(->number?(listof(listany/ccontract?))any/c)#f)
         =#f
procedure
(contract-property?x)->boolean?
x:any/c
procedure
(chaperone-contract-property?x)->boolean?
x:any/c
procedure
(flat-contract-property?x)->boolean?
x:any/c
syntax
(define/final-propheaderbody...)

header=main-id
     |(main-idid...)
     |(main-idid.... id)
syntax
(define/subexpression-pos-propheaderbody...)

header=main-id
     |(main-idid...)
     |(main-idid.... id)
procedure
(contract-stronger?xy)->boolean?
x:contract?
y:contract?
procedure
(contract-first-order-passes?contractv)->boolean?
contract:contract?
v:any/c
procedure
(contract-first-orderc)->(->any/cboolean?)
c:contract?
procedure
(contract?v)->boolean?
v:any/c
procedure
(chaperone-contract?v)->boolean?
v:any/c
procedure
(impersonator-contract?v)->boolean?
v:any/c
procedure
(flat-contract?v)->boolean?
v:any/c
procedure
(contract-namec)->any/c
c:contract?
procedure
(value-contractv)->contract?
v:has-contract?
procedure
(has-contract?v)->boolean?
v:any/c
procedure
(contract-projectionc)->(->blame?(->any/cany/c))
c:contract?
procedure
(make-none/csexp-name)->contract?
sexp-name:any/c
syntax
(recursive-contractcontract-expr)
(recursive-contractcontract-exprtype)
syntax
(opt/ccontract-exprmaybe-name)

maybe-name=
         |#:error-nameid
syntax
(define-opt/c(idid...)expr)
value
contract-continuation-mark-key:continuation-mark-key?
procedure
(make-proj-contractnameprojfirst-order)->contract?
name:any/c
proj:(or/c(->any/c
         any/c
         (list/cany/cany/c)
         contact?
         (->any/cany/c))
         (->any/c
         any/c
         (list/cany/cany/c)
         contact?
         boolean?
         (->any/cany/c)))
first-order:(->any/cboolean?)
procedure
(raise-contract-errorval      
                    src      
                    pos      
                    name     
                    fmt      
                    arg...)->any/c
val:any/c
src:any/c
pos:any/c
name:any/c
fmt:string?
arg:any/c
procedure
(contract-procc)
->(->*(symbol?symbol?(or/csyntax?(list/cany/cany/c)))
    (boolean?)
    (->any/cany))
c:contract?
procedure
(contract-random-generatectcfuel[fail])->any/c
ctc:contract?
fuel:int?
fail:(->any/c)=(()(error...))
syntax
(matchval-exprclause...)

clause=[patbody...+]
     |[pat(=>id)body...+]
     |[pat#:whencond-exprbody...+]
syntax
(match*(val-expr...+)clause*...)

clause*=[(pat...+)body...+]
      |[(pat...+)(=>id)body...+]
      |[(pat...+)#:whencond-exprbody...+]
syntax
(match/valuesexprclauseclause...)
syntax
(define/match(headargs)
match*-clause...)

head         =id
            |(headargs)
            
args         =arg...
            |arg....rest-id
            
arg          =arg-id
            |[arg-iddefault-expr]
            |keywordarg-id
            |keyword[arg-iddefault-expr]
            
match*-clause=[(pat...+)body...+]
            |[(pat...+)(=>id)body...+]
            |[(pat...+)#:whencond-exprbody...+]
syntax
(match-lambdaclause...)
syntax
(match-lambda*clause...)
syntax
(match-lambda**clause*...)
syntax
(match-let([patexpr]...)body...+)
syntax
(match-let*([patexpr]...)body...+)
syntax
(match-let-values([(pat...)expr]...)body...+)
syntax
(match-let*-values([(pat...)expr]...)body...+)
syntax
(match-letrec([patexpr]...)body...+)
syntax
(match-definepatexpr)
syntax
(match-define-values(patpats...)expr)
procedure
(exn:misc:match?v)->boolean?
v:any/c
syntax
(failure-cont)
syntax
(define-match-expanderidproc-expr)
(define-match-expanderidproc-exprproc-expr)
value
prop:match-expander:struct-type-property?
value
prop:legacy-match-expander:struct-type-property?
parameter
(match-equality-test)->(any/cany/c. -> .any)
(match-equality-testcomp-proc)->void?
comp-proc:(any/cany/c. -> .any)
syntax
(match/derivedval-exproriginal-datumclause...)
syntax
(match*/derived(val-expr...)original-datumclause*...)
syntax
(==valcomparator)
(==val)
syntax
(struct*struct-id([fieldpat]...))
procedure
(valuesv...)->any
v:any/c
procedure
(call-with-valuesgeneratorreceiver)->any
generator:(->any)
receiver:procedure?
procedure
(raisev[barrier?])->any
v:any/c
barrier?:any/c=#t
procedure
(errorsym)->any
sym:symbol?
(errormsgv...)->any
msg:string?
v:any/c
(errorsrcformatv...)->any
src:symbol?
format:string?
v:any/c
procedure
(raise-user-errorsym)->any
sym:symbol?
(raise-user-errormsgv...)->any
msg:string?
v:any/c
(raise-user-errorsrcformatv...)->any
src:symbol?
format:string?
v:any/c
procedure
(raise-argument-errornameexpectedv)->any
name:symbol?
expected:string?
v:any/c
(raise-argument-errorname     
                    expected 
                    bad-pos  
                    v...)  ->any
name:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-result-errornameexpectedv)->any
name:symbol?
expected:string?
v:any/c
(raise-result-errorname     
                  expected 
                  bad-pos  
                  v...)  ->any
name:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-arguments-errorname    
                     message 
                     field   
                     v...   
                     ...)   ->any
name:symbol?
message:string?
field:string?
v:any/c
procedure
(raise-range-errorname             
                 type-description 
                 index-prefix     
                 index            
                 in-value         
                 lower-bound      
                 upper-bound      
                 alt-lower-bound)->any
name:symbol?
type-description:string?
index-prefix:string?
index:exact-integer?
in-value:any/c
lower-bound:exact-integer?
upper-bound:exact-integer?
alt-lower-bound:(or/c#fexact-integer?)
procedure
(raise-type-errornameexpectedv)->any
name:symbol?
expected:string?
v:any/c
(raise-type-errornameexpectedbad-posv...)->any
name:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-mismatch-errorname    
                    message 
                    v...+  
                    ...+)  ->any
name:symbol?
message:string?
v:any/c
procedure
(raise-arity-errornamearity-v[arg-v...])->any
name:(or/csymbol?procedure?)
arity-v:(or/cexact-nonnegative-integer?
            arity-at-least?
            (listof
            (or/cexact-nonnegative-integer?
            arity-at-least?)))
arg-v:any/c=#f
procedure
(raise-syntax-error name            
                   message         
                  [expr            
                   sub-expr        
                   extra-sources])->any
name:(or/csymbol?#f)
message:string?
expr:any/c=#f
sub-expr:any/c=#f
extra-sources:(listofsyntax?)=null
procedure
(call-with-exception-handlerfthunk)->any
f:(any/c. -> .any)
thunk:(->any)
parameter
(uncaught-exception-handler)->(any/c. -> .any)
(uncaught-exception-handlerf)->void?
f:(any/c. -> .any)
syntax
(with-handlers([pred-exprhandler-expr]...)
body...+)
syntax
(with-handlers*([pred-exprhandler-expr]...)
body...+)
parameter
(error-escape-handler)->(->any)
(error-escape-handlerproc)->void?
proc:(->any)
parameter
(error-display-handler)->(string?any/c. -> .any)
(error-display-handlerproc)->void?
proc:(string?any/c. -> .any)
parameter
(error-print-width)->(and/cexact-integer?(>=/c3))
(error-print-widthwidth)->void?
width:(and/cexact-integer?(>=/c3))
parameter
(error-print-context-length)->exact-nonnegative-integer?
(error-print-context-lengthcnt)->void?
cnt:exact-nonnegative-integer?
parameter
(error-value->string-handler)
->(any/cexact-nonnegative-integer?
    . -> .
    string?)
(error-value->string-handlerproc)->void?
proc:(any/cexact-nonnegative-integer?
         . -> .
         string?)
parameter
(error-print-source-location)->boolean?
(error-print-source-locationinclude?)->void?
include?:any/c
struct
(structexn(message continuation-marks)
      #:extra-constructor-namemake-exn
      #:transparent)
message:string?
continuation-marks:continuation-mark-set?
struct
(structexn:failexn()
      #:extra-constructor-namemake-exn:fail
      #:transparent)
struct
(structexn:fail:contractexn:fail()
      #:extra-constructor-namemake-exn:fail:contract
      #:transparent)
struct
(structexn:fail:contract:arityexn:fail:contract()
      #:extra-constructor-namemake-exn:fail:contract:arity
      #:transparent)
struct
(structexn:fail:contract:divide-by-zeroexn:fail:contract()
      #:extra-constructor-name
      make-exn:fail:contract:divide-by-zero
      #:transparent)
struct
(structexn:fail:contract:non-fixnum-resultexn:fail:contract()
      #:extra-constructor-name
      make-exn:fail:contract:non-fixnum-result
      #:transparent)
struct
(structexn:fail:contract:continuationexn:fail:contract()
      #:extra-constructor-name
      make-exn:fail:contract:continuation
      #:transparent)
struct
(structexn:fail:contract:variableexn:fail:contract(id)
      #:extra-constructor-namemake-exn:fail:contract:variable
      #:transparent)
id:symbol?
struct
(structexn:fail:syntaxexn:fail(exprs)
      #:extra-constructor-namemake-exn:fail:syntax
      #:transparent)
exprs:(listofsyntax?)
struct
(structexn:fail:syntax:unboundexn:fail:syntax()
      #:extra-constructor-namemake-exn:fail:syntax:unbound
      #:transparent)
struct
(structexn:fail:syntax:missing-moduleexn:fail:syntax(path)
      #:extra-constructor-name
      make-exn:fail:syntax:missing-module
      #:transparent)
path:module-path?
struct
(structexn:fail:readexn:fail(srclocs)
      #:extra-constructor-namemake-exn:fail:read
      #:transparent)
srclocs:(listofsrcloc?)
struct
(structexn:fail:read:eofexn:fail:read()
      #:extra-constructor-namemake-exn:fail:read:eof
      #:transparent)
struct
(structexn:fail:read:non-charexn:fail:read()
      #:extra-constructor-namemake-exn:fail:read:non-char
      #:transparent)
struct
(structexn:fail:filesystemexn:fail()
      #:extra-constructor-namemake-exn:fail:filesystem
      #:transparent)
struct
(structexn:fail:filesystem:existsexn:fail:filesystem()
      #:extra-constructor-namemake-exn:fail:filesystem:exists
      #:transparent)
struct
(structexn:fail:filesystem:versionexn:fail:filesystem()
      #:extra-constructor-namemake-exn:fail:filesystem:version
      #:transparent)
struct
(structexn:fail:filesystem:errnoexn:fail:filesystem(errno)
      #:extra-constructor-namemake-exn:fail:filesystem:errno
      #:transparent)
errno:(cons/cexact-integer?(or/c'posix'windows'gai))
struct
(structexn:fail:filesystem:missing-moduleexn:fail:filesystem
                                                           (path)
      #:extra-constructor-name
      make-exn:fail:filesystem:missing-module
      #:transparent)
path:module-path?
struct
(structexn:fail:networkexn:fail()
      #:extra-constructor-namemake-exn:fail:network
      #:transparent)
struct
(structexn:fail:network:errnoexn:fail:network(errno)
      #:extra-constructor-namemake-exn:fail:network:errno
      #:transparent)
errno:(cons/cexact-integer?(or/c'posix'windows'gai))
struct
(structexn:fail:out-of-memoryexn:fail()
      #:extra-constructor-namemake-exn:fail:out-of-memory
      #:transparent)
struct
(structexn:fail:unsupportedexn:fail()
      #:extra-constructor-namemake-exn:fail:unsupported
      #:transparent)
struct
(structexn:fail:userexn:fail()
      #:extra-constructor-namemake-exn:fail:user
      #:transparent)
struct
(structexn:breakexn(continuation)
      #:extra-constructor-namemake-exn:break
      #:transparent)
continuation:continuation?
struct
(structexn:break:hang-upexn:break()
      #:extra-constructor-namemake-exn:break:hang-up
      #:transparent)
struct
(structexn:break:terminateexn:break()
      #:extra-constructor-namemake-exn:break:terminate
      #:transparent)
value
prop:exn:srclocs:struct-type-property?
procedure
(exn:srclocs?v)->boolean?
v:any/c
procedure
(exn:srclocs-accessorv)
->(exn:srclocs?. -> .(listofsrcloc))
v:exn:srclocs?
struct
(structsrcloc(source line column position span)
      #:extra-constructor-namemake-srcloc
      #:transparent)
source:any/c
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:(or/cexact-positive-integer?#f)
span:(or/cexact-nonnegative-integer?#f)
procedure
(srcloc->stringsrcloc)->(or/cstring?#f)
srcloc:srcloc?
value
prop:exn:missing-module:struct-type-property?
procedure
(exn:missing-module?v)->boolean?
v:any/c
procedure
(exn:missing-module-accessorv)
->(exn:missing-module?. -> .module-path?)
v:exn:srclocs?
procedure
(promise?v)->boolean?
v:any/c
syntax
(delaybody...+)
syntax
(lazybody...+)
procedure
(forcev)->any
v:any/c
procedure
(promise-forced?promise)->boolean?
promise:promise?
procedure
(promise-running?promise)->boolean?
promise:promise?
syntax
(delay/namebody...+)
syntax
(delay/strictbody...+)
syntax
(delay/syncbody...+)
syntax
(delay/threadbody/option...+)

body/option=body
          |#:groupthread-group-expr
syntax
(delay/idlebody/option...+)

body/option=body
          |#:wait-forwait-evt-expr
          |#:work-whilewhile-evt-expr
          |#:ticktick-secs-expr
          |#:useuse-ratio-expr
procedure
(call-with-continuation-prompt proc       
                             [prompt-tag 
                              handler]   
                              arg...)  ->any
proc:procedure?
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
handler:(or/cprocedure?#f)=#f
arg:any/c
procedure
(abort-current-continuationprompt-tag 
                          v...)    ->any
prompt-tag:any/c
v:any/c
procedure
(make-continuation-prompt-tag)->continuation-prompt-tag?
(make-continuation-prompt-tagsym)->continuation-prompt-tag?
sym:symbol?
procedure
(default-continuation-prompt-tag)->continuation-prompt-tag?
procedure
(call-with-current-continuation proc         
                              [prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call/ccproc[prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call-with-composable-continuation proc         
                                 [prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call-with-escape-continuationproc)->any
proc:(continuation?. -> .any)
procedure
(call/ecproc)->any
proc:(continuation?. -> .any)
syntax
(let/cckbody...+)
syntax
(let/eckbody...+)
procedure
(call-with-continuation-barrierthunk)->any
thunk:(->any)
procedure
(continuation-prompt-available? prompt-tag 
                              [cont])    ->any
prompt-tag:continuation-prompt-tag?
cont:continuation?=(call/ccvalues)
procedure
(continuation?v)->boolean?
v:any/c
procedure
(continuation-prompt-tag?v)->boolean?
v:any/c
procedure
(dynamic-windpre-thunk   
            value-thunk 
            post-thunk)->any
pre-thunk:(->any)
value-thunk:(->any)
post-thunk:(->any)
procedure
(call/promptproc[prompt-taghandler]arg...)->any
proc:procedure?
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
handler:(or/cprocedure?#f)=#f
arg:any/c
procedure
(abort/ccprompt-tagv...)->any
prompt-tag:any/c
v:any/c
procedure
(call/compproc[prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(abortv...)->any
v:any/c
syntax
(%expr)
(%exprhandler-expr)
(%exprhandler-expr#:tagtag-expr)
procedure
(fcontrolv#:tagprompt-tag)->any
v:any/c
prompt-tag:(default-continuation-prompt-tag)
syntax
(promptexpr...+)
syntax
(controlidexpr...+)
syntax
(prompt-atprompt-tag-exprexpr...+)
syntax
(control-atprompt-tag-expridexpr...+)
syntax
(resetexpr...+)
syntax
(shiftidexpr...+)
syntax
(reset-atprompt-tag-exprexpr...+)
syntax
(shift-atprompt-tag-expridentifierexpr...+)
syntax
(prompt0expr...+)
syntax
(reset0expr...+)
syntax
(control0idexpr...+)
syntax
(shift0idexpr...+)
syntax
(prompt0-atprompt-tag-exprexpr...+)
syntax
(reset0-atprompt-tag-exprexpr...+)
syntax
(control0-atprompt-tag-expridexpr...+)
syntax
(shift0-atprompt-tag-expridexpr...+)
procedure
(spawnproc)->any
proc:((any/c. -> .any). -> .any)
procedure
(splitterproc)->any
proc:(((->any). -> .any)
         ((continuation?. -> .any). -> .any)
         . -> .any)
procedure
(new-prompt)->any
syntax
(setprompt-exprexpr...+)
syntax
(cuptoprompt-expridexpr...+)
procedure
(continuation-markscont[prompt-tag])->continuation-mark-set?
cont:(or/ccontinuation?thread?#f)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(current-continuation-marks[prompt-tag])
->continuation-mark-set?
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(continuation-mark-set->list mark-set     
                            key-v        
                           [prompt-tag])->list?
mark-set:continuation-mark-set?
key-v:any/c
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(make-continuation-mark-key)->continuation-mark-key?
(make-continuation-mark-keysym)->continuation-mark-key?
sym:symbol?
procedure
(continuation-mark-set->list* mark-set     
                             key-list     
                            [none-v       
                             prompt-tag])->(listofvector?)
mark-set:continuation-mark-set?
key-list:(listofany/c)
none-v:any/c=#f
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(continuation-mark-set-first mark-set     
                            key-v        
                           [none-v       
                            prompt-tag])->any
mark-set:(or/ccontinuation-mark-set?#f)
key-v:any/c
none-v:any/c=#f
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call-with-immediate-continuation-mark key-v       
                                      proc        
                                     [default-v])->any
key-v:any/c
proc:(any/c. -> .any)
default-v:any/c=#f
procedure
(continuation-mark-key?v)->boolean?
v:any/c
procedure
(continuation-mark-set?v)->boolean?
v:any/c
procedure
(continuation-mark-set->contextmark-set)->list?
mark-set:continuation-mark-set?
procedure
(break-enabled)->boolean?
(break-enabledon?)->void?
on?:any/c
syntax
(parameterize-breakboolean-exprbody...+)
procedure
(current-break-parameterization)->break-parameterization?
procedure
(call-with-break-parameterizationbreak-param 
                                thunk)     ->any
break-param:break-parameterization?
thunk:(->any)
procedure
(exit[v])->any
v:any/c=#t
parameter
(exit-handler)->(any/c. -> .any)
(exit-handlerproc)->void?
proc:(any/c. -> .any)
parameter
(executable-yield-handler)->(byte?. -> .any)
(executable-yield-handlerproc)->void?
proc:(byte?. -> .any)
procedure
(threadthunk)->thread?
thunk:(->any)
procedure
(thread?v)->thread?
v:any/c
procedure
(current-thread)->thread?
procedure
(thread/suspend-to-killthunk)->thread
thunk:(->any)
procedure
(call-in-nested-threadthunk[cust])->any
thunk:(->any)
cust:custodian?=(current-custodian)
procedure
(thread-suspendthd)->void?
thd:thread?
procedure
(thread-resumethd[benefactor])->void?
thd:thread?
benefactor:(or/cthread?custodian?#f)=#f
procedure
(kill-threadthd)->void?
thd:thread?
procedure
(break-threadthd[kind])->void?
thd:thread?
kind:(or/c#f'hang-up'terminate)=#f
procedure
(sleep[secs])->void?
secs:(>=/c0)=0
procedure
(thread-running?thd)->any
thd:thread?
procedure
(thread-dead?thd)->any
thd:thread?
procedure
(thread-waitthd)->void?
thd:thread?
procedure
(thread-dead-evtthd)->evt?
thd:thread?
procedure
(thread-resume-evtthd)->evt?
thd:thread?
procedure
(thread-suspend-evtthd)->evt?
thd:thread?
procedure
(thread-sendthdv[fail-thunk])->any
thd:thread?
v:any/c
fail-thunk:(or/c(->any)#f)
          =(lambda()(raise-mismatch-error....))
procedure
(thread-receive)->any/c
procedure
(thread-try-receive)->any/c
procedure
(thread-receive-evt)->evt?
procedure
(thread-rewind-receivelst)->void?
lst:list?
procedure
(evt?v)->boolean?
v:any/c
procedure
(syncevt...+)->any
evt:evt?
procedure
(sync/timeouttimeoutevt...+)->any
timeout:(or/c#f(and/creal?(not/cnegative?))(->any))
evt:evt?
procedure
(sync/enable-breakevt...+)->any
evt:evt?
procedure
(sync/timeout/enable-breaktimeoutevt...+)->any
timeout:(or/c#f(and/creal?(not/cnegative?))(->any))
evt:evt?
procedure
(choice-evtevt...)->evt?
evt:evt?
procedure
(wrap-evtevtwrap)->evt?
evt:evt?
wrap:(any/c.... -> .any)
procedure
(handle-evtevthandle)->handle-evt?
evt:evt?
handle:(any/c.... -> .any)
procedure
(guard-evtmaker)->evt?
maker:(->evt?)
procedure
(nack-guard-evtmaker)->evt?
maker:(evt?. -> .evt?)
procedure
(poll-guard-evtmaker)->evt?
maker:(boolean?. -> .evt?)
value
always-evt:evt?
value
never-evt:evt?
procedure
(system-idle-evt)->evt?
procedure
(alarm-evtmsecs)->evt?
msecs:real?
procedure
(handle-evt?evt)->boolean?
evt:evt?
value
prop:evt:struct-type-property?
parameter
(current-evt-pseudo-random-generator)
->pseudo-random-generator?
(current-evt-pseudo-random-generatorgenerator)->void?
generator:pseudo-random-generator?
procedure
(channel?v)->boolean?
v:any/c
procedure
(make-channel)->channel?
procedure
(channel-getch)->any
ch:channel?
procedure
(channel-try-getch)->any
ch:channel?
procedure
(channel-putchv)->void?
ch:channel?
v:any/c
procedure
(channel-put-evtchv)->channel-put-evt?
ch:channel?
v:any/c
procedure
(channel-put-evt?v)->boolean?
v:any/c
procedure
(semaphore?v)->boolean?
v:any/c
procedure
(make-semaphore[init])->semaphore?
init:exact-nonnegative-integer?=0
procedure
(semaphore-postsema)->void?
sema:semaphore?
procedure
(semaphore-waitsema)->void?
sema:semaphore?
procedure
(semaphore-try-wait?sema)->boolean?
sema:semaphore?
procedure
(semaphore-wait/enable-breaksema)->void?
sema:semaphore?
procedure
(semaphore-peek-evtsema)->semaphore-peek-evt?
sema:semaphore?
procedure
(semaphore-peek-evt?v)->boolean?
v:any/c
procedure
(call-with-semaphore sema            
                    proc            
                   [try-fail-thunk] 
                    arg...)       ->any
sema:semaphore?
proc:procedure?
try-fail-thunk:(or/c(->any)#f)=#f
arg:any/c
procedure
(call-with-semaphore/enable-break sema            
                                 proc            
                                [try-fail-thunk] 
                                 arg...)       ->any
sema:semaphore?
proc:procedure?
try-fail-thunk:(or/c(->any)#f)=#f
arg:any/c
procedure
(async-channel?v)->boolean?
v:any/c
procedure
(make-async-channel[limit])->async-channel?
limit:(or/cexact-positive-integer?#f)=#f
procedure
(async-channel-getach)->any/c
ach:async-channel?
procedure
(async-channel-try-getach)->any/c
ach:async-channel?
procedure
(async-channel-putachv)->void?
ach:async-channel?
v:any/c
procedure
(async-channel-put-evtachv)->evt?
ach:async-channel?
v:any/c
procedure
(thread-cell?v)->boolean?
v:any/c
procedure
(make-thread-cellv[preserved?])->thread-cell?
v:any/c
preserved?:any/c=#f
procedure
(thread-cell-refcell)->any
cell:thread-cell?
procedure
(thread-cell-set!cellv)->any
cell:thread-cell?
v:any/c
procedure
(current-preserved-thread-cell-values)->thread-cell-values?
(current-preserved-thread-cell-valuesthread-cell-vals)->void?
thread-cell-vals:thread-cell-values?
procedure
(thread-cell-values?v)->boolean?
v:any/c
procedure
(make-parameterv[guard])->parameter?
v:any/c
guard:(or/c(any/c. -> .any)#f)=#f
syntax
(parameterize([parameter-exprvalue-expr]...)
body...+)

parameter-expr:parameter?
syntax
(parameterize*((parameter-exprvalue-expr)...)
body...+)
procedure
(make-derived-parameterparameter 
                      guard     
                      wrap)    ->parameter?
parameter:parameter?
guard:(any/c. -> .any)
wrap:(any/c. -> .any)
procedure
(parameter?v)->boolean?
v:any/c
procedure
(parameter-procedure=?ab)->boolean?
a:parameter?
b:parameter?
procedure
(current-parameterization)->parameterization?
procedure
(call-with-parameterizationparameterization 
                          thunk)          ->any
parameterization:parameterization?
thunk:(->any)
procedure
(parameterization?v)->boolean?
v:any/c
procedure
(futurethunk)->future?
thunk:(->any)
procedure
(touchf)->any
f:future?
procedure
(futures-enabled?)->boolean?
procedure
(current-future)->(or/c#ffuture?)
procedure
(future?v)->boolean?
v:any/c
procedure
(would-be-futurethunk)->future?
thunk:(->any)
procedure
(processor-count)->exact-positive-integer?
procedure
(make-fsemaphoreinit)->fsemaphore?
init:exact-nonnegative-integer?
procedure
(fsemaphore?v)->boolean?
v:any/c
procedure
(fsemaphore-postfsema)->void?
fsema:fsemaphore?
procedure
(fsemaphore-waitfsema)->void?
fsema:fsemaphore?
procedure
(fsemaphore-try-wait?fsema)->boolean?
fsema:fsemaphore?
procedure
(fsemaphore-countfsema)->exact-nonnegative-integer?
fsema:fsemaphore?
procedure
(place-enabled?)->boolean?
procedure
(place?v)->boolean?
v:any/c
procedure
(place-channel?v)->boolean?
v:any/c
procedure
(dynamic-place module-path     
              start-name      
             [#:atlocation   
              #:namednamed])->place?
module-path:(or/cmodule-path?path?)
start-name:symbol?
location:(or/c#fplace-location?)=#f
named:any/c=#f
procedure
(dynamic-place* module-path 
               start-name  
              [#:inin     
               #:outout   
               #:errerr])->place?
                                (or/coutput-port?#f)
                                (or/cinput-port?#f)
                                (or/cinput-port?#f)
module-path:(or/cmodule-path?path?)
start-name:symbol?
in:(or/cinput-port?#f)=#f
out:(or/coutput-port?#f)=(current-output-port)
err:(or/coutput-port?#f)=(current-error-port)
syntax
(placeidbody...+)
syntax
(place*maybe-port...
id
body...+)

maybe-port=
         |#:inin-expr
         |#:outout-expr
         |#:errerr-expr
procedure
(place-waitp)->exact-integer?
p:place?
procedure
(place-dead-evtp)->evt?
p:place?
procedure
(place-killp)->void?
p:place?
procedure
(place-breakp[kind])->void?
p:place?
kind:(or/c#f'hang-up'terminate)=#f
procedure
(place-channel)->place-channel?place-channel?
procedure
(place-channel-putpchv)->void
pch:place-channel?
v:place-message-allowed?
procedure
(place-channel-getpch)->place-message-allowed?
pch:place-channel?
procedure
(place-channel-put/getpchv)->any/c
pch:place-channel?
v:any/c
procedure
(place-message-allowed?v)->boolean?
v:any/c
value
prop:place-location:struct-type-property?
procedure
(place-location?v)->boolean?
v:any/c
procedure
(engineproc)->engine?
proc:((any/c. -> .void?). -> .any/c)
procedure
(engine?v)->any
v:any/c
procedure
(engine-rununtilengine)->boolean?
until:(or/cevt?real?)
engine:engine?
procedure
(engine-resultengine)->any
engine:engine?
procedure
(engine-killengine)->void?
engine:engine?
syntax
(syntax-casestx-expr(literal-id...)
clause...)

clause      =[patternresult-expr]
           |[patternfender-exprresult-expr]
           
pattern     =_
           |id
           |(pattern...)
           |(pattern...+. pattern)
           |(pattern...patternellipsispattern...)
           |(pattern...patternellipsispattern.... pattern)
           |#(pattern...)
           |#(pattern...patternellipsispattern...)
           |#&pattern
           |#s(key-datumpattern...)
           |#s(key-datumpattern...patternellipsispattern...)
           |(ellipsisstat-pattern)
           |const
           
stat-pattern=id
           |(stat-pattern...)
           |(stat-pattern...+. stat-pattern)
           |#(stat-pattern...)
           |const
           
ellipsis    =...

_

id

(pattern...)

(pattern...+. pattern)

(pattern...patternellipsispattern...)

(pattern...patternellipsispattern.... pattern)

#(pattern...)

#(pattern...patternellipsispattern...)

#&pattern

#s(key-datumpattern...)

#s(key-datumpattern...patternellipsispattern...)

(ellipsisstat-pattern)

const
syntax
(syntax-case*stx-expr(literal-id...)id-compare-expr
clause...)
syntax
(with-syntax([patternstx-expr]...)
body...+)
syntax
(syntaxtemplate)

template     =id
            |(template-elem...)
            |(template-elem...+. template)
            |#(template-elem...)
            |#&template
            |#s(key-datumtemplate-elem...)
            |(ellipsisstat-template)
            |const
            
template-elem=templateellipsis...
            
stat-template=id
            |(stat-template...)
            |(stat-template.... stat-template)
            |#(stat-template...)
            |#&stat-template
            |#s(key-datumstat-template...)
            |const
            
ellipsis     =...

id

(template-elem...)

(template-elem.... template)

#(template-elem...)

#&template

#s(key-datumtemplate-elem...)

(ellipsisstat-template)

const
syntax
(quasisyntaxtemplate)
syntax
(unsyntaxexpr)
syntax
(unsyntax-splicingexpr)
syntax
(syntax/locstx-exprtemplate)
syntax
(quasisyntax/locstx-exprtemplate)
syntax
(quote-syntax/pruneid)
syntax
(syntax-rules(literal-id...)
[(id. pattern)template]...)
syntax
(syntax-id-rules(literal-id...)
[patterntemplate]...)
syntax
(define-syntax-rule(id. pattern)template)
syntax
...
syntax
_
procedure
(syntax-pattern-variable?v)->boolean?
v:any/c
procedure
(syntax?v)->boolean?
v:any/c
procedure
(identifier?v)->boolean?
v:any/c
procedure
(syntax-sourcestx)->any
stx:syntax?
procedure
(syntax-linestx)->(or/cexact-positive-integer?#f)
stx:syntax?
procedure
(syntax-columnstx)->(or/cexact-nonnegative-integer?#f)
stx:syntax?
procedure
(syntax-positionstx)->(or/cexact-positive-integer?#f)
stx:syntax?
procedure
(syntax-spanstx)->(or/cexact-nonnegative-integer?#f)
stx:syntax?
procedure
(syntax-original?stx)->boolean?
stx:syntax?
procedure
(syntax-source-modulestx[source?])
->(or/cmodule-path-index?symbol?path?resolved-module-path?#f)
stx:syntax?
source?:any/c=#f
procedure
(syntax-estx)->any
stx:syntax?
procedure
(syntax->liststx)->(or/clist?#f)
stx:syntax?
procedure
(syntax->datumstx)->any
stx:syntax?
procedure
(datum->syntaxctxtv[srclocpropignored])->syntax?
ctxt:(or/csyntax?#f)
v:any/c
srcloc:(or/csyntax?#f
           (list/cany/c
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f))
           (vector/cany/c
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)))
      =#f
prop:(or/csyntax?#f)=#f
ignored:(or/csyntax?#f)=#f
procedure
(datum-intern-literalv)->any/c
v:any/c
procedure
(syntax-shift-phase-levelstxshift)->syntax?
stx:syntax?
shift:(or/cexact-integer?#f)
procedure
(generate-temporariesstx-pair)->(listofidentifier?)
stx-pair:(orsyntax?list?)
procedure
(identifier-prune-lexical-context id-stx 
                                [syms])->identifier?
id-stx:identifier?
syms:(listofsymbol?)=(list(syntax-eid-stx))
procedure
(identifier-prune-to-source-moduleid-stx)->identifier?
id-stx:identifier?
procedure
(syntax-recertifynew-stx   
                old-stx   
                inspector 
                key)     ->syntax?
new-stx:syntax?
old-stx:syntax?
inspector:inspector?
key:any/c
procedure
(bound-identifier=?a-idb-id[phase-level])->boolean?
a-id:syntax?
b-id:syntax?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(free-identifier=? a-id            
                  b-id            
                 [a-phase-level   
                  b-phase-level])->boolean?
a-id:syntax?
b-id:syntax?
a-phase-level:(or/cexact-integer?#f)
             =(syntax-local-phase-level)
b-phase-level:(or/cexact-integer?#f)=a-phase-level
procedure
(free-transformer-identifier=?a-idb-id)->boolean?
a-id:syntax?
b-id:syntax?
procedure
(free-template-identifier=?a-idb-id)->boolean?
a-id:syntax?
b-id:syntax?
procedure
(free-label-identifier=?a-idb-id)->boolean?
a-id:syntax?
b-id:syntax?
procedure
(check-duplicate-identifierids)->(or/cidentifier?#f)
ids:(listofidentifier?)
procedure
(identifier-bindingid-stx[phase-level])
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    (or/c01)
    (or/cexact-integer?#f)
    (or/cexact-integer?#f)))
id-stx:syntax?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(identifier-transformer-bindingid-stx)
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    (or/c01)
    (or/cexact-integer?#f)
    (or/cexact-integer?#f)))
id-stx:syntax?
procedure
(identifier-template-bindingid-stx)
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    (or/c01)
    (or/cexact-integer?#f)
    (or/cexact-integer?#f)))
id-stx:syntax?
procedure
(identifier-label-bindingid-stx)
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    (or/c01)
    (or/cexact-integer?#f)
    (or/cexact-integer?#f)))
id-stx:syntax?
procedure
(identifier-binding-symbol id-stx        
                         [phase-level])->symbol?
id-stx:syntax?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(set!-transformer?v)->boolean?
v:any/c
procedure
(make-set!-transformerproc)->set!-transformer?
proc:(syntax?. -> .syntax?)
procedure
(set!-transformer-proceduretransformer)
->(syntax?. -> .syntax?)
transformer:set!-transformer?
value
prop:set!-transformer:struct-type-property?
procedure
(rename-transformer?v)->boolean?
v:any/c
procedure
(make-rename-transformer id-stx            
                       [delta-introduce])->rename-transformer?
id-stx:syntax?
delta-introduce:(identifier?. -> .identifier?)
               =(lambda(id)id)
procedure
(rename-transformer-targettransformer)->identifier?
transformer:rename-transformer?
value
prop:rename-transformer:struct-type-property?
procedure
(local-expand stx          
             context-v    
             stop-ids     
            [intdef-ctx])->syntax?
stx:syntax?
context-v:(or/c'expression'top-level'module'module-beginlist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?
               (and/cpair?
               (listofinternal-definition-context?))
               #f)
          =#f
procedure
(syntax-local-expand-expressionstx)->syntax?syntax?
stx:syntax?
procedure
(local-transformer-expand stx          
                         context-v    
                         stop-ids     
                        [intdef-ctx])->syntax?
stx:syntax?
context-v:(or/c'expression'top-levellist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?#f)=#f
procedure
(local-expand/capture-lifts stx        
                           context-v  
                           stop-ids   
                          [intdef-ctx 
                           lift-ctx])->syntax?
stx:syntax?
context-v:(or/c'expression'top-level'module'module-beginlist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?#f)=#f
lift-ctx:any/c=(gensym'lifts)
procedure
(local-transformer-expand/capture-lifts stx        
                                       context-v  
                                       stop-ids   
                                      [intdef-ctx 
                                       lift-ctx])->syntax?
stx:syntax?
context-v:(or/c'expression'top-levellist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?#f)=#f
lift-ctx:any/c=(gensym'lifts)
procedure
(internal-definition-context?v)->boolean?
v:any/c
procedure
(syntax-local-make-definition-context[intdef-ctx])
->internal-definition-context?
intdef-ctx:(or/cinternal-definition-context?#f)=#f
procedure
(syntax-local-bind-syntaxesid-list     
                          expr        
                          intdef-ctx)->void?
id-list:(listofidentifier?)
expr:(or/csyntax?#f)
intdef-ctx:internal-definition-context?
procedure
(internal-definition-context-sealintdef-ctx)->void?
intdef-ctx:internal-definition-context?
procedure
(identifier-remove-from-definition-contextid-stx     
                                         intdef-ctx)
->identifier?
id-stx:identifier?
intdef-ctx:(or/cinternal-definition-context?
               (listofinternal-definition-context?))
procedure
(syntax-local-value id-stx        
                  [failure-thunk 
                   intdef-ctx]) ->any
id-stx:syntax?
failure-thunk:(or/c(->any)#f)=#f
intdef-ctx:(or/cinternal-definition-context?=#f
               #f)
procedure
(syntax-local-value/immediate id-stx        
                            [failure-thunk 
                             intdef-ctx]) ->any
id-stx:syntax?
failure-thunk:(or/c(->any)#f)=#f
intdef-ctx:(or/cinternal-definition-context?=#f
               #f)
procedure
(syntax-local-lift-expressionstx)->identifier?
stx:syntax?
procedure
(syntax-local-lift-values-expressionnstx)
->(listofidentifier?)
n:exact-nonnegative-integer?
stx:syntax?
procedure
(syntax-local-lift-context)->any/c
procedure
(syntax-local-lift-module-end-declarationstx)->void?
stx:syntax?
procedure
(syntax-local-lift-requireraw-require-spec 
                         stx)            ->syntax?
raw-require-spec:any/c
stx:syntax?
procedure
(syntax-local-lift-provideraw-provide-spec-stx)->void?
raw-provide-spec-stx:syntax?
procedure
(syntax-local-name)->any/c
procedure
(syntax-local-context)
->(or/c'expression'top-level'module'module-beginlist?)
procedure
(syntax-local-phase-level)->(or/cexact-integer?#f)
procedure
(syntax-local-module-exportsmod-path)
->(listof(cons/c(or/cexact-integer?#f)(listofsymbol?)))
mod-path:(or/cmodule-path?
             (and/csyntax?
             (lambda(stx)
             (module-path?(syntax->datumstx)))))
procedure
(syntax-local-submodules)->(listofsymbol?)
procedure
(syntax-local-get-shadowerid-stx)->identifier?
id-stx:identifier?
procedure
(syntax-local-certifier[active?])
->((syntax?)(any/c(or/cprocedure?#f))
    . ->* .syntax?)
active?:boolean?=#f
procedure
(syntax-transforming?)->boolean?
procedure
(syntax-transforming-module-expression?)->boolean?
procedure
(syntax-local-introducestx)->syntax?
stx:syntax?
procedure
(make-syntax-introducer)->(syntax?. -> .syntax?)
procedure
(make-syntax-delta-introducer ext-stx      
                             base-stx     
                            [phase-level])
->(syntax?. -> .syntax?)
ext-stx:syntax?
base-stx:(or/csyntax?#f)
phase-level:(or/c#fexact-integer?)
           =(syntax-local-phase-level)
procedure
(syntax-local-make-delta-introducerid)
->(identifier?. -> .identifier?)
id:identifier?
procedure
(syntax-local-transforming-module-provides?)->boolean?
procedure
(syntax-local-module-defined-identifiers)
->(and/chash?immutable?)
procedure
(syntax-local-module-required-identifiersmod-path    
                                        phase-level)
->(listof(cons/c(or/cexact-integer?#f)
    (listofidentifier?)))
mod-path:(or/cmodule-path?#f)
phase-level:(or/cexact-integer?#f#t)
value
prop:liberal-define-context:struct-type-property?
procedure
(liberal-define-context?v)->boolean?
v:any/c
procedure
(expand-importstx)->(listofimport?)(listofimport-source?)
stx:syntax?
procedure
(make-require-transformerproc)->require-transformer?
proc:(syntax?. -> .(values
         (listofimport?)
         (listofimport-source?)))
value
prop:require-transformer:struct-type-property?
procedure
(require-transformer?v)->boolean?
v:any/c
struct
(structimport                               (local-id
                                          src-sym
                                          src-mod-path
                                          mode
                                          req-mode
                                          orig-mode
                                          orig-stx)
      #:extra-constructor-namemake-import)
local-id:identifier?
src-sym:symbol?
src-mod-path:(or/cmodule-path?
                 (and/csyntax?
                 (lambda(stx)
                 (module-path?(syntax->datumstx)))))
mode:(or/cexact-integer?#f)
req-mode:(or/cexact-integer?#f)
orig-mode:(or/cexact-integer?#f)
orig-stx:syntax?
struct
(structimport-source(mod-path-stx mode)
      #:extra-constructor-namemake-import-source)
mod-path-stx:(and/csyntax?
                 (lambda(x)
                 (module-path?(syntax->datumx))))
mode:(or/cexact-integer?#f)
parameter
(current-require-module-path)->(or/c#fmodule-path-index?)
(current-require-module-pathmodule-path)->void?
module-path:(or/c#fmodule-path-index?)
procedure
(convert-relative-module-pathmodule-path)
->(or/cmodule-path?
    (and/csyntax?
    (lambda(stx)
    (module-path?(syntax-estx)))))
module-path:(or/cmodule-path?
                (and/csyntax?
                (lambda(stx)
                (module-path?(syntax-estx)))))
procedure
(syntax-local-require-certifier)
->((syntax?)(or/c#f(syntax?. -> .syntax?))
    . ->* .syntax?)
procedure
(expand-exportstxmodes)->(listofexport?)
stx:syntax?
modes:(listof(or/cexact-integer?#f))
procedure
(pre-expand-exportstxmodes)->syntax?
stx:syntax?
modes:(listof(or/cexact-integer?#f))
procedure
(make-provide-transformerproc)->provide-transformer?
proc:(syntax?(listof(or/cexact-integer?#f))
         . -> .(listofexport?))
(make-provide-transformerprocpre-proc)
->(and/cprovide-transformer?provide-pre-transformer?)
proc:(syntax?(listof(or/cexact-integer?#f))
         . -> .(listofexport?))
pre-proc:(syntax?(listof(or/cexact-integer?#f))
             . -> .syntax?)
procedure
(make-provide-pre-transformerpre-proc)
->provide-pre-transformer?
pre-proc:(syntax?(listof(or/cexact-integer?#f))
             . -> .syntax?)
value
prop:provide-transformer:struct-type-property?
value
prop:provide-pre-transformer:struct-type-property?
procedure
(provide-transformer?v)->boolean?
v:any/c
procedure
(provide-pre-transformer?v)->boolean?
v:any/c
struct
(structexport(local-id out-sym mode protect? orig-stx)
      #:extra-constructor-namemake-export)
local-id:identifier?
out-sym:symbol?
mode:(or/cexact-integer?#f)
protect?:any/c
orig-stx:syntax?
procedure
(syntax-local-provide-certifier)
->((syntax?)(or/c#f(syntax?. -> .syntax?))
    . ->* .syntax?)
procedure
(syntax-procedure-alias-propertystx)
->(or/c#f
    (letrec([val?(recursive-contract
    (or/c(cons/cidentifier?identifier?)
    (cons/cval?val?)))])
    val?))
stx:syntax?
procedure
(syntax-procedure-converted-arguments-propertystx)
->(or/c#f
    (letrec([val?(recursive-contract
    (or/c(cons/cidentifier?identifier?)
    (cons/cval?val?)))])
    val?))
stx:syntax?
syntax
(define-syntax-parameteridexpr)
syntax
(syntax-parameterize([idexpr]...)body-expr...+)
procedure
(syntax-parameter-valueid-stx)->any
id-stx:syntax?
procedure
(make-parameter-rename-transformerid-stx)->any
id-stx:syntax?
syntax
splicing-let
syntax
splicing-letrec
syntax
splicing-let-values
syntax
splicing-letrec-values
syntax
splicing-let-syntax
syntax
splicing-letrec-syntax
syntax
splicing-let-syntaxes
syntax
splicing-letrec-syntaxes
syntax
splicing-letrec-syntaxes+values
syntax
splicing-local
syntax
splicing-syntax-parameterize
procedure
(syntax-propertystxkeyv)->syntax?
stx:syntax?
key:any/c
v:any/c
(syntax-propertystxkey)->any
stx:syntax?
key:any/c
procedure
(syntax-property-symbol-keysstx)->list?
stx:syntax?
procedure
(syntax-track-originnew-stx  
                   orig-stx 
                   id-stx) ->any
new-stx:syntax?
orig-stx:syntax?
id-stx:syntax?
procedure
(syntax-tainted?stx)->boolean?
stx:syntax?
procedure
(syntax-armstx[inspectoruse-mode?])->syntax?
stx:syntax?
inspector:(or/cinspector?#f)=#f
use-mode?:any/c=#f
procedure
(syntax-protectstx)->syntax?
stx:syntax?
procedure
(syntax-disarmstxinspector)->syntax?
stx:syntax?
inspector:(or/cinspector?#f)
procedure
(syntax-rearmstxfrom-stx[use-mode?])->syntax?
stx:syntax?
from-stx:syntax?
use-mode?:any/c=#f
procedure
(syntax-taintstx)->syntax?
stx:syntax?
procedure
(expandtop-level-form)->syntax?
top-level-form:any/c
procedure
(expand-syntaxstx)->syntax?
stx:syntax?
procedure
(expand-oncetop-level-form)->syntax?
top-level-form:any/c
procedure
(expand-syntax-oncestx)->syntax?
stx:syntax?
procedure
(expand-to-top-formtop-level-form)->syntax?
top-level-form:any/c
procedure
(expand-syntax-to-top-formstx)->syntax?
stx:syntax?
syntax
(includepath-spec)

path-spec=string
        |(filestring)
        |(libstring...+)
syntax
(include-at/relative-tocontextsourcepath-spec)
syntax
(include/readerpath-specreader-expr)
syntax
(include-at/relative-to/readercontextsourcepath-specreader-expr)
procedure
(format-id lctx             
          fmt              
          v...            
         [#:sourcesrc     
          #:propsprops    
          #:certignored])->identifier?
lctx:(or/csyntax?#f)
fmt:string?
v:(or/cstring?symbol?identifier?keyword?char?number?)
src:(or/csyntax?#f)=#f
props:(or/csyntax?#f)=#f
ignored:(or/csyntax?#f)=#f
procedure
(format-symbolfmtv...)->symbol?
fmt:string?
v:(or/cstring?symbol?identifier?keyword?char?number?)
syntax
(define/with-syntaxpatternstx-expr)

stx-expr:syntax?
parameter
(current-syntax-context)->(or/csyntax?false/c)
(current-syntax-contextstx)->void?
stx:(or/csyntax?false/c)
procedure
(wrong-syntaxstxformat-stringv...)->any
stx:syntax?
format-string:string?
v:any/c
parameter
(current-recorded-disappeared-uses)
->(or/c(listofidentifier?)false/c)
(current-recorded-disappeared-usesids)->void?
ids:(or/c(listofidentifier?)false/c)
syntax
(with-disappeared-usesstx-expr)

stx-expr:syntax?
procedure
(syntax-local-value/recordidpredicate)->any/c
id:identifier?
predicate:(->any/cboolean?)
procedure
(record-disappeared-usesids)->void?
ids:(listofidentifier?)
procedure
(generate-temporary[name-base])->identifier?
name-base:any/c='g
procedure
(internal-definition-context-applyintdef-ctx 
                                 stx)      ->syntax?
intdef-ctx:internal-definition-context?
stx:syntax?
procedure
(syntax-local-evalstx[intdef-ctx])->any
stx:syntax?
intdef-ctx:(or/cinternal-definition-context?#f)=#f
syntax
(with-syntax*([patternstx-expr]...)
body...+)

stx-expr:syntax?
parameter
(current-locale)->(or/cstring?#f)
(current-localelocale)->void?
locale:(or/cstring?#f)
procedure
(input-port?v)->boolean?
v:any/c
procedure
(output-port?v)->boolean?
v:any/c
procedure
(port?v)->boolean?
v:any/c
procedure
(close-input-portin)->void?
in:input-port?
procedure
(close-output-portout)->void?
out:output-port?
procedure
(port-closed?port)->boolean?
port:port?
procedure
(port-closed-evtport)->evt?
port:port?
parameter
(current-input-port)->input-port?
(current-input-portin)->void?
in:input-port?
parameter
(current-output-port)->output-port?
(current-output-portout)->void?
out:output-port?
parameter
(current-error-port)->output-port?
(current-error-portout)->void?
out:output-port?
procedure
(file-stream-port?port)->boolean?
port:port?
procedure
(terminal-port?port)->boolean?
port:port?
value
eof:eof-object?
procedure
(eof-object?a)->boolean?
a:any/c
procedure
(flush-output[out])->void?
out:output-port?=(current-output-port)
procedure
(file-stream-buffer-modeport)->(or/c'none'line'block#f)
port:port?
(file-stream-buffer-modeportmode)->void?
port:port?
mode:(or/c'none'line'block)
procedure
(file-positionport)->exact-nonnegative-integer?
port:port?
(file-positionportpos)->void?
port:port?
pos:(or/cexact-nonnegative-integer?eof-object?)
procedure
(file-position*port)->(or/cexact-nonnegative-integer?#f)
port:port?
procedure
(file-truncateportsize)->void?
port:(and/coutput-port?file-stream-port?)
size:exact-nonnegative-integer?
procedure
(port-count-lines!port)->void?
port:port?
procedure
(port-counts-lines?port)->boolean?
port:port?
procedure
(port-next-locationport)
->(or/cexact-positive-integer?#f)
    (or/cexact-nonnegative-integer?#f)
    (or/cexact-positive-integer?#f)
port:port?
procedure
(set-port-next-location!port      
                       line      
                       column    
                       position)->void?
port:port?
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:(or/cexact-positive-integer?#f)
parameter
(port-count-lines-enabled)->boolean?
(port-count-lines-enabledon?)->void?
on?:any/c
procedure
(open-input-filepath[#:modemode-flag])->input-port?
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(open-output-file path                   
                [#:modemode-flag       
                 #:existsexists-flag])->output-port?
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate
                'must-truncate'truncate/replace)
           ='error
procedure
(open-input-output-file path                  
                      [#:modemode-flag      
                       #:existsexists-flag])
->input-port?output-port?
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate'truncate/replace)
           ='error
procedure
(call-with-input-file path               
                     proc               
                    [#:modemode-flag])->any
path:path-string?
proc:(input-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
procedure
(call-with-output-file path                   
                      proc                   
                     [#:modemode-flag       
                      #:existsexists-flag])->any
path:path-string?
proc:(output-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(call-with-input-file* path               
                      proc               
                     [#:modemode-flag])->any
path:path-string?
proc:(input-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
procedure
(call-with-output-file* path                   
                       proc                   
                      [#:modemode-flag       
                       #:existsexists-flag])->any
path:path-string?
proc:(output-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(with-input-from-file path               
                     thunk              
                    [#:modemode-flag])->any
path:path-string?
thunk:(->any)
mode-flag:(or/c'binary'text)='binary
procedure
(with-output-to-file path                   
                    thunk                  
                   [#:modemode-flag       
                    #:existsexists-flag])->any
path:path-string?
thunk:(->any)
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(port-try-file-lock?portmode)->boolean?
port:file-stream-port?
mode:(or/c'shared'exclusive)
procedure
(port-file-unlockport)->void?
port:file-stream-port?
procedure
(port-file-identityport)->exact-positive-integer?
port:file-stream-port?
procedure
(open-input-bytesbstr[name])->input-port?
bstr:bytes?
name:any/c='string
procedure
(open-input-stringstr[name])->input-port?
str:string?
name:any/c='string
procedure
(open-output-bytes[name])->output-port?
name:any/c='string
procedure
(open-output-string[name])->output-port?
name:any/c='string
procedure
(get-output-bytes out       
                [reset?    
                 start-pos 
                 end-pos])->bytes?
out:output-port?
reset?:any/c=#f
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=#f
procedure
(get-output-stringout)->string?
out:output-port?
procedure
(make-pipe[limitinput-nameoutput-name])
->input-port?output-port?
limit:exact-positive-integer?=#f
input-name:any/c='pipe
output-name:any/c='pipe
procedure
(pipe-content-lengthpipe-port)->exact-nonnegative-integer?
pipe-port:port?
value
prop:input-port:struct-type-property?
value
prop:output-port:struct-type-property?
procedure
(make-input-port name             
                read-in          
                peek             
                close            
               [get-progress-evt 
                commit           
                get-location     
                count-lines!     
                init-position    
                buffer-mode])   ->input-port?
name:any/c
read-in:(or/c
            (bytes?
            . -> .(or/cexact-nonnegative-integer?
            eof-object?
            procedure?
            evt?))
            input-port?)
peek:(or/c
         (bytes?exact-nonnegative-integer?(or/cevt?#f)
         . -> .(or/cexact-nonnegative-integer?
         eof-object?
         procedure?
         evt?
         #f))
         input-port?)
close:(->any)
get-progress-evt:(or/c(->evt?)#f)=#f
commit:(or/c(exact-positive-integer?evt?evt?. -> .any)
           #f)
      =#f
get-location:(or/c
                 (->
                 (values(or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
            =#f
count-lines!:(->any)=void
init-position:(or/cexact-positive-integer?
                  port?
                  #f
                  (->(or/cexact-positive-integer?#f)))
             =1
buffer-mode:(or/c(case->((or/c'block'none). -> .any)
                (->(or/c'block'none#f)))
                #f)
           =#f
procedure
(make-output-port name                  
                 evt                   
                 write-out             
                 close                 
                [write-out-special     
                 get-write-evt         
                 get-write-special-evt 
                 get-location          
                 count-lines!          
                 init-position         
                 buffer-mode])        ->output-port?
name:any/c
evt:evt?
write-out:(or/c
              (bytes?exact-nonnegative-integer?
              exact-nonnegative-integer?
              boolean?
              boolean?
              . -> .
              (or/cexact-nonnegative-integer?
              #f
              evt?))
              output-port?)
close:(->any)
write-out-special:(or/c(any/cboolean?boolean?=#f
                      . -> .
                      (or/cany/c
                      #f
                      evt?))
                      output-port?
                      #f)
get-write-evt:(or/c                              =#f
                  (bytes?exact-nonnegative-integer?
                  exact-nonnegative-integer?
                  . -> .
                  evt?)
                  #f)
get-write-special-evt:(or/c               =#f
                          (any/c. -> .evt?)
                          #f)
get-location:(or/c
                 (->
                 (values(or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
            =#f
count-lines!:(->any)=void
init-position:(or/cexact-positive-integer?
                  port?
                  #f
                  (->(or/cexact-positive-integer?#f)))
             =1
buffer-mode:(or/c(case->
                ((or/c'block'line'none). -> .any)
                (->(or/c'block'line'none#f)))
                #f)
           =#f
procedure
(port->list[rin])->(listofany/c)
r:(input-port?. -> .any/c)=read
in:input-port?=(current-input-port)
procedure
(port->string[in])->string?
in:input-port?=(current-input-port)
procedure
(port->bytes[in])->bytes?
in:input-port?=(current-input-port)
procedure
(port->lines[in#:line-modeline-mode])->(listofstring?)
in:input-port?=(current-input-port)
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
procedure
(port->bytes-lines[in                      
                  #:line-modeline-mode])->(listofbytes?)
in:input-port?=(current-input-port)
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
procedure
(display-lines lst                     
             [out                     
              #:separatorseparator])->void?
lst:list?
out:output-port?=(current-output-port)
separator:any/c=#"\n"
procedure
(call-with-output-stringproc)->string?
proc:(output-port?. -> .any)
procedure
(call-with-output-bytesproc)->bytes?
proc:(output-port?. -> .any)
procedure
(with-output-to-stringproc)->string?
proc:(->any)
procedure
(with-output-to-bytesproc)->bytes?
proc:(->any)
procedure
(call-with-input-stringstrproc)->any
str:string?
proc:(input-port?. -> .any)
procedure
(call-with-input-bytesbstrproc)->any
bstr:bytes?
proc:(input-port?. -> .any)
procedure
(with-input-from-stringstrproc)->any
str:string?
proc:(->any)
procedure
(with-input-from-bytesbstrproc)->any
bstr:bytes?
proc:(->any)
procedure
(input-port-appendclose-at-eof?in...)->input-port?
close-at-eof?:any/c
in:input-port?
procedure
(make-input-port/read-to-peek name          
                             read-in       
                             fast-peek     
                             close         
                            [get-location  
                             count-lines!  
                             init-position 
                             buffer-mode   
                             buffering?    
                             on-consumed])->input-port?
name:any/c
read-in:(bytes?
            . -> .(or/cexact-nonnegative-integer?
            eof-object?
            procedure?
            evt?))
fast-peek:(or/c#f
              (bytes?exact-nonnegative-integer?
              (bytes?exact-nonnegative-integer?
              . -> .(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f))
              . -> .(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f)))
close:(->any)
get-location:(or/c                                  =#f
                 (->
                 (values
                 (or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
count-lines!:(->any)=void
init-position:exact-positive-integer?=1
buffer-mode:(or/c(case->((or/c'block'none). -> .any)
                (->(or/c'block'none#f)))
                #f)
           =#f
buffering?:any/c=#f
on-consumed:(or/c((or/cexact-nonnegative-integer?eof-object?
                procedure?evt?)
                . -> .any)
                #f)
           =#f
procedure
(make-limited-input-port in            
                        limit         
                       [close-orig?])->input-port?
in:input-port?
limit:exact-nonnegative-integer?
close-orig?:any/c=#t
procedure
(make-pipe-with-specials[limit      
                        in-name    
                        out-name])->input-port?output-port?
limit:exact-nonnegative-integer?=#f
in-name:any/c='pipe
out-name:any/c='pipe
procedure
(merge-inputa-inb-in[buffer-limit])->input-port?
a-in:input-port?
b-in:input-port?
buffer-limit:(or/cexact-nonnegative-integer?#f)=4096
procedure
(open-output-nowhere[namespecial-ok?])->output-port?
name:any/c='nowhere
special-ok?:any/c=#t
procedure
(peeking-input-port in                              
                  [name                            
                   skip                            
                   #:init-positioninit-position])->input-port
in:input-port?
name:any/c=(object-namein)
skip:exact-nonnegative-integer?=0
init-position:exact-positive-integer?=1
procedure
(reencode-input-port in                
                    encoding          
                   [error-bytes       
                    close?            
                    name              
                    convert-newlines? 
                    enc-error])      ->input-port?
in:input-port?
encoding:string?
error-bytes:(or/c#fbytes?)=#f
close?:any/c=#f
name:any/c=(object-namein)
convert-newlines?:any/c=#f
enc-error:(string?input-port?. -> .any)
         =(lambda(msgport)(error...))
procedure
(reencode-output-port out           
                     encoding      
                    [error-bytes   
                     close?        
                     name          
                     newline-bytes 
                     enc-error])  ->output-port?
out:output-port?
encoding:string?
error-bytes:(or/c#fbytes?)=#f
close?:any/c=#f
name:any/c=(object-nameout)
newline-bytes:(or/c#fbytes?)=#f
enc-error:(string?output-port?. -> .any)
         =(lambda(msgport)(error...))
procedure
(dup-input-portin[close?])->input-port?
in:input-port?
close?:any/c=#f
procedure
(dup-output-portout[close?])->output-port?
out:output-port?
close?:any/c=#f
procedure
(relocate-input-port in       
                    line     
                    column   
                    position 
                   [close?])->input-port?
in:input-port?
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:exact-positive-integer?
close?:any/c=#t
procedure
(relocate-output-port out      
                     line     
                     column   
                     position 
                    [close?])->output-port?
out:output-port?
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:exact-positive-integer?
close?:any/c=#t
procedure
(transplant-input-port in             
                      get-location   
                      init-pos       
                     [close?         
                      count-lines!])->input-port?
in:input-port?
get-location:(or/c
                 (->
                 (values
                 (or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
init-pos:exact-positive-integer?
close?:any/c=#t
count-lines!:(->any)=void
procedure
(transplant-output-port out            
                       get-location   
                       init-pos       
                      [close?         
                       count-lines!])->output-port?
out:output-port?
get-location:(or/c
                 (->
                 (values
                 (or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
init-pos:exact-positive-integer?
close?:any/c=#t
count-lines!:(->any)=void
procedure
(filter-read-input-port in        
                       read-wrap 
                       peek-wrap 
                      [close?]) ->input-port?
in:input-port?
read-wrap:(bytes?(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?)
              . -> .
              (or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?))
peek-wrap:(bytes?exact-nonnegative-integer?(or/cevt?#f)
              (or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f)
              . -> .(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f))
close?:any/c=#t
procedure
(special-filter-input-portinproc[close?])->input-port?
in:input-port?
proc:(procedure?bytes?. -> .(or/cexact-nonnegative-integer?
         eof-object?
         procedure?
         evt?))
close?:any/c=#t
procedure
(eof-evtin)->evt?
in:input-port?
procedure
(read-bytes-evtkin)->evt?
k:exact-nonnegative-integer?
in:input-port?
procedure
(read-bytes!-evtbstrinprogress-evt)->evt?
bstr:(and/cbytes?(not/cimmutable?))
in:input-port?
progress-evt:(or/cprogress-evt?#f)
procedure
(read-bytes-avail!-evtbstrin)->evt?
bstr:(and/cbytes?(not/cimmutable?))
in:input-port?
procedure
(read-string-evtkin)->evt?
k:exact-nonnegative-integer?
in:input-port?
procedure
(read-string!-evtstrin)->evt?
str:(and/cstring?(not/cimmutable?))
in:input-port?
procedure
(read-line-evtinmode)->evt?
in:input-port?
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
procedure
(read-bytes-line-evtinmode)->evt?
in:input-port?
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
procedure
(peek-bytes-evtkskipprogress-evtin)->evt?
k:exact-nonnegative-integer?
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-bytes!-evtbstrskipprogress-evtin)->evt?
bstr:(and/cbytes?(not/cimmutable?))
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-bytes-avail!-evtbstr         
                     skip         
                     progress-evt 
                     in)         ->evt?
bstr:(and/cbytes?(not/cimmutable?))
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-string-evtkskipprogress-evtin)->evt?
k:exact-nonnegative-integer?
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-string!-evtstrskipprogress-evtin)->evt?
str:(and/cstring?(not/cimmutable?))
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
procedure
(regexp-match-evtpatternin)->any
pattern:(or/cstring?bytes?regexp?byte-regexp?)
in:input-port?
procedure
(convert-streamfrom-encoding 
              in            
              to-encoding   
              out)         ->void?
from-encoding:string?
in:input-port?
to-encoding:string?
out:output-port?
procedure
(copy-portinout...+)->void?
in:input-port?
out:output-port?
procedure
(read-char[in])->(or/cchar?eof-object?)
in:input-port?=(current-input-port)
procedure
(read-byte[in])->(or/cbyte?eof-object?)
in:input-port?=(current-input-port)
procedure
(read-line[inmode])->(or/cstring?eof-object?)
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='linefeed
procedure
(read-bytes-line[inmode])->(or/cbytes?eof-object?)
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='linefeed
procedure
(read-stringamt[in])->(or/cstring?eof-object?)
amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(read-bytesamt[in])->(or/cbytes?eof-object?)
amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(read-string!str[instart-posend-pos])
->(or/cexact-positive-integer?eof-object?)
str:(and/cstring?(not/cimmutable?))
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(string-lengthstr)
procedure
(read-bytes!bstr[instart-posend-pos])
->(or/cexact-positive-integer?eof-object?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-bytes-avail!bstr[instart-posend-pos])
->(or/cexact-positive-integer?eof-object?procedure?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-bytes-avail!* bstr     
                  [in       
                   start-pos
                   end-pos])
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-bytes-avail!/enable-break bstr     
                              [in       
                               start-pos
                               end-pos])
->(or/cexact-positive-integer?eof-object?procedure?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-stringamtskip-bytes-amt[in])->(or/cstring?eof-object?)
amt:exact-nonnegative-integer?
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(peek-bytesamtskip-bytes-amt[in])->(or/cbytes?eof-object?)
amt:exact-nonnegative-integer?
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(peek-string! str           
             skip-bytes-amt
            [in            
             start-pos     
             end-pos])     
->(or/cexact-positive-integer?eof-object?)
str:(and/cstring?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(string-lengthstr)
procedure
(peek-bytes! bstr          
            skip-bytes-amt
           [in            
            start-pos     
            end-pos])     
->(or/cexact-positive-integer?eof-object?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-bytes-avail! bstr          
                  skip-bytes-amt
                 [progress      
                  in            
                  start-pos     
                  end-pos])     
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
progress:(or/cprogress-evt?#f)=#f
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-bytes-avail!* bstr          
                   skip-bytes-amt
                  [progress      
                   in            
                   start-pos     
                   end-pos])     
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
progress:(or/cprogress-evt?#f)=#f
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-bytes-avail!/enable-break bstr          
                               skip-bytes-amt
                              [progress      
                               in            
                               start-pos     
                               end-pos])     
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
progress:(or/cprogress-evt?#f)=#f
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-char-or-special[in])->(or/cchar?eof-object?any/c)
in:input-port?=(current-input-port)
procedure
(read-byte-or-special[in])->(or/cbyte?eof-object?any/c)
in:input-port?=(current-input-port)
procedure
(peek-char[inskip-bytes-amt])->(or/cchar?eof-object?)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
procedure
(peek-byte[inskip-bytes-amt])->(or/cbyte?eof-object?)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
procedure
(peek-char-or-special[inskip-bytes-amt])
->(or/cchar?eof-object?any/c)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
procedure
(peek-byte-or-special[in            
                     skip-bytes-amt
                     progress])    
->(or/cbyte?eof-object?any/c)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
progress:(or/cprogress-evt?#f)=#f
procedure
(port-progress-evt[in])->progress-evt?
in:(and/cinput-port?port-provides-progress-evts?)
  =(current-input-port)
procedure
(port-provides-progress-evts?in)->boolean
in:input-port?
procedure
(port-commit-peekedamtprogressevt[in])->boolean?
amt:exact-nonnegative-integer?
progress:progress-evt?
evt:evt?
in:input-port?=(current-input-port)
procedure
(byte-ready?[in])->boolean?
in:input-port?=(current-input-port)
procedure
(char-ready?[in])->boolean?
in:input-port?=(current-input-port)
procedure
(progress-evt?v)->boolean?
v:any/c
(progress-evt?evtin)->boolean?
evt:progress-evt?
in:input-port?
procedure
(write-charchar[out])->void?
char:char?
out:output-port?=(current-output-port)
procedure
(write-bytebyte[out])->void?
byte:byte?
out:output-port?=(current-output-port)
procedure
(newline[out])->void?
out:output-port?=(current-output-port)
procedure
(write-stringstr[outstart-posend-pos])
->exact-nonnegative-integer?
str:string?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(string-lengthstr)
procedure
(write-bytesbstr[outstart-posend-pos])
->exact-nonnegative-integer?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-bytes-avail bstr      
                 [out       
                  start-pos 
                  end-pos])->exact-nonnegative-integer?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-bytes-avail* bstr     
                  [out      
                   start-pos
                   end-pos])
->(or/cexact-nonnegative-integer?#f)
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-bytes-avail/enable-break bstr     
                              [out      
                               start-pos
                               end-pos])
->exact-nonnegative-integer?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-specialv[out])->boolean?
v:any/c
out:output-port?=(current-output-port)
procedure
(write-special-avail*v[out])->boolean?
v:any/c
out:output-port?=(current-output-port)
procedure
(write-bytes-avail-evt bstr      
                     [out       
                      start-pos 
                      end-pos])->evt?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-special-evtv[out])->evt?
v:any/c
out:output-port?=(current-output-port)
procedure
(port-writes-atomic?out)->boolean?
out:output-port?
procedure
(port-writes-special?out)->boolean?
out:output-port?
procedure
(read[in])->any
in:input-port?=(current-input-port)
procedure
(read-syntax[source-namein])->(or/csyntax?eof-object?)
source-name:any/c=(object-namein)
in:input-port?=(current-input-port)
procedure
(read/recursive[instartreadtablegraph?])->any
in:input-port?=(current-input-port)
start:(or/cchar?#f)=#f
readtable:(or/creadtable?#f)=(current-readtable)
graph?:any/c=#t
procedure
(read-syntax/recursive[source-name 
                      in          
                      start       
                      readtable   
                      graph?])   ->any
source-name:any/c=(object-namein)
in:input-port?=(current-input-port)
start:(or/cchar?#f)=#f
readtable:(or/creadtable?#f)=(current-readtable)
graph?:any/c=#t
procedure
(read-language[infail-thunk])->(any/cany/c. -> .any)
in:input-port?=(current-input-port)
fail-thunk:(->any)=(lambda()(error...))
parameter
(read-case-sensitive)->boolean?
(read-case-sensitiveon?)->void?
on?:any/c
parameter
(read-square-bracket-as-paren)->boolean?
(read-square-bracket-as-parenon?)->void?
on?:any/c
parameter
(read-curly-brace-as-paren)->boolean?
(read-curly-brace-as-parenon?)->void?
on?:any/c
parameter
(read-accept-box)->boolean?
(read-accept-boxon?)->void?
on?:any/c
parameter
(read-accept-compiled)->boolean?
(read-accept-compiledon?)->void?
on?:any/c
parameter
(read-accept-bar-quote)->boolean?
(read-accept-bar-quoteon?)->void?
on?:any/c
parameter
(read-accept-graph)->boolean?
(read-accept-graphon?)->void?
on?:any/c
parameter
(read-decimal-as-inexact)->boolean?
(read-decimal-as-inexacton?)->void?
on?:any/c
parameter
(read-accept-dot)->boolean?
(read-accept-doton?)->void?
on?:any/c
parameter
(read-accept-infix-dot)->boolean?
(read-accept-infix-doton?)->void?
on?:any/c
parameter
(read-accept-quasiquote)->boolean?
(read-accept-quasiquoteon?)->void?
on?:any/c
parameter
(read-accept-reader)->boolean?
(read-accept-readeron?)->void?
on?:any/c
parameter
(read-accept-lang)->boolean?
(read-accept-langon?)->void?
on?:any/c
parameter
(current-readtable)->(or/creadtable?#f)
(current-readtablereadtable)->void?
readtable:(or/creadtable?#f)
procedure
(call-with-default-reading-parameterizationthunk)->any
thunk:(->any)
parameter
(current-reader-guard)->(any/c. -> .any)
(current-reader-guardproc)->void?
proc:(any/c. -> .any)
parameter
(read-on-demand-source)
->(or/c#f#t(and/cpath?complete-path?))
(read-on-demand-sourcemode)->void?
mode:(or/c#f#t(and/cpath?complete-path?))
procedure
(port-read-handlerin)->(case->
                          (input-port?. -> .any)
                          (input-port?any/c. -> .any))
in:input-port?
(port-read-handlerinproc)->void?
in:input-port?
proc:(case->
         (input-port?. -> .any)
         (input-port?any/c. -> .any))
procedure
(writedatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(displaydatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(printdatum[outquote-depth])->void?
datum:any/c
out:output-port?=(current-output-port)
quote-depth:(or/c01)=0
procedure
(displaylndatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(fprintfoutformv...)->void?
out:output-port?
form:string?
v:any/c
procedure
(printfformv...)->void?
form:string?
v:any/c
procedure
(eprintfformv...)->void?
form:string?
v:any/c
procedure
(formatformv...)->string?
form:string?
v:any/c
parameter
(print-pair-curly-braces)->boolean?
(print-pair-curly-braceson?)->void?
on?:any/c
parameter
(print-mpair-curly-braces)->boolean?
(print-mpair-curly-braceson?)->void?
on?:any/c
parameter
(print-unreadable)->boolean?
(print-unreadableon?)->void?
on?:any/c
parameter
(print-graph)->boolean?
(print-graphon?)->void?
on?:any/c
parameter
(print-struct)->boolean?
(print-structon?)->void?
on?:any/c
parameter
(print-box)->boolean?
(print-boxon?)->void?
on?:any/c
parameter
(print-vector-length)->boolean?
(print-vector-lengthon?)->void?
on?:any/c
parameter
(print-hash-table)->boolean?
(print-hash-tableon?)->void?
on?:any/c
parameter
(print-boolean-long-form)->boolean?
(print-boolean-long-formon?)->void?
on?:any/c
parameter
(print-reader-abbreviations)->boolean?
(print-reader-abbreviationson?)->void?
on?:any/c
parameter
(print-as-expression)->boolean?
(print-as-expressionon?)->void?
on?:any/c
parameter
(print-syntax-width)
->(or/c+inf.00(and/cexact-integer?(>/c3)))
(print-syntax-widthwidth)->void?
width:(or/c+inf.00(and/cexact-integer?(>/c3)))
parameter
(current-write-relative-directory)
->(or/c(and/cpath?complete-path?)
    (cons/c(and/cpath?complete-path?)
    (and/cpath?complete-path?))
    #f)
(current-write-relative-directorypath)->void?
path:(or/c(and/cpath-string?complete-path?)
         (cons/c(and/cpath-string?complete-path?)
         (and/cpath-string?complete-path?))
         #f)
procedure
(port-write-handlerout)->(any/coutput-port?. -> .any)
out:output-port?
(port-write-handleroutproc)->void?
out:output-port?
proc:(any/coutput-port?. -> .any)
procedure
(port-display-handlerout)->(any/coutput-port?. -> .any)
out:output-port?
(port-display-handleroutproc)->void?
out:output-port?
proc:(any/coutput-port?. -> .any)
procedure
(port-print-handlerout)
->((any/coutput-port?)((or/c01)). ->* .any)
out:output-port?
(port-print-handleroutproc)->void?
out:output-port?
proc:(any/coutput-port?. -> .any)
procedure
(global-port-print-handler)
->(->*(any/coutput-port?)((or/c01))any)
(global-port-print-handlerproc)->void?
proc:(or/c(->*(any/coutput-port?)((or/c01))any)
         (any/coutput-port?. -> .any))
procedure
(pretty-printv[portquote-depth])->void?
v:any/c
port:output-port?=(current-output-port)
quote-depth:(or/c01)=0
procedure
(pretty-writev[port])->void?
v:any/c
port:output-port?=(current-output-port)
procedure
(pretty-displayv[port])->void?
v:any/c
port:output-port?=(current-output-port)
procedure
(pretty-formatv[columns])->string?
v:any/c
columns:exact-nonnegative-integer?=(pretty-print-columns)
procedure
(pretty-print-handlerv)->void?
v:any/c
parameter
(pretty-print-columns)
->(or/cexact-positive-integer?'infinity)
(pretty-print-columnswidth)->void?
width:(or/cexact-positive-integer?'infinity)
parameter
(pretty-print-depth)->(or/cexact-nonnegative-integer?#f)
(pretty-print-depthdepth)->void?
depth:(or/cexact-nonnegative-integer?#f)
parameter
(pretty-print-exact-as-decimal)->boolean?
(pretty-print-exact-as-decimalas-decimal?)->void?
as-decimal?:any/c
parameter
(pretty-print-.-symbol-without-bars)->boolean?
(pretty-print-.-symbol-without-barson?)->void?
on?:any/c
parameter
(pretty-print-show-inexactness)->boolean?
(pretty-print-show-inexactnessshow?)->void?
show?:any/c
parameter
(pretty-print-abbreviate-read-macros)->boolean?
(pretty-print-abbreviate-read-macrosabbrev?)->void?
abbrev?:any/c
procedure
(pretty-print-style-table?v)->boolean?
v:any/c
parameter
(pretty-print-current-style-table)->pretty-print-style-table?
(pretty-print-current-style-tablestyle-table)->void?
style-table:pretty-print-style-table?
procedure
(pretty-print-extend-style-tablestyle-table      
                               symbol-list      
                               like-symbol-list)
->pretty-print-style-table?
style-table:pretty-print-style-table?
symbol-list:(listofsymbol?)
like-symbol-list:(listofsymbol?)
parameter
(pretty-print-remap-stylable)
->(any/c. -> .(or/csymbol?#f))
(pretty-print-remap-stylableproc)->void?
proc:(any/c. -> .(or/csymbol?#f))
procedure
(pretty-print-newlineportwidth)->void?
port:out-port?
width:exact-nonnegative-integer?
parameter
(pretty-print-print-line)
->((or/cexact-nonnegative-integer?#f)
    output-port?
    exact-nonnegative-integer?
    (or/cexact-nonnegative-integer?'infinity)
    . -> .
    exact-nonnegative-integer?)
(pretty-print-print-lineproc)->void?
proc:((or/cexact-nonnegative-integer?#f)
         output-port?
         exact-nonnegative-integer?
         (or/cexact-nonnegative-integer?'infinity)
         . -> .
         exact-nonnegative-integer?)
parameter
(pretty-print-size-hook)
->(any/cboolean?output-port?
    . -> .
    (or/c#fexact-nonnegative-integer?))
(pretty-print-size-hookproc)->void?
proc:(any/cboolean?output-port?
         . -> .
         (or/c#fexact-nonnegative-integer?))
parameter
(pretty-print-print-hook)
->(any/cboolean?output-port?. -> .void?)
(pretty-print-print-hookproc)->void?
proc:(any/cboolean?output-port?. -> .void?)
parameter
(pretty-print-pre-print-hook)
->(any/coutput-port?. -> .void)
(pretty-print-pre-print-hookproc)->void?
proc:(any/coutput-port?. -> .void)
parameter
(pretty-print-post-print-hook)
->(any/coutput-port?. -> .void)
(pretty-print-post-print-hookproc)->void?
proc:(any/coutput-port?. -> .void)
parameter
(pretty-printing)->boolean?
(pretty-printingon?)->void?
on?:any/c
procedure
(make-tentative-pretty-print-output-portout            
                                       width          
                                       overflow-thunk)
->output-port?
out:output-port?
width:exact-nonnegative-integer?
overflow-thunk:(->any)
procedure
(tentative-pretty-print-port-transfertentative-out 
                                    orig-out)    ->void?
tentative-out:output-port?
orig-out:output-port?
procedure
(tentative-pretty-print-port-canceltentative-out)->void?
tentative-out:output-port?
procedure
(readtable?v)->boolean?
v:any/c
procedure
(make-readtablereadtable    
              key          
              mode         
              action...+)->readtable?
readtable:readtable?
key:(or/cchar?#f)
mode:(or/c(or/c'terminating-macro
         'non-terminating-macro
         'dispatch-macro)
         char?)
action:(or/cprocedure?
           readtable?)
procedure
(readtable-mappingreadtablechar)
->(or/cchar?
    (or/c'terminating-macro
    'non-terminating-macro))
    (or/c#fprocedure?)
    (or/c#fprocedure?)
readtable:readtable?
char:char?
procedure
(make-special-commentv)->special-comment?
v:any/c
procedure
(special-comment?v)->boolean?
v:any/c
procedure
(special-comment-valuesc)->any
sc:special-comment?
value
gen:custom-write:any/c
value
prop:custom-write:struct-type-property?
procedure
(custom-write?v)->boolean?
v:any/c
procedure
(custom-write-accessorv)
->(custom-write?output-port?boolean?. -> .any)
v:custom-write?
value
prop:custom-print-quotable:struct-type-property?
value
custom-print-quotable?:struct-type-property?
value
custom-print-quotable-accessor:struct-type-property?
procedure
(serializable?v)->boolean?
v:any/c
procedure
(serializev)->any
v:serializable?
procedure
(deserializev)->any
v:any/c
procedure
(serialized=?v1v2)->boolean?
v1:any/c
v2:any/c
parameter
(deserialize-module-guard)
->(module-path?symbol?. -> .void?)
(deserialize-module-guardguard)->void?
guard:(module-path?symbol?. -> .void?)
syntax
(serializable-structidmaybe-super(field...)
struct-option...)
syntax
(define-serializable-structid-maybe-super(field...)
struct-option...)
syntax
(serializable-struct/versionsidmaybe-supervers(field...)
(other-version-clause...)
struct-option...)

other-version-clause=(other-versmake-proc-expr
                       cycle-make-proc-expr)
syntax
(define-serializable-struct/versionsid-maybe-supervers(field...)
(other-version-clause...)
struct-option...)
procedure
(make-deserialize-infomakecycle-make)->any
make:procedure?
cycle-make:(->(valuesany/cprocedure?))
value
prop:serializable:property?
procedure
(make-serialize-infoto-vector      
                   deserialize-id 
                   can-cycle?     
                   dir)          ->any
to-vector:(any/c. -> .vector?)
deserialize-id:(oridentifier?
                   symbol?
                   (cons/csymbol?
                   module-path-index?))
can-cycle?:any/c
dir:path-string?
procedure
(s-exp->faslv[out])->(or/c(void)bytes?)
v:any/c
out:(or/coutput-port?#f)=#f
procedure
(fasl->s-expin)->any/c
in:(or/cinput-port?bytes?)
procedure
(namespace?v)->boolean?
v:any/c
procedure
(make-empty-namespace)->namespace?
procedure
(make-base-empty-namespace)->namespace?
procedure
(make-base-namespace)->namespace?
syntax
(define-namespace-anchorid)
procedure
(namespace-anchor?v)->boolean?
v:any/c
procedure
(namespace-anchor->empty-namespacea)->namespace?
a:namespace-anchor?
procedure
(namespace-anchor->namespacea)->namespace?
a:namespace-anchor?
parameter
(current-namespace)->namespace?
(current-namespacen)->void?
n:namespace?
procedure
(namespace-symbol->identifiersym)->identifier?
sym:symbol?
procedure
(namespace-base-phase[namespace])->exact-integer?
namespace:namespace?=(current-namespace)
procedure
(namespace-module-identifier[where])->identifier?
where:(or/cnamespace?exact-integer?#f)
     =(current-namespace)
procedure
(namespace-variable-value sym           
                        [use-mapping?  
                         failure-thunk 
                         namespace])  ->any
sym:symbol?
use-mapping?:any/c=#t
failure-thunk:(or/c(->any)#f)=#f
namespace:namespace?=(current-namespace)
procedure
(namespace-set-variable-value! sym         
                              v           
                             [map?        
                              namespace])->void?
sym:symbol?
v:any/c
map?:any/c=#f
namespace:namespace?=(current-namespace)
procedure
(namespace-undefine-variable! sym         
                            [namespace])->void?
sym:symbol?
namespace:namespace?=(current-namespace)
procedure
(namespace-mapped-symbols[namespace])->(listofsymbol?)
namespace:namespace?=(current-namespace)
procedure
(namespace-requirequoted-raw-require-spec)->void?
quoted-raw-require-spec:any/c
procedure
(namespace-require/copyquoted-raw-require-spec)->void?
quoted-raw-require-spec:any/c
procedure
(namespace-require/constantquoted-raw-require-spec)->void?
quoted-raw-require-spec:any/c
procedure
(namespace-require/expansion-timequoted-raw-require-spec)
->void?
quoted-raw-require-spec:any/c
procedure
(namespace-attach-module src-namespace    
                        modname          
                       [dest-namespace])->void?
src-namespace:namespace?
modname:module-path?
dest-namespace:namespace?=(current-namespace)
procedure
(namespace-attach-module-declaration src-namespace    
                                    modname          
                                   [dest-namespace])->void?
src-namespace:namespace?
modname:module-path?
dest-namespace:namespace?=(current-namespace)
procedure
(namespace-unprotect-module inspector   
                           modname     
                          [namespace])->void?
inspector:inspector?
modname:module-path?
namespace:namespace?=(current-namespace)
procedure
(namespace-module-registrynamespace)->any
namespace:namespace?
procedure
(module->namespacemodname)->namespace?
modname:module-path?
procedure
(namespace-syntax-introducestx)->syntax?
stx:syntax?
procedure
(module-provide-protected?module-path-index 
                         sym)             ->boolean?
module-path-index:(or/csymbol?module-path-index?)
sym:symbol?
procedure
(variable-reference?v)->boolean?
v:any/c
procedure
(variable-reference-constant?varref)->boolean?
varref:variable-reference?
procedure
(variable-reference->empty-namespacevarref)->namespace?
varref:variable-reference?
procedure
(variable-reference->namespacevarref)->namespace?
varref:variable-reference?
procedure
(variable-reference->resolved-module-pathvarref)
->(or/cresolved-module-path?#f)
varref:variable-reference?
procedure
(variable-reference->module-path-indexvarref)
->(or/cmodule-path-index?#f)
varref:variable-reference?
procedure
(variable-reference->module-sourcevarref)
->(or/csymbol?(and/cpath?complete-path?)#f)
varref:variable-reference?
procedure
(variable-reference->phasevarref)->exact-nonnegative-integer?
varref:variable-reference?
procedure
(variable-reference->module-base-phasevarref)->exact-integer?
varref:variable-reference?
procedure
(variable-reference->module-declaration-inspectorvarref)
->inspector?
varref:variable-reference?
parameter
(current-eval)->(any/c. -> .any)
(current-evalproc)->void?
proc:(any/c. -> .any)
procedure
(evaltop-level-form[namespace])->any
top-level-form:any/c
namespace:namespace?=(current-namespace)
procedure
(eval-syntaxstx[namespace])->any
stx:syntax?
namespace:namespace?=(current-namespace)
parameter
(current-load)
->(path?(or/c#f
    symbol?
    (cons/c(or/c#fsymbol?)
    (non-empty-listofsymbol?)))
    . -> .
    any)
(current-loadproc)->void?
proc:(path?(or/c#f
         symbol?
         (cons/c(or/c#fsymbol?)
         (non-empty-listofsymbol?)))
         . -> .
         any)
procedure
(loadfile)->any
file:path-string?
procedure
(load-relativefile)->any
file:path-string?
procedure
(load/cdfile)->any
file:path-string?
parameter
(current-load-extension)
->(path?(or/csymbol?#f). -> .any)
(current-load-extensionproc)->void?
proc:(path?(or/csymbol?#f). -> .any)
procedure
(load-extensionfile)->any
file:path-string?
procedure
(load-relative-extensionfile)->any
file:path-string?
parameter
(current-load/use-compiled)
->(path?(or/c#f
    symbol?
    (cons/c(or/c#fsymbol?)
    (non-empty-listofsymbol?)))
    . -> .any)
(current-load/use-compiledproc)->void?
proc:(path?(or/c#f
         symbol?
         (cons/c(or/c#fsymbol?)
         (non-empty-listofsymbol?)))
         . -> .any)
procedure
(load/use-compiledfile)->any
file:path-string?
parameter
(current-load-relative-directory)
->(or/c(and/cpath-string?complete-path?)#f)
(current-load-relative-directorypath)->void?
path:(or/c(and/cpath-string?complete-path?)#f)
parameter
(use-compiled-file-paths)
->(listof(and/cpath?relative-path?))
(use-compiled-file-pathspaths)->void?
paths:(listof(and/cpath-string?relative-path?))
parameter
(current-compiled-file-roots)->(listof(or/cpath?'path))
(current-compiled-file-rootspaths)->void?
paths:(listof(or/cpath-string?'same))
procedure
(read-eval-print-loop)->any
parameter
(current-prompt-read)->(->any)
(current-prompt-readproc)->void?
proc:(->any)
parameter
(current-get-interaction-input-port)->(->input-port?)
(current-get-interaction-input-portproc)->void?
proc:(->input-port?)
parameter
(current-read-interaction)->(any/cinput-port?->any)
(current-read-interactionproc)->void?
proc:(any/cinput-port?->any)
parameter
(current-print)->(any/c->any)
(current-printproc)->void?
proc:(any/c->any)
parameter
(current-compile)
->(any/cboolean?. -> .compiled-expression?)
(current-compileproc)->void?
proc:(any/cboolean?. -> .compiled-expression?)
procedure
(compiletop-level-form)->compiled-expression?
top-level-form:any/c
procedure
(compile-syntaxstx)->compiled-expression?
stx:syntax?
procedure
(compiled-expression?v)->boolean?
v:any/c
parameter
(compile-enforce-module-constants)->boolean?
(compile-enforce-module-constantson?)->void?
on?:any/c
parameter
(compile-allow-set!-undefined)->boolean?
(compile-allow-set!-undefinedallow?)->void?
allow?:any/c
parameter
(compile-context-preservation-enabled)->boolean?
(compile-context-preservation-enabledon?)->void?
on?:any/c
parameter
(eval-jit-enabled)->boolean?
(eval-jit-enabledon?)->void?
on?:any/c
parameter
(load-on-demand-enabled)->boolean?
(load-on-demand-enabledon?)->void?
on?:any/c
procedure
(resolved-module-path?v)->boolean?
v:any/c
procedure
(make-resolved-module-pathpath)->resolved-module-path?
path:(or/csymbol?
         (and/cpath?complete-path?)
         (cons/c(or/csymbol?
         (and/cpath?complete-path?))
         (non-empty-listofsymbol?)))
procedure
(resolved-module-path-namemodule-path)
->(or/csymbol?
    (and/cpath?complete-path?)
    (cons/c(or/csymbol?
    (and/cpath?complete-path?))
    (non-empty-listofsymbol?)))
module-path:resolved-module-path?
procedure
(module-path?v)->boolean?
v:any/c
parameter
(current-module-name-resolver)
->(case->
    (resolved-module-path?(or/c#fnamespace?). -> .any)
    (module-path?
    (or/c#fresolved-module-path?)
    (or/c#fsyntax?)
    boolean?
    . -> .
    resolved-module-path?))
(current-module-name-resolverproc)->void?
proc:(case->
         (resolved-module-path?(or/c#fnamespace?). -> .any)
         (module-path?
         (or/c#fresolved-module-path?)
         (or/c#fsyntax?)
         boolean?
         . -> .
         resolved-module-path?))
parameter
(current-module-declare-name)
->(or/cresolved-module-path?#f)
(current-module-declare-namename)->void?
name:(or/cresolved-module-path?#f)
parameter
(current-module-declare-source)
->(or/csymbol?(and/cpath?complete-path?)#f)
(current-module-declare-sourcesrc)->void?
src:(or/csymbol?(and/cpath?complete-path?)#f)
parameter
(current-module-path-for-load)
->(or/c#fmodule-path?
    (and/csyntax?
    (lambda(stx)
    (module-path?(syntax->datums)))))
(current-module-path-for-loadpath)->void?
path:(or/c#fmodule-path?
         (and/csyntax?
         (lambda(stx)
         (module-path?(syntax->datums)))))
procedure
(module-path-index?v)->boolean?
v:any/c
procedure
(module-path-index-resolvempi)->resolved-module-path?
mpi:module-path-index?
procedure
(module-path-index-splitmpi)
->(or/cmodule-path?#f)
    (or/cmodule-path-index?resolved-module-path?#f)
mpi:module-path-index?
procedure
(module-path-index-submodulempi)
->(or/c#f(non-empty-listofsymbol?))
mpi:module-path-index?
procedure
(module-path-index-joinpathbase[submod])->module-path-index?
path:(or/cmodule-path?#f)
base:(or/cmodule-path-index?resolved-module-path?#f)
submod:(or/c#f(non-empty-listofsymbol?))=#f
procedure
(compiled-module-expression?v)->boolean?
v:any/c
procedure
(module-compiled-namecompiled-module-code)
->(or/csymbol?(cons/csymbol?(non-empty-listofsymbol?)))
compiled-module-code:compiled-module-expression?
(module-compiled-namecompiled-module-code
                    name)               
->compiled-module-expression?
compiled-module-code:compiled-module-expression?
name:(or/csymbol?(cons/csymbol?(non-empty-listofsymbol?)))
procedure
(module-compiled-submodulescompiled-module-code
                          non-star?)          
->(listofcompiled-module-expression?)
compiled-module-code:compiled-module-expression?
non-star?:any/c
(module-compiled-submodulescompiled-module-code
                          non-star?           
                          submodules)         
->compiled-module-expression?
compiled-module-code:compiled-module-expression?
non-star?:any/c
submodules:(listofcompiled-module-expression?)
procedure
(module-compiled-importscompiled-module-code)
->(listof(cons/c(or/cexact-integer?#f)
    (listofmodule-path-index?)))
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-exportscompiled-module-code)
->(listof(cons/c(or/cexact-integer?#f)list?))
    (listof(cons/c(or/cexact-integer?#f)list?))
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-language-infocompiled-module-code)
->(or/c#f(vector/cmodule-path?symbol?any/c))
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-cross-phase-persistent?compiled-module-code)
->boolean?
compiled-module-code:compiled-module-expression?
procedure
(dynamic-requiremodprovided[fail-thunk])->any
mod:(or/cmodule-path?
        resolved-module-path?
        module-path-index?)
provided:(or/csymbol?#f0void?)
fail-thunk:(->any)=(lambda()....)
procedure
(dynamic-require-for-syntax mod          
                           provided     
                          [fail-thunk])->any
mod:module-path?
provided:(or/csymbol?#f)
fail-thunk:(->any)=(lambda()....)
procedure
(module-declared?mod[load?])->boolean?
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
load?:any/c=#f
procedure
(module->language-infomod[load?])
->(or/c#f(vector/cmodule-path?symbol?any/c))
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
load?:any/c=#f
procedure
(module->importsmod)
->(listof(cons/c(or/cexact-integer?#f)
    (listofmodule-path-index?)))
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
procedure
(module->exportsmod)
->(listof(cons/c(or/cexact-integer?#f)list?))
    (listof(cons/c(or/cexact-integer?#f)list?))
mod:(or/cmodule-path?resolved-module-path?)
procedure
(module-predefined?mod)->boolean?
mod:(or/cmodule-path?resolved-module-path?)
procedure
(impersonator?v)->boolean?
v:any/c
procedure
(chaperone?v)->boolean?
v:any/c
procedure
(impersonator-of?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(chaperone-of?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(impersonator-ephemeronv)->ephemeron?
v:any/c
procedure
(impersonate-procedureproc        
                     wrapper-proc
                     prop        
                     prop-val...
                     ...)        
->(and/cprocedure?impersonator?)
proc:procedure?
wrapper-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(impersonate-structv                 
                  orig-proc         
                  redirect-proc... 
                  ...               
                  prop              
                  prop-val...      
                  ...)             ->any/c
v:any/c
orig-proc:(or/cstruct-accessor-procedure?
              struct-mutator-procedure?
              struct-type-property-accessor-procedure?)
redirect-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(impersonate-vectorvec         
                  ref-proc    
                  set-proc    
                  prop        
                  prop-val...
                  ...)        
->(and/cvector?impersonator?)
vec:(and/cvector?(not/cimmutable?))
ref-proc:(vector?exact-nonnegative-integer?any/c. -> .any/c)
set-proc:(vector?exact-nonnegative-integer?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(impersonate-boxbox          
               unbox-proc   
               set-proc     
               prop         
               prop-val... 
               ...)        ->(and/cbox?impersonator?)
box:(and/cbox?(not/cimmutable?))
unbox-proc:(box?any/c. -> .any/c)
set-proc:(box?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(impersonate-hash hash         
                 ref-proc     
                 set-proc     
                 remove-proc  
                 key-proc     
                [clear-proc]  
                 prop         
                 prop-val... 
                 ...)        ->(and/chash?impersonator?)
hash:(and/chash?(not/cimmutable?))
ref-proc:(hash?any/c. -> .(values
             any/c
             (hash?any/cany/c. -> .any/c)))
set-proc:(hash?any/cany/c. -> .(valuesany/cany/c))
remove-proc:(hash?any/c. -> .any/c)
key-proc:(hash?any/c. -> .any/c)
clear-proc:(or/c#f(hash?. -> .any))=#f
prop:impersonator-property?
prop-val:any
procedure
(impersonate-channelchannel     
                   get-proc    
                   put-proc    
                   prop        
                   prop-val...
                   ...)        
->(and/cchannel?impersonator?)
channel:channel?
get-proc:(channel?. -> .(valueschannel?(any/c. -> .any/c)))
put-proc:(channel?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(impersonate-prompt-tag prompt-tag              
                       handle-proc             
                       abort-proc              
                      [cc-guard-proc           
                       callcc-impersonate-proc]
                       prop                    
                       prop-val...            
                       ...)                    
->(and/ccontinuation-prompt-tag?impersonator?)
prompt-tag:continuation-prompt-tag?
handle-proc:procedure?
abort-proc:procedure?
cc-guard-proc:procedure?=values
callcc-impersonate-proc:(procedure?. -> .procedure?)
                       =(lambda(p)p)
prop:impersonator-property?
prop-val:any
procedure
(impersonate-continuation-mark-keykey         
                                 get-proc    
                                 set-proc    
                                 prop        
                                 prop-val...
                                 ...)        
->(and/ccontinuation-mark?impersonator?)
key:continuation-mark-key?
get-proc:procedure?
set-proc:procedure?
prop:impersonator-property?
prop-val:any
value
prop:impersonator-of:struct-type-property?
procedure
(chaperone-procedureproc        
                   wrapper-proc
                   prop        
                   prop-val...
                   ...)        
->(and/cprocedure?chaperone?)
proc:procedure?
wrapper-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(chaperone-structv                 
                orig-proc         
                redirect-proc... 
                ...               
                prop              
                prop-val...      
                ...)             ->any/c
v:any/c
orig-proc:(or/cstruct-accessor-procedure?
              struct-mutator-procedure?
              struct-type-property-accessor-procedure?
              (one-of/cstruct-info))
redirect-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(chaperone-vectorvec          
                ref-proc     
                set-proc     
                prop         
                prop-val... 
                ...)        ->(and/cvector?chaperone?)
vec:vector?
ref-proc:(vector?exact-nonnegative-integer?any/c. -> .any/c)
set-proc:(vector?exact-nonnegative-integer?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(chaperone-boxbox          
             unbox-proc   
             set-proc     
             prop         
             prop-val... 
             ...)        ->(and/cbox?chaperone?)
box:box?
unbox-proc:(box?any/c. -> .any/c)
set-proc:(box?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(chaperone-hash hash         
               ref-proc     
               set-proc     
               remove-proc  
               key-proc     
              [clear-proc]  
               prop         
               prop-val... 
               ...)        ->(and/chash?chaperone?)
hash:hash?
ref-proc:(hash?any/c. -> .(values
             any/c
             (hash?any/cany/c. -> .any/c)))
set-proc:(hash?any/cany/c. -> .(valuesany/cany/c))
remove-proc:(hash?any/c. -> .any/c)
key-proc:(hash?any/c. -> .any/c)
clear-proc:(or/c#f(hash?. -> .any))=#f
prop:impersonator-property?
prop-val:any
procedure
(chaperone-struct-typestruct-type          
                     struct-info-proc     
                     make-constructor-proc
                     guard-proc           
                     prop                 
                     prop-val...         
                     ...)                 
->(and/cstruct-type?chaperone?)
struct-type:struct-type?
struct-info-proc:procedure?
make-constructor-proc:(procedure?. -> .procedure?)
guard-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(chaperone-evtevtprocpropprop-val......)
->(and/cevt?chaperone?)
evt:evt?
proc:(evt?. -> .(valuesevt?(any/c. -> .any/c)))
prop:impersonator-property?
prop-val:any
procedure
(chaperone-channelchannel      
                 get-proc     
                 put-proc     
                 prop         
                 prop-val... 
                 ...)        ->(and/cchannel?chaperone?)
channel:channel?
get-proc:(channel?. -> .(valueschannel?(any/c. -> .any/c)))
put-proc:(channel?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(chaperone-prompt-tag prompt-tag            
                     handle-proc           
                     abort-proc            
                    [cc-guard-proc         
                     callcc-chaperone-proc]
                     prop                  
                     prop-val...          
                     ...)                  
->(and/ccontinuation-prompt-tag?chaperone?)
prompt-tag:continuation-prompt-tag?
handle-proc:procedure?
abort-proc:procedure?
cc-guard-proc:procedure?=values
callcc-chaperone-proc:(procedure?. -> .procedure?)
                     =(lambda(p)p)
prop:impersonator-property?
prop-val:any
procedure
(chaperone-continuation-mark-keykey         
                               get-proc    
                               set-proc    
                               prop        
                               prop-val...
                               ...)        
->(and/ccontinuation-mark-key?chaperone?)
key:continuation-mark-key?
get-proc:procedure?
set-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(make-impersonator-propertyname)->impersonator-property?
                                     (->any/cboolean?)
                                     (->impersonator?any)
name:symbol?
procedure
(impersonator-property?v)->boolean?
v:any/c
procedure
(impersonator-property-accessor-procedure?v)->boolean?
v:any/c
value
impersonator-prop:application-mark:impersonator-property?
procedure
(security-guard?v)->boolean?
v:any/c
procedure
(make-security-guard parent        
                    file-guard    
                    network-guard 
                   [link-guard]) ->security-guard?
parent:security-guard?
file-guard:(symbol?
               (or/cpath?#f)
               (listofsymbol?)
               . -> .any)
network-guard:(symbol?
                  (or/c(and/cstring?immutable?)#f)
                  (or/c(integer-in165535)#f)
                  (or/c'server'client)
                  . -> .any)
link-guard:(or/c(symbol?path?path?. -> .any)#f)=#f
parameter
(current-security-guard)->security-guard?
(current-security-guardguard)->void?
guard:security-guard?
procedure
(custodian?v)->boolean?
v:any/c
procedure
(make-custodian[cust])->custodian?
cust:custodian?=(current-custodian)
procedure
(custodian-shutdown-allcust)->void?
cust:custodian?
parameter
(current-custodian)->custodian?
(current-custodiancust)->void?
cust:custodian?
procedure
(custodian-managed-listcustsuper)->list?
cust:custodian?
super:custodian?
procedure
(custodian-memory-accounting-available?)->boolean?
procedure
(custodian-require-memorylimit-cust 
                        need-amt   
                        stop-cust)->void?
limit-cust:custodian?
need-amt:exact-nonnegative-integer?
stop-cust:custodian?
procedure
(custodian-limit-memory limit-cust  
                       limit-amt   
                      [stop-cust])->void?
limit-cust:custodian?
limit-amt:exact-nonnegative-integer?
stop-cust:custodian?=limit-cust
procedure
(make-custodian-boxcustv)->custodian-box?
cust:custodian?
v:any/c
procedure
(custodian-box?v)->boolean?
v:any/c
procedure
(custodian-box-valuecb)->any
cb:custodian-box?
procedure
(make-thread-group[group])->thread-group?
group:thread-group?=(current-thread-group)
procedure
(thread-group?v)->boolean?
v:any/c
parameter
(current-thread-group)->thread-group?
(current-thread-groupgroup)->void?
group:thread-group?
procedure
(inspector?v)->boolean?
v:any/c
procedure
(make-inspector[inspector])->inspector?
inspector:inspector?=(current-inspector)
procedure
(make-sibling-inspector[inspector])->inspector?
inspector:inspector?=(current-inspector)
parameter
(current-inspector)->inspector?
(current-inspectorinsp)->void?
insp:inspector?
procedure
(struct-infov)->(or/cstruct-type?#f)boolean?
v:any/c
procedure
(struct-type-infostruct-type)
->symbol?
    exact-nonnegative-integer?
    exact-nonnegative-integer?
    struct-accessor-procedure?
    struct-mutator-procedure?
    (listofexact-nonnegative-integer?)
    (or/cstruct-type?#f)
    boolean?
struct-type:struct-type?
procedure
(struct-type-make-constructorstruct-type)
->struct-constructor-procedure?
struct-type:struct-type?
procedure
(struct-type-make-predicatestruct-type)->any
struct-type:any/c
procedure
(object-namev)->any
v:any/c
parameter
(current-code-inspector)->inspector?
(current-code-inspectorinsp)->void?
insp:inspector?
procedure
(make-evaluator language                             
               input-program...                    
              [#:requiresrequires                  
               #:allow-for-requireallow-for-require
               #:allow-for-loadallow-for-load      
               #:allow-readallow-read])            
->(any/c. -> .any)
language:(or/cmodule-path?
             (list/c'specialsymbol?)
             (cons/c'beginlist?))
input-program:any/c
requires:(listof(or/cmodule-path?path-string?
             (cons/c'for-syntax(listofmodule-path?))))
        =null
allow-for-require:(listof(or/cmodule-path?path?))=null
allow-for-load:(listofpath-string?)=null
allow-read:(listof(or/cmodule-path?path-string?))=null
(make-module-evaluator module-decl                          
                     [#:languagelang                      
                      #:allow-for-requireallow-for-require
                      #:allow-for-loadallow-for-load      
                      #:allow-readallow-read])            
->(any/c. -> .any)
module-decl:(or/csyntax?pair?path?input-port?string?bytes?)
lang:(or/c#fmodule-path?)=#f
allow-for-require:(listof(or/cmodule-path?path?))=null
allow-for-load:(listofpath-string?)=null
allow-read:(listof(or/cmodule-path?path-string?))=null
procedure
(exn:fail:sandbox-terminated?v)->boolean?
v:any/c
(exn:fail:sandbox-terminated-reasonexn)->symbol?
exn:exn:fail:sandbox-terminated?
procedure
(call-with-trusted-sandbox-configurationthunk)->any
thunk:(->any)
parameter
(sandbox-init-hook)->(->any)
(sandbox-init-hookthunk)->void?
thunk:(->any)
parameter
(sandbox-reader)->(any/c. -> .any)
(sandbox-readerproc)->void?
proc:(any/c. -> .any)
parameter
(sandbox-input)->(or/c#f
                   string?bytes?
                   input-port?
                   'pipe
                   (->input-port?))
(sandbox-inputin)->void?
in:(or/c#f
       string?bytes?
       input-port?
       'pipe
       (->input-port?))
parameter
(sandbox-output)->(or/c#f
                    output-port?
                    'pipe
                    'bytes
                    'string
                    (->output-port?))
(sandbox-outputin)->void?
in:(or/c#f
       output-port?
       'pipe
       'bytes
       'string
       (->output-port?))
parameter
(sandbox-error-output)->(or/c#f
                          output-port?
                          'pipe
                          'bytes
                          'string
                          (->output-port?))
(sandbox-error-outputin)->void?
in:(or/c#f
       output-port?
       'pipe
       'bytes
       'string
       (->output-port?))
parameter
(sandbox-coverage-enabled)->boolean?
(sandbox-coverage-enabledenabled?)->void?
enabled?:any/c
parameter
(sandbox-propagate-breaks)->boolean?
(sandbox-propagate-breakspropagate?)->void?
propagate?:any/c
parameter
(sandbox-propagate-exceptions)->boolean?
(sandbox-propagate-exceptionspropagate?)->void?
propagate?:any/c
parameter
(sandbox-namespace-specs)->(cons/c(->namespace?)
                             (listofmodule-path?))
(sandbox-namespace-specsspec)->void?
spec:(cons/c(->namespace?)
         (listofmodule-path?))
procedure
(sandbox-make-namespace)->namespace?
parameter
(sandbox-gui-available)->boolean?
(sandbox-gui-availableavail?)->void?
avail?:any/c
parameter
(sandbox-override-collection-paths)->(listofpath-string?)
(sandbox-override-collection-pathspaths)->void?
paths:(listofpath-string?)
parameter
(sandbox-security-guard)
->(or/csecurity-guard?(->security-guard?))
(sandbox-security-guardguard)->void?
guard:(or/csecurity-guard?(->security-guard?))
parameter
(sandbox-path-permissions)
->(listof(list/c(or/c'execute'write'delete
    'read-bytecode'read'exists)
    (or/cbyte-regexp?bytes?string?path?)))
(sandbox-path-permissionsperms)->void?
perms:(listof(list/c(or/c'execute'write'delete
          'read-bytecode'read'exists)
          (or/cbyte-regexp?bytes?string?path?)))
parameter
(sandbox-network-guard)
->(symbol?
    (or/c(and/cstring?immutable?)#f)
    (or/c(integer-in165535)#f)
    (or/c'server'client)
    . -> .any)
(sandbox-network-guardproc)->void?
proc:(symbol?
         (or/c(and/cstring?immutable?)#f)
         (or/c(integer-in165535)#f)
         (or/c'server'client)
         . -> .any)
parameter
(sandbox-exit-handler)->(any/c. -> .any)
(sandbox-exit-handlerhandler)->void?
handler:(any/c. -> .any)
parameter
(sandbox-memory-limit)->(or/c(>=/c0)#f)
(sandbox-memory-limitlimit)->void?
limit:(or/c(>=/c0)#f)
parameter
(sandbox-eval-limits)->(or/c(list/c(or/c(>=/c0)#f)
                         (or/c(>=/c0)#f))
                         #f)
(sandbox-eval-limitslimits)->void?
limits:(or/c(list/c(or/c(>=/c0)#f)
           (or/c(>=/c0)#f))
           #f)
parameter
(sandbox-eval-handlers)
->(list/c(or/c#f((->any). -> .any))
    (or/c#f((->any). -> .any)))
(sandbox-eval-handlershandlers)->void?
handlers:(list/c(or/c#f((->any). -> .any))
             (or/c#f((->any). -> .any)))
parameter
(sandbox-run-submodules)->(list/csymbol?)
(sandbox-run-submodulessubmod-syms)->void?
submod-syms:(list/csymbol?)
parameter
(sandbox-make-inspector)->(->inspector?)
(sandbox-make-inspectormake)->void?
make:(->inspector?)
parameter
(sandbox-make-code-inspector)->(->inspector?)
(sandbox-make-code-inspectormake)->void?
make:(->inspector?)
parameter
(sandbox-make-logger)->(->logger?)
(sandbox-make-loggermake)->void?
make:(->logger?)
parameter
(sandbox-make-environment-variables)
->(->environment-variables?)
(sandbox-make-environment-variablesmake)->void?
make:(->environment-variables?)
procedure
(evaluator-alive?evaluator)->boolean?
evaluator:(any/c. -> .any)
procedure
(kill-evaluatorevaluator)->void?
evaluator:(any/c. -> .any)
procedure
(break-evaluatorevaluator)->void?
evaluator:(any/c. -> .any)
procedure
(get-user-custodianevaluator)->void?
evaluator:(any/c. -> .any)
procedure
(set-eval-limitsevaluatorsecsmb)->void?
evaluator:(any/c. -> .any)
secs:(or/cexact-nonnegative-integer?#f)
mb:(or/cexact-nonnegative-integer?#f)
procedure
(set-eval-handlerevaluatorhandler)->void?
evaluator:(any/c. -> .any)
handler:(or/c#f((->any). -> .any))
procedure
(call-with-custodian-shutdownthunk)->any
thunk:(->any)
(call-with-killing-threadsthunk)->any
thunk:(->any)
procedure
(put-inputevaluator)->output-port?
evaluator:(any/c. -> .any)
(put-inputevaluatori/o)->void?
evaluator:(any/c. -> .any)
i/o:(or/cbytes?string?eof-object?)
procedure
(get-outputevaluator)->(or/c#finput-port?bytes?string?)
evaluator:(any/c. -> .any)
(get-error-outputevaluator)
->(or/c#finput-port?bytes?string?)
evaluator:(any/c. -> .any)
procedure
(get-uncovered-expressions evaluator 
                         [prog?     
                          src])    ->(listofsyntax?)
evaluator:(any/c. -> .any)
prog?:any/c=#t
src:any/c=default-src
procedure
(call-in-sandbox-context evaluator       
                        thunk           
                       [unrestricted?])->any
evaluator:(any/c. -> .any)
thunk:(->any)
unrestricted?:boolean?=#f
value
gui?:boolean?
procedure
(call-with-limitssecsmbthunk)->any
secs:(or/cexact-nonnegative-integer?#f)
mb:(or/cexact-nonnegative-integer?#f)
thunk:(->any)
syntax
(with-limitssec-exprmb-exprbody...)
procedure
(exn:fail:resource?v)->boolean?
v:any/c
(exn:fail:resource-resourceexn)->(or/c'time'memory)
exn:exn:fail:resource?
procedure
(path?v)->boolean?
v:any/c
procedure
(path-string?v)->boolean?
v:any/c
procedure
(path-for-some-system?v)->boolean?
v:any/c
procedure
(string->pathstr)->path?
str:string?
procedure
(bytes->pathbstr[type])->path?
bstr:bytes?
type:(or/c'unix'windows)=(system-path-convention-type)
procedure
(path->stringpath)->string?
path:path?
procedure
(path->bytespath)->bytes?
path:path-for-some-system?
procedure
(string->path-elementstr)->path?
str:string?
procedure
(bytes->path-elementbstr[type])->path-for-some-system?
bstr:bytes?
type:(or/c'unix'windows)=(system-path-convention-type)
procedure
(path-element->stringpath)->string?
path:path-element?
procedure
(path-element->bytespath)->bytes?
path:path-element?
procedure
(path<?a-pathb-path...)->boolean?
a-path:path?
b-path:path?
procedure
(path-convention-typepath)->(or/c'unix'windows)
path:path-for-some-system?
procedure
(system-path-convention-type)->(or/c'unix'windows)
procedure
(build-pathbasesub...)->path-for-some-system?
base:(or/cpath-string?path-for-some-system?'up'same)
sub:(or/c(and/c(or/cpath-string?path-for-some-system?)
        (not/ccomplete-path?))
        (or/c'up'same))
procedure
(build-path/convention-typetype     
                          base     
                          sub...)->path-for-some-system?
type:(or/c'unix'windows)
base:(or/cpath-string?path-for-some-system?'up'same)
sub:(or/c(and/c(or/cpath-string?path-for-some-system?)
        (not/ccomplete-path?))
        (or/c'up'same))
procedure
(absolute-path?path)->boolean?
path:(or/cpath-string?path-for-some-system?)
procedure
(relative-path?path)->boolean?
path:(or/cpath-string?path-for-some-system?)
procedure
(complete-path?path)->boolean?
path:(or/cpath-string?path-for-some-system?)
procedure
(path->complete-pathpath[base])->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
base:(or/cpath-string?path-for-some-system?)
    =(current-directory)
procedure
(path->directory-pathpath)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
procedure
(resolve-pathpath)->path?
path:path-string?
procedure
(cleanse-pathpath)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
procedure
(expand-user-pathpath)->path?
path:path-string?
procedure
(simplify-pathpath[use-filesystem?])->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
use-filesystem?:boolean?=#t
procedure
(normal-case-pathpath)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
procedure
(split-pathpath)->(or/cpath-for-some-system?'relative#f)
                     (or/cpath-for-some-system?'up'same)
                     boolean?
path:(or/cpath-string?path-for-some-system?)
procedure
(explode-pathpath)
->(listof(or/cpath-for-some-system?'up'same))
path:(or/cpath-string?path-for-some-system?)
procedure
(path-replace-suffixpathsuffix)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
suffix:(or/cstring?bytes?)
procedure
(path-add-suffixpathsuffix)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
suffix:(or/cstring?bytes?)
procedure
(reroot-pathpathroot-path)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
root-path:(or/cpath-string?path-for-some-system?)
procedure
(file-name-from-pathpath)->(or/cpath-for-some-system?#f)
path:(or/cpath-string?path-for-some-system?)
procedure
(filename-extensionpath)->(or/cbytes?#f)
path:(or/cpath-string?path-for-some-system?)
procedure
(find-relative-path base                               
                   path                               
                  [#:more-than-root?more-than-root?])
->path-for-some-system?
base:(or/cpath-string?path-for-some-system?)
path:(or/cpath-string?path-for-some-system?)
more-than-root?:any/c=#f
procedure
(normalize-pathpath[wrt])->path?
path:path-string?
wrt:(and/cpath-string?complete-path?)
   =(current-directory)
procedure
(path-element?path)->boolean?
path:any/c
procedure
(path-onlypath)->(or/c#fpath-for-some-system?)
path:(or/cpath-string?path-for-some-system?)
procedure
(simple-form-pathpath)->path?
path:path-string?
procedure
(some-system-path->stringpath)->string?
path:path-for-some-system?
procedure
(string->some-system-pathstrkind)->path-for-some-system?
str:string?
kind:(or/c'unix'windows)
procedure
(shrink-path-wrtpthother-pths)->(or/c#fpath?)
pth:path?
other-pths:(listofpath?)
procedure
(find-system-pathkind)->path?
kind:symbol?
procedure
(path-list-string->path-liststr               
                           default-path-list)
->(listofpath?)
str:(or/cstring?bytes?)
default-path-list:(listofpath?)
procedure
(find-executable-path program-sub 
                    [related-sub 
                     deepest?]) ->(or/cpath?#f)
program-sub:path-string?
related-sub:(or/cpath-string?#f)=#f
deepest?:any/c=#f
procedure
(file-exists?path)->boolean?
path:path-string?
procedure
(link-exists?path)->boolean?
path:path-string?
procedure
(delete-filepath)->void?
path:path-string?
procedure
(rename-file-or-directory old          
                         new          
                        [exists-ok?])->void?
old:path-string?
new:path-string?
exists-ok?:any/c=#f
procedure
(file-or-directory-modify-seconds path         
                                [secs-n       
                                 fail-thunk])->any
path:path-string?
secs-n:(or/cexact-integer?#f)=#f
fail-thunk:(->any)
          =(lambda()(raise(make-exn:fail:filesystem....)))
procedure
(file-or-directory-permissionspath[mode])
->(listof(or/c'read'write'execute))
path:path-string?
mode:#f=#f
(file-or-directory-permissionspathmode)->(integer-in065535)
path:path-string?
mode:'bits
(file-or-directory-permissionspathmode)->void
path:path-string?
mode:(integer-in065535)
procedure
(file-or-directory-identitypath[as-link?])
->exact-positive-integer?
path:path-string?
as-link?:any/c=#f
procedure
(file-sizepath)->exact-nonnegative-integer?
path:path-string?
procedure
(copy-filesrcdest[exists-ok?])->void?
src:path-string?
dest:path-string?
exists-ok?:any/c=#f
procedure
(make-file-or-directory-linktopath)->void?
to:path-string?
path:path-string?
parameter
(current-directory)->(and/cpath?complete-path?)
(current-directorypath)->void?
path:path-string?
parameter
(current-directory-for-user)->(and/cpath?complete-path?)
(current-directory-for-userpath)->void?
path:path-string?
procedure
(current-drive)->path?
procedure
(directory-exists?path)->boolean?
path:path-string?
procedure
(make-directorypath)->void?
path:path-string?
procedure
(delete-directorypath)->void?
path:path-string?
procedure
(directory-list[path#:build?build?])->(listofpath?)
path:path-string?=(current-directory)
build?:any/c=#f
procedure
(filesystem-root-list)->(listofpath?)
procedure
(filesystem-change-evt?v)->boolean?
v:any/c
procedure
(filesystem-change-evtpath)->filesystem-change-evt?
path:path-string?
(filesystem-change-evtpathfailure-thunk)->any
path:path-string?
failure-thunk:(->any)
procedure
(filesystem-change-evt-cancelevt)->void?
evt:filesystem-change-evt?
syntax
(define-runtime-pathidexpr)
syntax
(define-runtime-paths(id...)expr)
syntax
(define-runtime-path-listidexpr)
syntax
(define-runtime-module-path-indexidmodule-path-expr)
syntax
(runtime-requiremodule-path)
syntax
(define-runtime-module-pathidmodule-path)
syntax
(runtime-pathsmodule-path)
procedure
(file->stringpath[#:modemode-flag])->string?
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(file->bytespath[#:modemode-flag])->bytes?
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(file->valuepath[#:modemode-flag])->any
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(file->listpath[proc#:modemode-flag])->(listofany/c)
path:path-string?
proc:(input-port?. -> .any/c)=read
mode-flag:(or/c'binary'text)='binary
procedure
(file->lines path                    
           [#:modemode-flag        
            #:line-modeline-mode])->(listofstring?)
path:path-string?
mode-flag:(or/c'binary'text)='binary
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
procedure
(file->bytes-lines path                    
                 [#:modemode-flag        
                  #:line-modeline-mode])->(listofbytes?)
path:path-string?
mode-flag:(or/c'binary'text)='binary
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
procedure
(display-to-file v                      
                path                   
               [#:modemode-flag       
                #:existsexists-flag])->void?
v:any/c
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(write-to-file v                      
              path                   
             [#:modemode-flag       
              #:existsexists-flag])->void?
v:any/c
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(display-lines-to-file lst                    
                      path                   
                     [#:separatorseparator  
                      #:modemode-flag       
                      #:existsexists-flag])->void?
lst:list?
path:path-string?
separator:any/c=#"\n"
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(copy-directory/files                                             
                    src                                         
                    dest                                        
                    #:keep-modify-seconds?keep-modify-seconds?)
->void?
src:path-string?
dest:path-string?
keep-modify-seconds?:#f
procedure
(delete-directory/filespath                       
                      #:must-exist?must-exist?)->void?
path:path-string?
must-exist?:#t
procedure
(find-files predicate                      
          [start-path]                    
           #:follow-links?follow-links?)->(listofpath?)
predicate:(path?. -> .any/c)
start-path:(or/cpath-string?#f)=#f
follow-links?:#f
procedure
(pathlist-closurepath-list                     
                #:follow-links?follow-links?)
->(listofpath?)
path-list:(listofpath-string?)
follow-links?:#f
procedure
(fold-files proc            
           init-val        
          [start-path      
           follow-links?])->any
proc:(or/c(path?(or/c'file'dir'link)any/c
         . -> .any/c)
         (path?(or/c'file'dir'link)any/c
         . -> .(valuesany/cany/c)))
init-val:any/c
start-path:(or/cpath-string?#f)=#f
follow-links?:any/c=#t
procedure
(make-directory*path)->void?
path:path-string?
procedure
(make-temporary-file[template           
                    copy-from-filename 
                    directory])       ->path?
template:string?="rkttmp~a"
copy-from-filename:(or/cpath-string?#f'directory)=#f
directory:(or/cpath-string?#f)=#f
procedure
(call-with-atomic-output-file file                             
                             proc                             
                            [#:security-guardsecurity-guard])
->any
file:path-string?
proc:([portinput-port?][tmp-pathpath?]. -> .any)
security-guard:(or/c#fsecurity-guard?)=#f
procedure
(get-preference name                                    
              [failure-thunk                           
               flush-mode                              
               filename                                
               #:use-lock?use-lock?                   
               #:timeout-lock-theretimeout-lock-there 
               #:lock-therelock-there])              ->any
name:symbol?
failure-thunk:(->any)=(lambda()#f)
flush-mode:any/c='timestamp
filename:(or/cstring-path?#f)=#f
use-lock?:any/c=#t
timeout-lock-there:(or/c(path?. -> .any)#f)=#f
lock-there:(or/c(path?. -> .any)#f)
          =(make-handle-get-preference-locked
               0.01namefailure-thunkflush-modefilename
               #:lock-theretimeout-lock-there)
procedure
(put-preferences names       
                vals        
               [locked-proc 
                filename]) ->void?
names:(listofsymbol?)
vals:list?
locked-proc:(or/c#f(path?. -> .any))=#f
filename:(or/c#fpath-string?)=#f
procedure
(preferences-lock-file-mode)->(or/c'exists'file-lock)
procedure
(make-handle-get-preference-locked delay                  
                                  name                   
                                 [failure-thunk          
                                  flush-mode             
                                  filename               
                                  #:lock-therelock-there
                                  #:max-delaymax-delay])
->(path-string?. -> .any)
delay:real?
name:symbol?
failure-thunk:(->any)=(lambda()#f)
flush-mode:any/c='timestamp
filename:(or/cpath-string?#f)=#f
lock-there:(or/c(path?. -> .any)#f)=#f
max-delay:real?=0.2
procedure
(call-with-file-lock/timeout filename                
                            kind                    
                            thunk                   
                            failure-thunk           
                           [#:lock-filelock-file   
                            #:delaydelay           
                            #:max-delaymax-delay])->any
filename:(or/cpath-string?#f)
kind:(or/c'shared'exclusive)
thunk:(->any)
failure-thunk:(->any)
lock-file:(or/c#fpath-string?)=#f
delay:(and/creal?(not/cnegative?))=0.01
max-delay:(and/creal?(not/cnegative?))=0.2
procedure
(make-lock-file-namepath)->path?
path:(orpath-string?path-for-some-system?)
(make-lock-file-namedirname)->path?
dir:(orpath-string?path-for-some-system?)
name:path-element?
value
user-read-bit:#o400
value
user-write-bit:#o200
value
user-execute-bit:#o100
value
group-read-bit:#o040
value
group-write-bit:#o020
value
group-execute-bit:#o010
value
other-read-bit:#o004
value
other-write-bit:#o002
value
other-execute-bit:#o001
procedure
(tcp-listen port-no        
          [max-allow-wait 
           reuse?         
           hostname])    ->tcp-listener?
port-no:(integer-in065535)
max-allow-wait:exact-nonnegative-integer?=4
reuse?:any/c=#f
hostname:(or/cstring?#f)=#f
procedure
(tcp-connect hostname        
            port-no         
           [local-hostname  
            local-port-no])->input-port?output-port?
hostname:string?
port-no:(integer-in165535)
local-hostname:(or/cstring?#f)=#f
local-port-no:(or/c(integer-in165535)#f)=#f
procedure
(tcp-connect/enable-break hostname       
                         port-no        
                        [local-hostname]
                         local-port-no) 
->input-port?output-port?
hostname:string?
port-no:(integer-in165535)
local-hostname:(or/cstring?#f)=#f
local-port-no:(or/c(integer-in165535)#f)
procedure
(tcp-acceptlistener)->input-port?output-port?
listener:tcp-listener?
procedure
(tcp-accept/enable-breaklistener)->input-port?output-port?
listener:tcp-listener?
procedure
(tcp-accept-ready?listener)->boolean?
listener:tcp-listener?
procedure
(tcp-closelistener)->void?
listener:tcp-listener?
procedure
(tcp-listener?v)->boolean?
v:any/c
procedure
(tcp-accept-evtlistener)->evt?
listener:tcp-listener?
procedure
(tcp-abandon-porttcp-port)->void?
tcp-port:tcp-port?
procedure
(tcp-addressestcp-port[port-numbers?])
->(or/c(valuesstring?string?)
    (valuesstring?(integer-in165535)
    string?(integer-in065535)))
tcp-port:(or/ctcp-port?tcp-listener?)
port-numbers?:any/c=#f
procedure
(tcp-port?v)->boolean?
v:any/c
procedure
(udp-open-socket[family-hostname  
                family-port-no])->udp?
family-hostname:(or/cstring?#f)=#f
family-port-no:(or/c(integer-in165535)#f)=#f
procedure
(udp-bind! udp-socket      
          hostname-string 
          port-no         
         [reuse?])       ->void?
udp-socket:udp?
hostname-string:(or/cstring?#f)
port-no:(integer-in065535)
reuse?:any/c=#f
procedure
(udp-connect!udp-socket      
            hostname-string 
            port-no)       ->void?
udp-socket:udp?
hostname-string:(or/cstring?#f)
port-no:(or/c(integer-in165535)
            #f)
procedure
(udp-send-to udp-socket 
            hostname   
            port-no    
            bstr       
           [start-pos  
            end-pos]) ->void
udp-socket:udp?
hostname:string?
port-no:(integer-in165535)
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-sendudp-socketbstr[start-posend-pos])->void
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send-to* udp-socket 
             hostname   
             port-no    
             bstr       
            [start-pos  
             end-pos]) ->boolean?
udp-socket:udp?
hostname:string?
port-no:(integer-in165535)
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send*udp-socketbstr[start-posend-pos])->boolean?
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send-to/enable-break udp-socket 
                         hostname   
                         port-no    
                         bstr       
                        [start-pos  
                         end-pos]) ->void
udp-socket:udp?
hostname:string?
port-no:(integer-in165535)
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send/enable-break udp-socket 
                      bstr       
                     [start-pos  
                      end-pos]) ->void
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive! udp-socket 
             bstr       
            [start-pos  
             end-pos]) ->exact-nonnegative-integer?
                             string?
                             (integer-in165535)
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive!* udp-socket
              bstr      
             [start-pos 
              end-pos]) 
->(or/cexact-nonnegative-integer?#f)
    (or/cstring?#f)
    (or/c(integer-in165535)#f)
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive!/enable-break udp-socket
                          bstr      
                         [start-pos 
                          end-pos]) 
->exact-nonnegative-integer?
    string?
    (integer-in165535)
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-closeudp-socket)->void?
udp-socket:udp?
procedure
(udp?v)->boolean?
v:any/c
procedure
(udp-bound?udp-socket)->boolean?
udp-socket:udp?
procedure
(udp-connected?udp-socket)->boolean?
udp-socket:udp?
procedure
(udp-send-ready-evtudp-socket)->evt?
udp-socket:udp?
procedure
(udp-receive-ready-evtudp-socket)->evt?
udp-socket:udp?
procedure
(udp-send-to-evt udp-socket 
                hostname   
                port-no    
                bstr       
               [start-pos  
                end-pos]) ->evt?
udp-socket:udp?
hostname:string?
port-no:(integer-in165535)
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send-evt udp-socket 
             bstr       
            [start-pos  
             end-pos]) ->evt?
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive!-evt udp-socket 
                 bstr       
                [start-pos  
                 end-pos]) ->evt?
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-addressesudp-port[port-numbers?])
->(or/c(valuesstring?string?)
    (valuesstring?(integer-in065535)
    string?(integer-in065535)))
udp-port:udp?
port-numbers?:any/c=#f
procedure
(udp-multicast-join-group!udp-socket     
                         multicast-addr 
                         hostname)     ->void?
udp-socket:udp?
multicast-addr:string?
hostname:(or/cstring?#f)
procedure
(udp-multicast-leave-group!udp-socket     
                          multicast-addr 
                          hostname)     ->void?
udp-socket:udp?
multicast-addr:string?
hostname:(or/cstring?#f)
procedure
(udp-multicast-interfaceudp-socket)->string?
udp-socket:udp?
procedure
(udp-multicast-set-interface!udp-socket 
                            hostname) ->void?
udp-socket:udp?
hostname:(or/cstring?#f)
procedure
(udp-multicast-set-loopback!udp-socket 
                           loopback?)->void?
udp-socket:udp?
loopback?:any/c
procedure
(udp-multicast-loopback?udp-socket)->boolean?
udp-socket:udp?
procedure
(udp-multicast-set-ttl!udp-socketttl)->void?
udp-socket:udp?
ttl:byte?
procedure
(udp-multicast-ttludp-socket)->byte?
udp-socket:udp?
procedure
(subprocessstdout  
          stdin   
          stderr  
          command 
          arg...)
->subprocess?
    (or/c(and/cinput-port?file-stream-port?)#f)
    (or/c(and/coutput-port?file-stream-port?)#f)
    (or/c(and/cinput-port?file-stream-port?)#f)
stdout:(or/c(and/coutput-port?file-stream-port?)#f)
stdin:(or/c(and/cinput-port?file-stream-port?)#f)
stderr:(or/c(and/coutput-port?file-stream-port?)#f'stdout)
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
(subprocessstdout 
          stdin  
          stderr 
          command
          exact  
          arg)   
->subprocess?
    (or/c(and/cinput-port?file-stream-port?)#f)
    (or/c(and/coutput-port?file-stream-port?)#f)
    (or/c(and/cinput-port?file-stream-port?)#f)
stdout:(or/c(and/coutput-port?file-stream-port?)#f)
stdin:(or/c(and/cinput-port?file-stream-port?)#f)
stderr:(or/c(and/coutput-port?file-stream-port?)#f)
command:path-string?
exact:'exact
arg:string?
procedure
(subprocess-waitsubproc)->void?
subproc:subprocess?
procedure
(subprocess-statussubproc)->(or/c'running
                               exact-nonnegative-integer?)
subproc:subprocess?
procedure
(subprocess-killsubprocforce?)->void?
subproc:subprocess?
force?:any/c
procedure
(subprocess-pidsubproc)->exact-nonnegative-integer?
subproc:subprocess?
procedure
(subprocess?v)->boolean?
v:any/c
parameter
(current-subprocess-custodian-mode)
->(or/c#f'kill'interrupt)
(current-subprocess-custodian-modemode)->void?
mode:(or/c#f'kill'interrupt)
parameter
(subprocess-group-enabled)->boolean?
(subprocess-group-enabledon?)->void?
on?:any/c
procedure
(shell-executeverb       
             target     
             parameters 
             dir        
             show-mode)->#f
verb:(or/cstring?#f)
target:string?
parameters:string?
dir:path-string?
show-mode:symbol?
procedure
(systemcommand[#:set-pwd?set-pwd?])->boolean?
command:(or/cstring-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(system*commandarg...[#:set-pwd?set-pwd?])->boolean?
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(system* command               
        exact                 
        arg                   
       [#:set-pwd?set-pwd?])->boolean?
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(system/exit-code command               
                [#:set-pwd?set-pwd?])->byte?
command:(or/cstring-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(system*/exit-code command               
                  arg...               
                 [#:set-pwd?set-pwd?])->byte?
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(system*/exit-code command               
                  exact                 
                  arg                   
                 [#:set-pwd?set-pwd?])->byte?
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(processcommand[#:set-pwd?set-pwd?])
->(listinput-port?
    output-port?
    exact-nonnegative-integer?
    input-port?
    ((or/c'status'wait'interrupt'kill). -> .any))
command:(or/cstring-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(process* command               
         arg...               
        [#:set-pwd?set-pwd?])->list?
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(process* command               
         exact                 
         arg                   
        [#:set-pwd?set-pwd?])->list?
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(process/ports out                   
              in                    
              error-out             
              command               
             [#:set-pwd?set-pwd?])->list?
out:(or/c#foutput-port?)
in:(or/c#finput-port?)
error-out:(or/c#foutput-port?'stdout)
command:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(process*/ports out                   
               in                    
               error-out             
               command               
               arg...               
              [#:set-pwd?set-pwd?])->list?
out:(or/c#foutput-port?)
in:(or/c#finput-port?)
error-out:(or/c#foutput-port?'stdout)
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(process*/ports out                   
               in                    
               error-out             
               command               
               exact                 
               arg                   
              [#:set-pwd?set-pwd?])->list?
out:(or/c#foutput-port?)
in:(or/c#finput-port?)
error-out:(or/c#foutput-port?'stdout)
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(string-no-nuls?x)->boolean?
x:any/c
procedure
(bytes-no-nuls?x)->boolean?
x:any/c
procedure
(logger?v)->boolean?
v:any/c
procedure
(make-logger[nameparentnotify-callback])->logger?
name:(or/csymbol?#f)=#f
parent:(or/clogger?#f)=#f
notify-callback:(vector?. -> .any/c)=#f
procedure
(logger-namelogger)->(or/csymbol?#f)
logger:logger?
parameter
(current-logger)->logger?
(current-loggerlogger)->void?
logger:logger?
syntax
(define-loggerid)
procedure
(log-messageloggerlevel[name]messagedata)->void?
logger:logger?
level:(or/c'fatal'error'warning'info'debug)
name:(or/csymbol?#f)=(object-namelogger)
message:string?
data:any/c
procedure
(log-level?loggerlevel)->boolean?
logger:logger?
level:(or/c'fatal'error'warning'info'debug)
procedure
(log-max-levellogger)
->(or/c#f'fatal'error'warning'info'debug)
logger:logger?
syntax
(log-fatalstring-expr)
(log-fatalformat-string-exprv...)
syntax
(log-errorstring-expr)
(log-errorformat-string-exprv...)
syntax
(log-warningstring-expr)
(log-warningformat-string-exprv...)
syntax
(log-infostring-expr)
(log-infoformat-string-exprv...)
syntax
(log-debugstring-expr)
(log-debugformat-string-exprv...)
procedure
(log-receiver?v)->boolean?
v:any/c
procedure
(make-log-receiverloggerlevel[name...]...)->log-receiver?
logger:logger?
level:(or/c'none'fatal'error'warning'info'debug)
name:(or/c#fsymbol?)=#f
procedure
(current-seconds)->exact-integer?
procedure
(current-inexact-milliseconds)->real?
procedure
(seconds->datesecs-n[local-time?])->date*?
secs-n:real?
local-time?:any/c=#t
struct
(structdate                              (second
                                       minute
                                       hour
                                       day
                                       month
                                       year
                                       week-day
                                       year-day
                                       dst?
                                       time-zone-offset)
      #:extra-constructor-namemake-date
      #:transparent)
second:(integer-in060)
minute:(integer-in059)
hour:(integer-in023)
day:(integer-in131)
month:(integer-in112)
year:exact-integer?
week-day:(integer-in06)
year-day:(integer-in0365)
dst?:boolean?
time-zone-offset:exact-integer?
struct
(structdate*date(nanosecond time-zone-name)
      #:extra-constructor-namemake-date*)
nanosecond:(integer-in0999999999)
time-zone-name:(and/cstring?immutable?)
procedure
(current-milliseconds)->exact-integer?
procedure
(current-process-millisecondsthread)->exact-integer?
thread:(or/cthread?#f)
procedure
(current-gc-milliseconds)->exact-integer?
procedure
(time-applyproclst)->list?
                         exact-integer?
                         exact-integer?
                         exact-integer?
proc:procedure?
lst:list?
syntax
(timebody...+)
procedure
(current-date)->date*?
procedure
(date->stringdate[time?])->string?
date:date?
time?:any/c=#f
parameter
(date-display-format)->(or/c'american
                         'chinese
                         'german
                         'indian
                         'irish
                         'iso-8601
                         'rfc2822
                         'julian)
(date-display-formatformat)->void?
format:(or/c'american
           'chinese
           'german
           'indian
           'irish
           'iso-8601
           'rfc2822
           'julian)
procedure
(date->secondsdate[local-time?])->exact-integer?
date:date?
local-time?:any/c=#t
procedure
(date*->secondsdate[local-time?])->real?
date:date?
local-time?:any/c=#t
procedure
(find-seconds second        
             minute        
             hour          
             day           
             month         
             year          
            [local-time?])->exact-integer?
second:(integer-in061)
minute:(integer-in059)
hour:(integer-in023)
day:(integer-in131)
month:(integer-in112)
year:exact-nonnegative-integer?
local-time?:any/c=#t
procedure
(date->julian/scalingerdate)->exact-integer?
date:date?
procedure
(julian/scalinger->stringdate-number)->string?
date-number:exact-integer?
procedure
(environment-variables?v)->boolean?
v:any/c
parameter
(current-environment-variables)->environment-variables?
(current-environment-variablesenv)->void?
env:environment-variables?
procedure
(bytes-environment-variable-name?v)->boolean?
v:any/c
procedure
(make-environment-variablesnameval......)
->environment-variables?
name:bytes-environment-variable-name?
val:bytes-no-nuls?
procedure
(environment-variables-refenvname)
->(or/c#f(and/cbytes-no-nuls?immutable?))
env:environment-variables?
name:bytes-environment-variable-name?
procedure
(environment-variables-set! env        
                           name       
                           maybe-bstr 
                          [fail])    ->any
env:environment-variables?
name:bytes-environment-variable-name?
maybe-bstr:(or/cbytes-no-nuls?#f)
fail:(->any)=(lambda()
                    (raise(make-exn:fail....)))
procedure
(environment-variables-namesenv)
->(listof(and/cbytes-environment-variable-name?immutable?))
env:environment-variables?
procedure
(environment-variables-copyenv)->environment-variables?
env:environment-variables?
procedure
(getenvname)->(or/cstring-no-nuls?#f)
name:string-environment-variable-name?
procedure
(putenvnamevalue)->boolean?
name:string-environment-variable-name?
value:string-no-nuls?
procedure
(string-environment-variable-name?v)->boolean?
v:any/c
procedure
(system-type[mode])
->(or/csymbol?string?bytes?exact-positive-integer?vector?)
mode:(or/c'os'word'gc'link'machine   ='os
         'so-suffix'so-mode'fs-change)
procedure
(system-language+country)->string?
procedure
(system-library-subpath[mode])->path?
mode:(or/c'cgc'3m#f)=(system-type'gc)
procedure
(version)->(and/cstring?immutable?)
procedure
(banner)->(and/cstring?immutable?)
parameter
(current-command-line-arguments)->(vectorofstring?)
(current-command-line-argumentsargv)->void?
argv:(vectorof(and/cstring?immutable?))
parameter
(current-thread-initial-stack-size)->exact-positive-integer?
(current-thread-initial-stack-sizesize)->void?
size:exact-positive-integer?
procedure
(vector-set-performance-stats!results[thd])->void?
results:(and/cvector?
            (not/cimmutable?))
thd:(or/cthread?#f)=#f
syntax
(command-lineoptional-name-exproptional-argv-expr
flag-clause...
finish-clause)

optional-name-expr=
                 |#:programname-expr
                 
optional-argv-expr=
                 |#:argvargv-expr
                 
flag-clause       =#:multiflag-spec...
                 |#:once-eachflag-spec...
                 |#:once-anyflag-spec...
                 |#:finalflag-spec...
                 |#:usage-helpstring...
                 |#:help-labelsstring...
                 |#:psstring...
                 
flag-spec         =(flagsid...help-specbody...+)
                 |(flags=>handler-exprhelp-expr)
                 
flags             =flag-string
                 |(flag-string...+)
                 
help-spec         =string
                 |(string-expr...+)
                 
finish-clause     =
                 |#:argsarg-formalsbody...+
                 |#:handlershandlers-exprs
                 
arg-formals       =rest-id
                 |(arg...)
                 |(arg...+. rest-id)
                 
arg               =id
                 |[iddefault-expr]
                 
handlers-exprs    =finish-exprarg-strings-expr
                 |finish-exprarg-strings-exprhelp-expr
                 |finish-exprarg-strings-exprhelp-expr
                     unknown-expr
procedure
(parse-command-line name           
                   argv           
                   table          
                   finish-proc    
                   arg-help-strs  
                  [help-proc      
                   unknown-proc])->any
name:(or/cstring?path?)
argv:(or/c(listofstring?)(vectorofstring?))
table:(listof(cons/csymbol?list?))
finish-proc:((list?)()#:restlist?. ->* .any)
arg-help-strs:(listofstring?)
help-proc:(string?. -> .any)=(lambda(str)....)
unknown-proc:(string?. -> .any)=(lambda(str)...)
procedure
(make-weak-boxv)->weak-box?
v:any/c
procedure
(weak-box-valueweak-box[gced-v])->any/c
weak-box:weak-box?
gced-v:any/c=#f
procedure
(weak-box?v)->boolean?
v:any/c
procedure
(make-ephemeronkeyv)->ephemeron?
key:any/c
v:any/c
procedure
(ephemeron-valueephemeron[gced-v])->any/c
ephemeron:ephemeron?
gced-v:any/c=#f
procedure
(ephemeron?v)->boolean?
v:any/c
procedure
(make-will-executor)->will-executor?
procedure
(will-executor?v)->boolean?
v:any/c
procedure
(will-registerexecutorvproc)->void?
executor:will-executor?
v:any/c
proc:(any/c. -> .any)
procedure
(will-executeexecutor)->any
executor:will-executor?
procedure
(will-try-executeexecutor)->any
executor:any/c
procedure
(collect-garbage)->void?
procedure
(current-memory-use[cust])->exact-nonnegative-integer?
cust:custodian?=#f
procedure
(dump-memory-statsv...)->any
v:any/c
procedure
(phantom-bytes?v)->boolean?
v:any/c
procedure
(make-phantom-bytesk)->phantom-bytes?
k:exact-nonnegative-integer?
procedure
(set-phantom-bytes!phantom-bstrk)->phantom-bytes?
phantom-bstr:phantom-bytes?
k:exact-nonnegative-integer?
procedure
(unsafe-fx+ab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx-ab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx*ab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxquotientab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxremainderab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxmoduloab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxabsa)->fixnum?
a:fixnum?
procedure
(unsafe-fxandab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxiorab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxxorab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxnota)->fixnum?
a:fixnum?
procedure
(unsafe-fxlshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxrshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx=ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx<ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx>ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx<=ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx>=ab)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxminab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxmaxab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fl+ab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-fl-ab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-fl*ab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-fl/ab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-flabsa)->flonum?
a:flonum?
procedure
(unsafe-fl=ab)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl<ab)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl>ab)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl<=ab)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl>=ab)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-flminab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-flmaxab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-flrounda)->flonum?
a:flonum?
procedure
(unsafe-flfloora)->flonum?
a:flonum?
procedure
(unsafe-flceilinga)->flonum?
a:flonum?
procedure
(unsafe-fltruncatea)->flonum?
a:flonum?
procedure
(unsafe-flsina)->flonum?
a:flonum?
procedure
(unsafe-flcosa)->flonum?
a:flonum?
procedure
(unsafe-fltana)->flonum?
a:flonum?
procedure
(unsafe-flasina)->flonum?
a:flonum?
procedure
(unsafe-flacosa)->flonum?
a:flonum?
procedure
(unsafe-flatana)->flonum?
a:flonum?
procedure
(unsafe-flloga)->flonum?
a:flonum?
procedure
(unsafe-flexpa)->flonum?
a:flonum?
procedure
(unsafe-flsqrta)->flonum?
a:flonum?
procedure
(unsafe-flexptab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-make-flrectangularab)
->(and/ccomplex?inexact?(not/creal?))
a:flonum?
b:flonum?
procedure
(unsafe-flreal-parta)->flonum?
a:(and/ccomplex?inexact?(not/creal?))
procedure
(unsafe-flimag-parta)->flonum?
a:(and/ccomplex?inexact?(not/creal?))
procedure
(unsafe-fx->fla)->flonum?
a:fixnum?
procedure
(unsafe-fl->fxa)->fixnum?
a:flonum?
procedure
(unsafe-flrandomrand-gen)->(andflonum?(>/c0)(</c1))
rand-gen:pseudo-random-generator?
procedure
(unsafe-carp)->any/c
p:pair?
procedure
(unsafe-cdrp)->any/c
p:pair?
procedure
(unsafe-mcarp)->any/c
p:mpair?
procedure
(unsafe-mcdrp)->any/c
p:mpair?
procedure
(unsafe-set-mcar!pv)->void?
p:mpair?
v:any/c
procedure
(unsafe-set-mcdr!pv)->void?
p:mpair?
v:any/c
procedure
(unsafe-cons-listvrest)->(and/cpair?list?)
v:any/c
rest:list?
procedure
(unsafe-list-reflstpos)->any/c
lst:pair?
pos:(and/cexact-nonnegative-integer?fixnum?)
procedure
(unsafe-list-taillstpos)->any/c
lst:any/c
pos:(and/cexact-nonnegative-integer?fixnum?)
procedure
(unsafe-unboxb)->fixnum?
b:box?
procedure
(unsafe-set-box!bk)->void?
b:box?
k:fixnum?
procedure
(unsafe-unbox*v)->any/c
v:(and/cbox?(not/cimpersonator?))
procedure
(unsafe-set-box*!vval)->void?
v:(and/cbox?(not/cimpersonator?))
val:any/c
procedure
(unsafe-box*-cas!locoldnew)->boolean?
loc:box?
old:any/c
new:any/c
procedure
(unsafe-vector-lengthv)->fixnum?
v:vector?
procedure
(unsafe-vector-refvk)->any/c
v:vector?
k:fixnum?
procedure
(unsafe-vector-set!vkval)->void?
v:vector?
k:fixnum?
val:any/c
procedure
(unsafe-vector*-lengthv)->fixnum?
v:(and/cvector?(not/cimpersonator?))
procedure
(unsafe-vector*-refvk)->any/c
v:(and/cvector?(not/cimpersonator?))
k:fixnum?
procedure
(unsafe-vector*-set!vkval)->void?
v:(and/cvector?(not/cimpersonator?))
k:fixnum?
val:any/c
procedure
(unsafe-string-lengthstr)->fixnum?
str:string?
procedure
(unsafe-string-refstrk)
->(and/cchar?(lambda(ch)(<=0(char->integerch)255)))
str:string?
k:fixnum?
procedure
(unsafe-string-set!strkch)->void?
str:(and/cstring?(not/cimmutable?))
k:fixnum?
ch:char?
procedure
(unsafe-bytes-lengthbstr)->fixnum?
bstr:bytes?
procedure
(unsafe-bytes-refbstrk)->byte?
bstr:bytes?
k:fixnum?
procedure
(unsafe-bytes-set!bstrkb)->void?
bstr:(and/cbytes?(not/cimmutable?))
k:fixnum?
b:byte?
procedure
(unsafe-flvector-lengthv)->fixnum?
v:flvector?
procedure
(unsafe-flvector-refvk)->any/c
v:flvector?
k:fixnum?
procedure
(unsafe-flvector-set!vkx)->void?
v:flvector?
k:fixnum?
x:flonum?
procedure
(unsafe-f64vector-refveck)->flonum?
vec:f64vector?
k:fixnum?
procedure
(unsafe-f64vector-set!veckn)->void?
vec:f64vector?
k:fixnum?
n:flonum?
procedure
(unsafe-s16vector-refveck)->(integer-in-3276832767)
vec:s16vector?
k:fixnum?
procedure
(unsafe-s16vector-set!veckn)->void?
vec:s16vector?
k:fixnum?
n:(integer-in-3276832767)
procedure
(unsafe-u16vector-refveck)->(integer-in065535)
vec:u16vector?
k:fixnum?
procedure
(unsafe-u16vector-set!veckn)->void?
vec:u16vector?
k:fixnum?
n:(integer-in065535)
procedure
(unsafe-struct-refvk)->any/c
v:any/c
k:fixnum?
procedure
(unsafe-struct-set!vkval)->void?
v:any/c
k:fixnum?
val:any/c
procedure
(unsafe-struct*-refvk)->any/c
v:(not/cimpersonator?)
k:fixnum?
procedure
(unsafe-struct*-set!vkval)->void?
v:(not/cimpersonator?)
k:fixnum?
val:any/c
procedure
(unsafe-extfl+ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl-ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl*ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl/ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflabsa)->extflonum?
a:extflonum?
procedure
(unsafe-extfl=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl<ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl>ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl<=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl>=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflminab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflmaxab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflrounda)->extflonum?
a:extflonum?
procedure
(unsafe-extflfloora)->extflonum?
a:extflonum?
procedure
(unsafe-extflceilinga)->extflonum?
a:extflonum?
procedure
(unsafe-extfltruncatea)->extflonum?
a:extflonum?
procedure
(unsafe-extflsina)->extflonum?
a:extflonum?
procedure
(unsafe-extflcosa)->extflonum?
a:extflonum?
procedure
(unsafe-extfltana)->extflonum?
a:extflonum?
procedure
(unsafe-extflasina)->extflonum?
a:extflonum?
procedure
(unsafe-extflacosa)->extflonum?
a:extflonum?
procedure
(unsafe-extflatana)->extflonum?
a:extflonum?
procedure
(unsafe-extflloga)->extflonum?
a:extflonum?
procedure
(unsafe-extflexpa)->extflonum?
a:extflonum?
procedure
(unsafe-extflsqrta)->extflonum?
a:extflonum?
procedure
(unsafe-extflexptab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-fx->extfla)->extflonum?
a:fixnum?
procedure
(unsafe-extfl->fxa)->fixnum?
a:extflonum?
procedure
(unsafe-extflvector-lengthv)->fixnum?
v:extflvector?
procedure
(unsafe-extflvector-refvk)->any/c
v:extflvector?
k:fixnum?
procedure
(unsafe-extflvector-set!vkx)->void?
v:extflvector?
k:fixnum?
x:extflonum?
procedure
(find-library-collection-paths[pre-extras    
                              post-extras])->(listofpath?)
pre-extras:(listofpath-string?)=null
post-extras:(listofpath-string?)=null
procedure
(find-library-collection-links)
->(listof(or/c#f(and/cpath?complete-path?)))
procedure
(collection-file-pathfilecollection...+)->path?
file:path-string?
collection:path-string?
(collection-file-pathfile              
                    collection...+   
                    #:failfail-proc)->any
file:path-string?
collection:path-string?
fail-proc:(string?. -> .any)
procedure
(collection-pathcollection...+)->path?
collection:path-string?
(collection-pathcollection        
               ...+              
               #:failfail-proc)->any
collection:path-string?
fail-proc:(string?. -> .any)
parameter
(current-library-collection-paths)
->(listof(and/cpath?complete-path?))
(current-library-collection-pathspaths)->void?
paths:(listof(and/cpath-string?complete-path?))
parameter
(current-library-collection-links)
->(listof(or/c#f
    (and/cpath?complete-path?)
    (hash/c(or/c(and/csymbol?module-path?)#f)
    (listof(and/cpath?complete-path?)))))
(current-library-collection-linkspaths)->void?
paths:(listof(or/c#f
          (and/cpath-string?complete-path?)
          (hash/c(or/c(and/csymbol?module-path?)#f)
          (listof(and/cpath-string?complete-path?)))))
parameter
(use-user-specific-search-paths)->boolean?
(use-user-specific-search-pathson?)->void?
on?:any/c
parameter
(use-collection-link-paths)->boolean?
(use-collection-link-pathson?)->void?
on?:any/c
syntax
help
(helpstring...)
(helpid)
(helpid#:frommodule-path)
(help#:searchdatum...)
syntax
(enter!module-path)
(enter!#f)
(enter!module-pathflag...+)

flag=#:quiet
   |#:verbose-reload
   |#:verbose
   |#:dont-re-require-enter
procedure
(dynamic-rerequire module-path             
                 [#:verbosityverbosity])->void?
module-path:module-path?
verbosity:(or/c'all'reload'none)='reload
syntax
(traceid...)
syntax
(untraceid...)
parameter
(current-trace-notify)->(string?. -> .any)
(current-trace-notifyproc)->void?
proc:(string?. -> .any)
procedure
(trace-callidproc#:<kw>kw-arg...)->any/c
id:symbol?
proc:procedure?
kw-arg:any/c
parameter
(current-trace-print-args)->(->symbol?
                              list?
                              (listofkeyword?)
                              list?
                              number?
                              void?)
(current-trace-print-argstrace-print-args)->void?
trace-print-args:(->symbol?
                     list?
                     (listofkeyword?)
                     list?
                     number?
                     void?)
parameter
(current-trace-print-results)->(->symbol?
                                 list?
                                 number?
                                 any)
(current-trace-print-resultstrace-print-results)->void?
trace-print-results:(->symbol?
                        list?
                        number?
                        any)
parameter
(current-prefix-in)->string?
(current-prefix-inprefix)->void?
prefix:string?
parameter
(current-prefix-out)->string?
(current-prefix-outprefix)->void?
prefix:string?
